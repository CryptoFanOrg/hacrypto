package com.galois.hacrypto;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.PrintWriter;
import java.security.NoSuchAlgorithmException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Scanner;

import javax.management.RuntimeErrorException;

import org.stringtemplate.v4.ST;
import org.stringtemplate.v4.STGroup;
import org.stringtemplate.v4.STGroupDir;

/**
 * Responsible for language-independent parts of tests. Reads configuration
 * files, outputs shared test files and generates {@link KAT}s
 * 
 * @author Joey Dodds
 * 
 */
/**
 * @author jdodds
 * 
 */
public class Test {

	/**
	 * map from algorithm names to KATs
	 */
	private Map<String, KAT> kats = new HashMap<String, KAT>();
	/**
	 * map from algorithm names to autogenerated input file names
	 */
	private Map<String, List<String>> testFiles = new HashMap<String, List<String>>();

	private List<String> languages = new LinkedList<String>();

	private File outDir;
	private File testDir;
	public static final STGroup stGroup = new STGroupDir("tmp");

	/**
	 * @param testDir
	 *            The directory that holds the test definitions such as tests,
	 *            C_tests, and KAT files
	 * @param outDir
	 *            The directory that will contain all of the generated tests. If
	 *            this directory doesn't exist, it will be created. Some
	 *            exisiting files in this directory may be overwritten
	 */
	public Test(String testDir, String outDir) {
		this.outDir = new File(outDir);
		this.testDir = new File(testDir);
		this.outDir.mkdirs();
		this.testDir.mkdirs();
		File testFile = new File(testDir + File.separator + "tests");
		Scanner testReader = null;
		try {
			testReader = new Scanner(testFile);
		} catch (FileNotFoundException e) {
			System.err.println("File " + testFile.getAbsolutePath()
					+ " not found");
			e.printStackTrace();
		}
		while (testReader.hasNext()) {
			readTestLine(testReader.nextLine());
		}
	}

	/**
	 * Generates tests for each language specified in the tests files. Each of
	 * these language must have a "language"_tests file defined in
	 * {@link #testDir}
	 */
	public void generateLanguageTests() {
		for (String s : languages) {
			if (s.toUpperCase().equals("C")) {
				CTests ct = new CTests();
				ct.writeTestFiles(outDir, testDir, this);
			} else {
				throw new RuntimeErrorException(new Error(
						"Unsupported language " + s));
			}
		}
	}

	public KAT getKAT(String algorithm) {
		return kats.get(algorithm);
	}

	public List<String> getTestFile(String algorithm) {
		return testFiles.get(algorithm);
	}

	// TODO: More extensible solution
	/**
	 * @param algorithm
	 *            algorithm name given by the user
	 * @return a string that is usable by the java crypto library
	 */
	private String translateAlgorithm(String algorithm) {
		if (algorithm.equals("SHA256")) {
			return "SHA-256";
		}
		return algorithm;
	}

	/**
	 * Reads a single line of the test file. This can specify KAT and/or
	 * Comparison tests for a single algorithm
	 * 
	 * @param testReader
	 *            Scanner located after the algorithm of a line in the tests
	 *            file
	 * @param algorithm
	 *            algorithm that can be used by Java crypto API
	 */
	private void readTest(Scanner testReader, String algorithm) {
		String testType = testReader.next();

		if (testType.toUpperCase().equals("KAT")) {
			KAT kat = new KAT(testDir.getPath() + File.separator + algorithm
					+ "_KAT");
			kats.put(algorithm, kat);
		} else if (testType.toUpperCase().equals("COMPARE")) {
			createCompare(testReader, algorithm);
		}

		else {
			throw new RuntimeErrorException(new Error(
					"Unimplemented test type: " + testType));
		}
	}
	
	/**
	 * creates input and output files for a compare read in from the tests file
	 * @param testReader next string should be the test name after the compare
	 * @param algorithm 
	 */
	private void createCompare(Scanner testReader, String algorithm){
		KAT kat = null;
		String testName = testReader.next();
		String fileName = algorithm + testName + ".req";
		try {
			kat = new KAT(testReader.nextInt(), testReader.nextInt(),
					testReader.nextInt(), translateAlgorithm(algorithm));
		} catch (NoSuchAlgorithmException e) {
			e.printStackTrace();
		}

		Entry<String, String> inout = kat.simpleStrings(); //TODO only need output if changing to NIST file format
		/*
		 * for old test writing
		 * writeStringToOutDir(algorithm + "_compare_in", outDir.getPath(),
		 * 		inout.getKey());
		 */
		writeSTToOutDir(fileName, outDir.getPath(), kat.getReqFile(stGroup, algorithm));
		writeStringToOutDir(algorithm + testName + "_out", outDir.getPath(),
				inout.getValue());
		addTestFile(algorithm, testName);
	}

	/**
	 * this adds a filename to the one to many map testFiles
	 * @param algorithm algorithm to add the testfile for
	 * @param fileName 
	 */
	private void addTestFile(String algorithm, String fileName){
		List<String> value = testFiles.get(algorithm);
		if(value == null){
			value = new LinkedList<String>();
			testFiles.put(algorithm, value);
		}
		value.add(fileName);
	}

	/**
	 * Reads first word on the line. If it is languages, saves the languages to
	 * {@link #languages}. Otherwise calls {@link #readTest(Scanner, String)} to
	 * continue reading the line
	 * 
	 * @param line
	 *            entire line of a tests file
	 */
	private void readTestLine(String line) {
		Scanner lineReader = new Scanner(line);
		String algorithm = lineReader.next();
		if (algorithm.toUpperCase().equals("LANGUAGES")) {
			while (lineReader.hasNext()) {
				languages.add(lineReader.next());
			}
		}
		while (lineReader.hasNext()) {
			readTest(lineReader, algorithm);
		}

	}

	/**
	 * @param filename
	 *            name of the file to be created/overwritten
	 * @param outputDirectory
	 *            directory to write the file in
	 * @param toWrite
	 *            String to be written to the file
	 */
	public static void writeStringToOutDir(String filename,
			String outputDirectory, String toWrite) {
		File outfile = new File(outputDirectory + File.separator + filename);
		try {
			outfile.createNewFile();
		} catch (IOException e) {
			System.err.println("could not create file "
					+ outfile.getAbsolutePath());
			e.printStackTrace();
		}

		try {
			PrintWriter out = new PrintWriter(outfile);
			out.print(toWrite);
			out.close();
		} catch (IOException e) {
			System.err.println("Problem writing to file "
					+ outfile.getAbsolutePath());
			e.printStackTrace();
		}
	}

	/**
	 * Same as {@link #writeStringToOutDir(String, String, String)} but uses the
	 * built in file writing of a stringtemplate
	 * 
	 * @param filename
	 *            name of the file to be created/overwritten
	 * @param outputDirectory
	 *            directory to write the file in
	 * @param toWrite
	 *            StringTemplate to render to a file
	 */
	public static void writeSTToOutDir(String filename, String outputDirectory,
			ST toWrite) {
		File outfile = new File(outputDirectory + File.separator + filename);

		try {
			outfile.createNewFile();
		} catch (IOException e) {
			System.err.println("could not create file "
					+ outfile.getAbsolutePath());
			e.printStackTrace();
		}

		try {
			toWrite.write(outfile, null);// TODO: figure out what to do for
											// second argument
		} catch (IOException e) {
			System.err.println("Problem writing to file "
					+ outfile.getAbsolutePath());
			e.printStackTrace();
		}
	}

	public static void main(String args[]) {
		new Test("test_defs", "../callsha/tests2").generateLanguageTests();
	}

}
