package com.galois.hacrypto.req.input;

import java.security.InvalidKeyException;
import java.util.AbstractMap.SimpleEntry;
import java.util.Map.Entry;

import javax.crypto.spec.DESedeKeySpec;

import com.galois.hacrypto.req.length.InputLength;
import com.galois.hacrypto.test.Util;

/**
 * An input that is a random string of bytes
 * 
 * @author jdodds
 * @author dmz
 */
public class RandomInput extends AbstractInput {

	private InputLength inputLength;
	private boolean parity;
	
	/**
	 * @param name
	 * @param il
	 *            Determines the length of each advancing input
	 * @param parity true if the low-order bits of the generated bytes
	 *  should be odd parity bits, false otherwise
	 */
	public RandomInput(String name, InputLength il, boolean parity) {
		super(name);
		this.inputLength = il;
		this.parity = parity;
	}

	@Override
	public boolean hasNextInput() {
		return inputLength.hasNextLength();
	}

	@Override
	public InputLength getInputLength() {
		return inputLength;
	}

	@Override
	public Entry<String, byte[]> toReqString() {
		StringBuilder sb = new StringBuilder(name);
		sb.append(" = ");

		byte[] val = new byte[inputLength.getLength() / 8];
		Util.rand.nextBytes(val);

		// adjust the parity of each byte, if necessary; used mainly for Triple-DES
		if (parity) {
			for (int i = 0; i < val.length; i++) {
				int b = val[i];
				val[i] = (byte)((b & 0xfe) | ((((b >> 1) ^ (b >> 2) ^ (b >> 3) ^ (b >> 4) ^ 
						(b >> 5) ^ (b >> 6) ^ (b >> 7)) ^ 0x01) & 0x01));
			}
		}

		String valString = Util.byteArrayToHexString(val);
		if (val.length == 0) {
			valString = "00"; // length-zero strings are represented as "00" for some reason
		}
		sb.append(valString);
		return new SimpleEntry<String, byte[]>(sb.toString(), val);
	}

}
