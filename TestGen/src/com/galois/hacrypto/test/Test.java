package com.galois.hacrypto.test;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.security.NoSuchAlgorithmException;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Scanner;

import javax.management.RuntimeErrorException;

import org.stringtemplate.v4.STGroup;
import org.stringtemplate.v4.STGroupDir;

import com.galois.hacrypto.req.*;

/**
 * Responsible for language-independent parts of tests. Reads configuration
 * files, outputs shared test files and generates {@link KAT}s
 * 
 * @author Joey Dodds
 * 
 */
/**
 * @author jdodds
 * 
 */
public class Test {

	/**
	 * map from algorithm names to KATs
	 */
	private Map<String, KAT> kats = new HashMap<String, KAT>();
	/**
	 * map from algorithm names to autogenerated input file names
	 */
	private Map<String, List<String>> testFiles = new HashMap<String, List<String>>();

	private List<String> languages = new LinkedList<String>();

	private File outDir;
	private File testDir;
	public static final STGroup stGroup = new STGroupDir("tmp");

	/**
	 * @param testDir
	 *            The directory that holds the test definitions such as tests,
	 *            C_tests, and KAT files
	 * @param outDir
	 *            The directory that will contain all of the generated tests. If
	 *            this directory doesn't exist, it will be created. Some
	 *            exisiting files in this directory may be overwritten
	 */
	public Test(String testDir, String outDir) {
		this.outDir = new File(outDir);
		this.testDir = new File(testDir);
		this.outDir.mkdirs();
		File testFile = new File(testDir + File.separator + "tests");
		Scanner testReader = null;
		try {
			testReader = new Scanner(testFile);
		} catch (FileNotFoundException e) {
			System.err.println("File " + testFile.getAbsolutePath()
					+ " not found");
			e.printStackTrace();
		}
		while (testReader.hasNext()) {
			readTestLine(testReader.nextLine());
		}
	}

	/**
	 * Generates tests for each language specified in the tests files. Each of
	 * these language must have a "language"_tests file defined in
	 * {@link #testDir}
	 */
	public void generateLanguageTests() {
		for (String s : languages) {
			if (s.toUpperCase().equals("C")) {
				CTests ct = new CTests();
				ct.writeTestFiles(outDir, testDir, this);
			} else {
				throw new RuntimeErrorException(new Error(
						"Unsupported language " + s));
			}
		}
	}

	public KAT getKAT(String algorithm) {
		return kats.get(algorithm);
	}

	public List<String> getTestFile(String algorithm) {
		return testFiles.get(algorithm);
	}

	// TODO: More extensible solution
	/**
	 * @param algorithm
	 *            algorithm name given by the user
	 * @return a string that is usable by the java crypto library
	 */
	private String translateAlgorithm(String algorithm) {
		if (algorithm.equals("SHA256")) {
			return "SHA-256";
		}
		return algorithm;
	}

	/**
	 * Reads a single line of the test file. This can specify KAT and/or
	 * Comparison tests for a single algorithm
	 * 
	 * @param testReader
	 *            Scanner located after the algorithm of a line in the tests
	 *            file
	 * @param algorithm
	 *            algorithm that can be used by Java crypto API
	 */
	private void readTest(Scanner testReader, String algorithm) {
		String testType = testReader.next();

		if (testType.toUpperCase().equals("KAT")) {
			KAT kat = new KAT(testDir.getPath() + File.separator + algorithm
					+ "_KAT");
			kats.put(algorithm, kat);
		} else if (testType.toUpperCase().equals("COMPARE")) {
			createCompare(testReader, algorithm, false);
		} else if (testType.toUpperCase().equals("STEP")) {
			createCompare(testReader, algorithm, true);
		} else if (testType.toUpperCase().equals("FILE")) {
			createFile(testReader.next(), algorithm);
		}

		else {
			throw new RuntimeErrorException(new Error(
					"Unimplemented test type: " + testType));
		}
	}

	private void createFile(String fileName, String algorithm) {
		Req r;
		fileName = fileName.replace('/', File.separatorChar);
		String dir = fileName.substring(0,
				fileName.lastIndexOf(File.separatorChar));
		new File(outDir.getPath() + File.separator + "req" + File.separator
				+ dir).mkdirs();
		try {
			r = new Req(testDir + File.separator + fileName);
		} catch (IOException e) {
			throw new RuntimeException("could not read file: " + testDir
					+ File.separator + fileName);
		}

		Entry<String, String> reqrsp = r.creatReqRsp();

		Util.writeStringToOutDir(fileName + ".req", outDir.getPath()
				+ File.separator + "req", reqrsp.getKey());
		File rspdir = new File(outDir.getPath() + File.separator + "rsp"
				+ File.separator + dir);
		rspdir.mkdirs();
		Util.writeStringToOutDir(fileName + ".rsp", outDir.getPath()
				+ File.separator + "rsp", reqrsp.getValue());
	}

	/**
	 * creates input and output files for a compare read in from the tests file
	 * 
	 * @param testReader
	 *            next string should be the test name after the compare
	 * @param algorithm
	 */
	private void createCompare(Scanner testReader, String algorithm,
			boolean isStep) {
		KAT kat = new KAT();
		String testName = testReader.next();
		String fileName = algorithm + testName + ".req";
		try {
			if (isStep) {
				kat.createStep(testReader.nextInt(), testReader.nextInt(),
						testReader.nextInt(), translateAlgorithm(algorithm));
			} else {
				kat.createRandom(testReader.nextInt(), testReader.nextInt(),
						testReader.nextInt(), translateAlgorithm(algorithm));
			}
		} catch (NoSuchAlgorithmException e) {
			e.printStackTrace();
		}

		Entry<String, String> inout = kat.simpleStrings(); // TODO only need
															// output if
															// changing to NIST
															// file format
		/*
		 * for old test writing writeStringToOutDir(algorithm + "_compare_in",
		 * outDir.getPath(), inout.getKey());
		 */
		Util.writeSTToOutDir(fileName, outDir.getPath(),
				kat.getReqFile(stGroup, algorithm));
		Util.writeStringToOutDir(algorithm + testName + "_out",
				outDir.getPath(), inout.getValue());
		addTestFile(algorithm, testName);
	}

	/**
	 * this adds a filename to the one to many map testFiles
	 * 
	 * @param algorithm
	 *            algorithm to add the testfile for
	 * @param fileName
	 */
	private void addTestFile(String algorithm, String fileName) {
		List<String> value = testFiles.get(algorithm);
		if (value == null) {
			value = new LinkedList<String>();
			testFiles.put(algorithm, value);
		}
		value.add(fileName);
	}

	/**
	 * Reads first word on the line. If it is languages, saves the languages to
	 * {@link #languages}. Otherwise calls {@link #readTest(Scanner, String)} to
	 * continue reading the line
	 * 
	 * @param line
	 *            entire line of a tests file
	 */
	private void readTestLine(String line) {
		Scanner lineReader = new Scanner(line);
		String algorithm = lineReader.next();
		if (algorithm.toUpperCase().equals("LANGUAGES")) {
			while (lineReader.hasNext()) {
				languages.add(lineReader.next());
			}
		}
		while (lineReader.hasNext()) {
			readTest(lineReader, algorithm);
		}

	}

	public static void main(String args[]) {
		new Test("test_defs", "output")/* .generateLanguageTests() */;
	}

}
