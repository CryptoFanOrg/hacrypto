module aes where

type Nk = 4
type Nb = 4
type Nr = 6 + Nk


type Word       = [4][8]


/* Round *********************************************************************/

// The state is represented in column-major mode.
type State = [4]Word

type KeySize = Nk * 32

msgToState : [128] -> State
msgToState msg = split (split msg)

stateToMsg : State -> [128]
stateToMsg s = join (join s)

AESEncrypt : [KeySize] -> [128] -> [128]
AESEncrypt key pt = join (join (AESFinalRound final finalKey))
  where
  (initialKey,roundKeys,finalKey) = KeySchedule key
  state0 = AddRoundKey (msgToState pt) initialKey
  final  = AESRounds state0 roundKeys

AESRounds : State -> [Nr-1]RoundKey -> State
AESRounds state0 roundKeys = rounds ! 0
  where
  rounds = [state0] # [ AESRound s rk | s  <- rounds
                                      | rk <- roundKeys ]

AESFinalRound : State -> FinalKey -> State
AESFinalRound [s0,s1,s2,s3] fk = AddRoundKey s' fk
  where
  // merge ByteSub and ShiftRows
  s' = [ [ Sbox (s0 @ 0), Sbox (s1 @ 1), Sbox (s2 @ 2), Sbox (s3 @ 3) ]
       , [ Sbox (s1 @ 0), Sbox (s2 @ 1), Sbox (s3 @ 2), Sbox (s0 @ 3) ]
       , [ Sbox (s2 @ 0), Sbox (s3 @ 1), Sbox (s0 @ 2), Sbox (s1 @ 3) ]
       , [ Sbox (s3 @ 0), Sbox (s0 @ 1), Sbox (s1 @ 2), Sbox (s2 @ 3) ]
       ]


AESRound : State -> RoundKey -> State
AESRound [s0,s1,s2,s3] rk = AddRoundKey s' rk
  where
  // merge ByteSub, ShiftRows, then apply MixColumn
  s' =
    [ MixColumn (Sbox (s0 @ 0)) (Sbox (s1 @ 1)) (Sbox (s2 @ 2)) (Sbox (s3 @ 3))
    , MixColumn (Sbox (s1 @ 0)) (Sbox (s2 @ 1)) (Sbox (s3 @ 2)) (Sbox (s0 @ 3))
    , MixColumn (Sbox (s2 @ 0)) (Sbox (s3 @ 1)) (Sbox (s0 @ 2)) (Sbox (s1 @ 3))
    , MixColumn (Sbox (s3 @ 0)) (Sbox (s0 @ 1)) (Sbox (s1 @ 2)) (Sbox (s2 @ 3))
    ]

/**
 * Mix columns, assuming that the rows have already been shifted.
 */
MixColumns : State -> State
MixColumns s =
  [ MixColumn (s @ 0 @ 0) (s @ 0 @ 1) (s @ 0 @ 2) (s @ 0 @ 3)
  , MixColumn (s @ 1 @ 0) (s @ 1 @ 1) (s @ 1 @ 2) (s @ 1 @ 3)
  , MixColumn (s @ 2 @ 0) (s @ 2 @ 1) (s @ 2 @ 2) (s @ 2 @ 3)
  , MixColumn (s @ 3 @ 0) (s @ 3 @ 1) (s @ 3 @ 2) (s @ 3 @ 3) ]

AddRoundKey : State -> RoundKey -> State
AddRoundKey s rk = s ^ rk

/**
 * Multiply the column vector by the * polynomial <| 3x^^3 + x^^2 + x + 2 |>,
 * represented as the matrix:
 *
 * | 2 3 1 1 |
 * | 1 2 3 1 |
 * | 1 1 2 3 |
 * | 3 1 1 2 |
 *
 */
MixColumn : [8] -> [8] -> [8] -> [8] -> Word
MixColumn a0 a1 a2 a3 =
  [ (gtimes2 @ a0) ^ (gtimes3 @ a1) ^            a2  ^            a3
  ,            a0  ^ (gtimes2 @ a1) ^ (gtimes3 @ a2) ^            a3
  ,            a0  ^            a1  ^ (gtimes2 @ a2) ^ (gtimes3 @ a3)
  , (gtimes3 @ a0) ^            a1  ^            a2  ^ (gtimes2 @ a3) ]


/* Galois Field 2^8 **********************************************************/

gtimes : [8] -> [8] -> [8]
gtimes x y = pmod (pmult x y) <| x^^8 + x^^4 + x^^3 + x + 1 |>

/**
 * The x2 table.
 */
gtimes2 : [256][8]
gtimes2 = [ gtimes b 2 | b <- [0 .. 255] ]

/**
 * The x3 table
 */
gtimes3 : [256][8]
gtimes3 = [ gtimes b 3 | b <- [0 .. 255] ]


/* Key Expansion *************************************************************/

// The round key is encoded in column-major mode
type RoundKey   = [4]Word
type InitialKey = RoundKey
type FinalKey   = RoundKey
type KS = (InitialKey, [Nr - 1]RoundKey, FinalKey)

KeySchedule : [KeySize] -> KS
KeySchedule key = (initialKey, groupBy roundKeys, finalKey)
  where
  (initialKey,rest)    = splitAt `{4} (KeyExpansion (split (split key)))
  (roundKeys,finalKey) = splitAt `{_,4} rest

KeyExpansion : [Nk]Word -> [(Nr+1)*4]Word
KeyExpansion seed = take W
  where
  W : [inf]Word
  W = seed # [ NextWord i old prev
             | i    <- [`Nk ... ]
             | old  <- W              // W[i - Nk]
             | prev <- drop `{Nk-1} W // W[i - 1 ]
             ]

NextWord : [6] -> Word -> Word -> Word
NextWord i old prev = old ^ temp
  where
  nk : [6]
  nk = `Nk

  temp : Word
  temp = if i % `Nk == 0
            then SubByte (RotByte prev) ^ (Rcon @ /* (i / `Nk) */ (i >> 2))
            /* this case is only for Nk > 4, so we'll skip it to simplify
             * code generation
            else if (nk > 6) && (i % nk == 4)
                    then SubByte prev */
                    else prev

Rcon : [16]Word
Rcon =
 [ [0x8d, 0x00, 0x00, 0x00]
 , [0x01, 0x00, 0x00, 0x00]
 , [0x02, 0x00, 0x00, 0x00]
 , [0x04, 0x00, 0x00, 0x00]
 , [0x08, 0x00, 0x00, 0x00]
 , [0x10, 0x00, 0x00, 0x00]
 , [0x20, 0x00, 0x00, 0x00]
 , [0x40, 0x00, 0x00, 0x00]
 , [0x80, 0x00, 0x00, 0x00]
 , [0x1b, 0x00, 0x00, 0x00]
 , [0x36, 0x00, 0x00, 0x00]
 , [0x6c, 0x00, 0x00, 0x00]
 , [0xd8, 0x00, 0x00, 0x00]
 , [0xab, 0x00, 0x00, 0x00]
 , [0x4d, 0x00, 0x00, 0x00]
 , [0x9a, 0x00, 0x00, 0x00]
 ]

RotByte : Word -> Word
RotByte w = w <<< 1

SubByte : Word -> Word
SubByte [a,b,c,d] = [Sbox a, Sbox b, Sbox c, Sbox d]


/* SBox **********************************************************************/

Sbox : [8] -> [8]
Sbox n = sbox @ n

sbox : [256][8]
sbox =
  [0x63,0x7c,0x77,0x7b,0xf2,0x6b,0x6f,0xc5,0x30,0x01,0x67,0x2b
  ,0xfe,0xd7,0xab,0x76,0xca,0x82,0xc9,0x7d,0xfa,0x59,0x47,0xf0,0xad,0xd4
  ,0xa2,0xaf,0x9c,0xa4,0x72,0xc0,0xb7,0xfd,0x93,0x26,0x36,0x3f,0xf7,0xcc
  ,0x34,0xa5,0xe5,0xf1,0x71,0xd8,0x31,0x15,0x04,0xc7,0x23,0xc3,0x18,0x96
  ,0x05,0x9a,0x07,0x12,0x80,0xe2,0xeb,0x27,0xb2,0x75,0x09,0x83,0x2c,0x1a
  ,0x1b,0x6e,0x5a,0xa0,0x52,0x3b,0xd6,0xb3,0x29,0xe3,0x2f,0x84,0x53,0xd1
  ,0x00,0xed,0x20,0xfc,0xb1,0x5b,0x6a,0xcb,0xbe,0x39,0x4a,0x4c,0x58,0xcf
  ,0xd0,0xef,0xaa,0xfb,0x43,0x4d,0x33,0x85,0x45,0xf9,0x02,0x7f,0x50,0x3c
  ,0x9f,0xa8,0x51,0xa3,0x40,0x8f,0x92,0x9d,0x38,0xf5,0xbc,0xb6,0xda,0x21
  ,0x10,0xff,0xf3,0xd2,0xcd,0x0c,0x13,0xec,0x5f,0x97,0x44,0x17,0xc4,0xa7
  ,0x7e,0x3d,0x64,0x5d,0x19,0x73,0x60,0x81,0x4f,0xdc,0x22,0x2a,0x90,0x88
  ,0x46,0xee,0xb8,0x14,0xde,0x5e,0x0b,0xdb,0xe0,0x32,0x3a,0x0a,0x49,0x06
  ,0x24,0x5c,0xc2,0xd3,0xac,0x62,0x91,0x95,0xe4,0x79,0xe7,0xc8,0x37,0x6d
  ,0x8d,0xd5,0x4e,0xa9,0x6c,0x56,0xf4,0xea,0x65,0x7a,0xae,0x08,0xba,0x78
  ,0x25,0x2e,0x1c,0xa6,0xb4,0xc6,0xe8,0xdd,0x74,0x1f,0x4b,0xbd,0x8b,0x8a
  ,0x70,0x3e,0xb5,0x66,0x48,0x03,0xf6,0x0e,0x61,0x35,0x57,0xb9,0x86,0xc1
  ,0x1d,0x9e,0xe1,0xf8,0x98,0x11,0x69,0xd9,0x8e,0x94,0x9b,0x1e,0x87,0xe9
  ,0xce,0x55,0x28,0xdf,0x8c,0xa1,0x89,0x0d,0xbf,0xe6,0x42,0x68,0x41,0x99
  ,0x2d,0x0f,0xb0,0x54,0xbb,0x16]


/* Test Vectors **************************************************************/

type AESTest = { key: [KeySize], input: [128], output: [128] }

test_aes      : AESTest -> Bit
test_aes test = AESEncrypt test.key test.input == test.output

test1 : AESTest
test1 =
  { key    = 0x2b7e151628aed2a6abf7158809cf4f3c
  , input  = 0x3243f6a8885a308d313198a2e0370734
  , output = 0x3925841d02dc09fbdc118597196a0b32
  }

test2 : AESTest
test2 =
  { key    = 0x000102030405060708090a0b0c0d0e0f
  , input  = 0x00112233445566778899aabbccddeeff
  , output = 0x69c4e0d86a7b0430d8cdb78070b4c55a
  }

property prop_test1 = test_aes test1
property prop_test2 = test_aes test2
property prop_tests = prop_test1 && prop_test2

