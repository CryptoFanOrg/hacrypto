diff -ruN ../openssh-6.0p1.virgin/auth2-hostbased.c ./auth2-hostbased.c
--- ../openssh-6.0p1.virgin/auth2-hostbased.c	2010-08-04 23:04:50.000000000 -0400
+++ ./auth2-hostbased.c	2012-09-03 11:08:42.769416200 -0400
@@ -197,13 +197,13 @@
 	if (host_status == HOST_OK) {
 		if (key_is_cert(key)) {
 			fp = key_fingerprint(key->cert->signature_key,
-			    SSH_FP_MD5, SSH_FP_HEX);
+			    key_fingerprint_alg(), SSH_FP_HEX);
 			verbose("Accepted certificate ID \"%s\" signed by "
 			    "%s CA %s from %s@%s", key->cert->key_id,
 			    key_type(key->cert->signature_key), fp,
 			    cuser, lookup);
 		} else {
-			fp = key_fingerprint(key, SSH_FP_MD5, SSH_FP_HEX);
+			fp = key_fingerprint(key, key_fingerprint_alg(), SSH_FP_HEX);
 			verbose("Accepted %s public key %s from %s@%s",
 			    key_type(key), fp, cuser, lookup);
 		}
diff -ruN ../openssh-6.0p1.virgin/auth2-pubkey.c ./auth2-pubkey.c
--- ../openssh-6.0p1.virgin/auth2-pubkey.c	2011-10-02 04:00:00.000000000 -0400
+++ ./auth2-pubkey.c	2012-09-03 11:08:47.169445497 -0400
@@ -320,7 +320,7 @@
 				continue;
 			if (!key_is_cert_authority)
 				continue;
-			fp = key_fingerprint(found, SSH_FP_MD5,
+			fp = key_fingerprint(found, key_fingerprint_alg(),
 			    SSH_FP_HEX);
 			debug("matching CA found: file %s, line %lu, %s %s",
 			    file, linenum, key_type(found), fp);
@@ -363,7 +363,7 @@
 			found_key = 1;
 			debug("matching key found: file %s, line %lu",
 			    file, linenum);
-			fp = key_fingerprint(found, SSH_FP_MD5, SSH_FP_HEX);
+			fp = key_fingerprint(found, key_fingerprint_alg(), SSH_FP_HEX);
 			verbose("Found matching %s key: %s",
 			    key_type(found), fp);
 			xfree(fp);
@@ -390,7 +390,7 @@
 		return 0;
 
 	ca_fp = key_fingerprint(key->cert->signature_key,
-	    SSH_FP_MD5, SSH_FP_HEX);
+	    key_fingerprint_alg(), SSH_FP_HEX);
 
 	if (key_in_file(key->cert->signature_key,
 	    options.trusted_user_ca_keys, 1) != 1) {
diff -ruN ../openssh-6.0p1.virgin/auth.c ./auth.c
--- ../openssh-6.0p1.virgin/auth.c	2011-05-29 07:40:42.000000000 -0400
+++ ./auth.c	2012-09-03 11:08:51.569465144 -0400
@@ -624,7 +624,7 @@
 		return 1;
 	case 1:
 		/* Key revoked */
-		key_fp = key_fingerprint(key, SSH_FP_MD5, SSH_FP_HEX);
+		key_fp = key_fingerprint(key, key_fingerprint_alg(), SSH_FP_HEX);
 		error("WARNING: authentication attempt with a revoked "
 		    "%s key %s ", key_type(key), key_fp);
 		xfree(key_fp);
diff -ruN ../openssh-6.0p1.virgin/auth-rsa.c ./auth-rsa.c
--- ../openssh-6.0p1.virgin/auth-rsa.c	2011-05-29 07:39:38.000000000 -0400
+++ ./auth-rsa.c	2012-09-02 14:47:58.210247914 -0400
@@ -326,7 +326,7 @@
 	 * options; this will be reset if the options cause the
 	 * authentication to be rejected.
 	 */
-	fp = key_fingerprint(key, SSH_FP_MD5, SSH_FP_HEX);
+	fp = key_fingerprint(key, key_fingerprint_alg(), SSH_FP_HEX);
 	verbose("Found matching %s key: %s",
 	    key_type(key), fp);
 	xfree(fp);
--- ../openssh-6.0p1.virgin/cipher.c	2009-01-28 00:38:41.000000000 -0500
+++ cipher.c	2012-09-05 07:16:26.281357489 -0400
@@ -54,10 +54,9 @@
 extern const EVP_CIPHER *evp_ssh1_bf(void);
 extern const EVP_CIPHER *evp_ssh1_3des(void);
 extern void ssh1_3des_iv(EVP_CIPHER_CTX *, int, u_char *, int);
-extern const EVP_CIPHER *evp_aes_128_ctr(void);
 extern void ssh_aes_ctr_iv(EVP_CIPHER_CTX *, int, u_char *, u_int);
 
-struct Cipher {
+static struct Cipher {
 	char	*name;
 	int	number;		/* for ssh1 only */
 	u_int	block_size;
@@ -82,15 +81,47 @@
 	{ "aes256-cbc",		SSH_CIPHER_SSH2, 16, 32, 0, 1, EVP_aes_256_cbc },
 	{ "rijndael-cbc@lysator.liu.se",
 				SSH_CIPHER_SSH2, 16, 32, 0, 1, EVP_aes_256_cbc },
-	{ "aes128-ctr",		SSH_CIPHER_SSH2, 16, 16, 0, 0, evp_aes_128_ctr },
-	{ "aes192-ctr",		SSH_CIPHER_SSH2, 16, 24, 0, 0, evp_aes_128_ctr },
-	{ "aes256-ctr",		SSH_CIPHER_SSH2, 16, 32, 0, 0, evp_aes_128_ctr },
+	{ "aes128-ctr",		SSH_CIPHER_SSH2, 16, 16, 0, 0, EVP_aes_128_ctr },
+	{ "aes192-ctr",		SSH_CIPHER_SSH2, 16, 24, 0, 0, EVP_aes_192_ctr },
+	{ "aes256-ctr",		SSH_CIPHER_SSH2, 16, 32, 0, 0, EVP_aes_256_ctr },
 #ifdef USE_CIPHER_ACSS
 	{ "acss@openssh.org",	SSH_CIPHER_SSH2, 16, 5, 0, 0, EVP_acss },
 #endif
 	{ NULL,			SSH_CIPHER_INVALID, 0, 0, 0, 0, NULL }
 };
 
+#ifdef OPENSSL_FIPS_CAPABLE
+/* subset of the ciphers table above which is relevant for FIPS140 usage */
+static struct Cipher fips_ciphers[] = {
+	{ "none",		SSH_CIPHER_NONE, 8, 0, 0, 0, EVP_enc_null },
+	{ "3des",		SSH_CIPHER_3DES, 8, 16, 0, 1, evp_ssh1_3des },
+	{ "3des-cbc",		SSH_CIPHER_SSH2, 8, 24, 0, 1, EVP_des_ede3_cbc },
+	{ "aes128-cbc",		SSH_CIPHER_SSH2, 16, 16, 0, 1, EVP_aes_128_cbc },
+	{ "aes192-cbc",		SSH_CIPHER_SSH2, 16, 24, 0, 1, EVP_aes_192_cbc },
+	{ "aes256-cbc",		SSH_CIPHER_SSH2, 16, 32, 0, 1, EVP_aes_256_cbc },
+	{ "rijndael-cbc@lysator.liu.se",
+				SSH_CIPHER_SSH2, 16, 32, 0, 1, EVP_aes_256_cbc },
+	{ "aes128-ctr",		SSH_CIPHER_SSH2, 16, 16, 0, 0, EVP_aes_128_ctr },
+	{ "aes192-ctr",		SSH_CIPHER_SSH2, 16, 24, 0, 0, EVP_aes_192_ctr },
+	{ "aes256-ctr",		SSH_CIPHER_SSH2, 16, 32, 0, 0, EVP_aes_256_ctr },
+	{ NULL,			SSH_CIPHER_INVALID, 0, 0, 0, 0, NULL }
+};
+#endif /* OPENSSL_FIPS_CAPABLE */
+
+/* return the correct list of ciphers depending on what mode we are 
+ * operating in (non-FIPS140 or FIPS140 mode)
+ */
+struct Cipher *ciphers_list(void) 
+{
+#ifdef OPENSSL_FIPS_CAPABLE
+  if (FIPS_mode()) 
+    return fips_ciphers;
+  else
+#endif /* OPENSSL_FIPS_CAPABLE */
+    return ciphers;
+}
+
+
 /*--*/
 
 u_int
@@ -133,7 +164,7 @@
 cipher_by_name(const char *name)
 {
 	Cipher *c;
-	for (c = ciphers; c->name != NULL; c++)
+	for (c = ciphers_list(); c->name != NULL; c++)
 		if (strcmp(c->name, name) == 0)
 			return c;
 	return NULL;
@@ -143,7 +174,7 @@
 cipher_by_number(int id)
 {
 	Cipher *c;
-	for (c = ciphers; c->name != NULL; c++)
+	for (c = ciphers_list(); c->name != NULL; c++)
 		if (c->number == id)
 			return c;
 	return NULL;
@@ -187,7 +218,7 @@
 	Cipher *c;
 	if (name == NULL)
 		return -1;
-	for (c = ciphers; c->name != NULL; c++)
+	for (c = ciphers_list(); c->name != NULL; c++)
 		if (strcasecmp(c->name, name) == 0)
 			return c->number;
 	return -1;
@@ -294,21 +325,19 @@
  * passphrase and using the resulting 16 bytes as the key.
  */
 
-void
+int
 cipher_set_key_string(CipherContext *cc, Cipher *cipher,
     const char *passphrase, int do_encrypt)
 {
-	MD5_CTX md;
 	u_char digest[16];
 
-	MD5_Init(&md);
-	MD5_Update(&md, (const u_char *)passphrase, strlen(passphrase));
-	MD5_Final(digest, &md);
+	if (EVP_Digest(passphrase, strlen(passphrase), digest, NULL, EVP_md5(), NULL) <= 0)
+	  return -1;
 
 	cipher_init(cc, cipher, digest, 16, NULL, 0, do_encrypt);
 
 	memset(digest, 0, sizeof(digest));
-	memset(&md, 0, sizeof(md));
+	return 0;
 }
 
 /*
@@ -351,10 +380,7 @@
 			ssh_rijndael_iv(&cc->evp, 0, iv, len);
 		else
 #endif
-		if (c->evptype == evp_aes_128_ctr)
-			ssh_aes_ctr_iv(&cc->evp, 0, iv, len);
-		else
-			memcpy(iv, cc->evp.iv, len);
+		memcpy(iv, cc->evp.iv, len);
 		break;
 	case SSH_CIPHER_3DES:
 		ssh1_3des_iv(&cc->evp, 0, iv, 24);
@@ -382,10 +408,7 @@
 			ssh_rijndael_iv(&cc->evp, 1, iv, evplen);
 		else
 #endif
-		if (c->evptype == evp_aes_128_ctr)
-			ssh_aes_ctr_iv(&cc->evp, 1, iv, evplen);
-		else
-			memcpy(cc->evp.iv, iv, evplen);
+		memcpy(cc->evp.iv, iv, evplen);
 		break;
 	case SSH_CIPHER_3DES:
 		ssh1_3des_iv(&cc->evp, 1, iv, 24);
@@ -409,7 +432,12 @@
 	Cipher *c = cc->cipher;
 	int plen = 0;
 
+#ifdef OPENSSL_FIPS_CAPABLE
+	if ((FIPS_mode() && (c->evptype == EVP_acss)) ||
+		(c->evptype == EVP_rc4 || c->evptype == EVP_acss)) {
+#else
 	if (c->evptype == EVP_rc4 || c->evptype == EVP_acss) {
+#endif
 		plen = EVP_X_STATE_LEN(cc->evp);
 		if (dat == NULL)
 			return (plen);
@@ -424,7 +452,12 @@
 	Cipher *c = cc->cipher;
 	int plen;
 
+#ifdef OPENSSL_FIPS_CAPABLE
+	if ((FIPS_mode() && (c->evptype == EVP_acss)) ||
+		(c->evptype == EVP_rc4 || c->evptype == EVP_acss)) {
+#else
 	if (c->evptype == EVP_rc4 || c->evptype == EVP_acss) {
+#endif
 		plen = EVP_X_STATE_LEN(cc->evp);
 		memcpy(EVP_X_STATE(cc->evp), dat, plen);
 	}
diff -ruN ../openssh-6.0p1.virgin/cipher-ctr.c ./cipher-ctr.c
--- ../openssh-6.0p1.virgin/cipher-ctr.c	2010-10-07 07:06:42.000000000 -0400
+++ ./cipher-ctr.c	1969-12-31 19:00:00.000000000 -0500
@@ -1,146 +0,0 @@
-/* $OpenBSD: cipher-ctr.c,v 1.11 2010/10/01 23:05:32 djm Exp $ */
-/*
- * Copyright (c) 2003 Markus Friedl <markus@openbsd.org>
- *
- * Permission to use, copy, modify, and distribute this software for any
- * purpose with or without fee is hereby granted, provided that the above
- * copyright notice and this permission notice appear in all copies.
- *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
- * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- */
-#include "includes.h"
-
-#include <sys/types.h>
-
-#include <stdarg.h>
-#include <string.h>
-
-#include <openssl/evp.h>
-
-#include "xmalloc.h"
-#include "log.h"
-
-/* compatibility with old or broken OpenSSL versions */
-#include "openbsd-compat/openssl-compat.h"
-
-#ifndef USE_BUILTIN_RIJNDAEL
-#include <openssl/aes.h>
-#endif
-
-const EVP_CIPHER *evp_aes_128_ctr(void);
-void ssh_aes_ctr_iv(EVP_CIPHER_CTX *, int, u_char *, size_t);
-
-struct ssh_aes_ctr_ctx
-{
-	AES_KEY		aes_ctx;
-	u_char		aes_counter[AES_BLOCK_SIZE];
-};
-
-/*
- * increment counter 'ctr',
- * the counter is of size 'len' bytes and stored in network-byte-order.
- * (LSB at ctr[len-1], MSB at ctr[0])
- */
-static void
-ssh_ctr_inc(u_char *ctr, size_t len)
-{
-	int i;
-
-	for (i = len - 1; i >= 0; i--)
-		if (++ctr[i])	/* continue on overflow */
-			return;
-}
-
-static int
-ssh_aes_ctr(EVP_CIPHER_CTX *ctx, u_char *dest, const u_char *src,
-    LIBCRYPTO_EVP_INL_TYPE len)
-{
-	struct ssh_aes_ctr_ctx *c;
-	size_t n = 0;
-	u_char buf[AES_BLOCK_SIZE];
-
-	if (len == 0)
-		return (1);
-	if ((c = EVP_CIPHER_CTX_get_app_data(ctx)) == NULL)
-		return (0);
-
-	while ((len--) > 0) {
-		if (n == 0) {
-			AES_encrypt(c->aes_counter, buf, &c->aes_ctx);
-			ssh_ctr_inc(c->aes_counter, AES_BLOCK_SIZE);
-		}
-		*(dest++) = *(src++) ^ buf[n];
-		n = (n + 1) % AES_BLOCK_SIZE;
-	}
-	return (1);
-}
-
-static int
-ssh_aes_ctr_init(EVP_CIPHER_CTX *ctx, const u_char *key, const u_char *iv,
-    int enc)
-{
-	struct ssh_aes_ctr_ctx *c;
-
-	if ((c = EVP_CIPHER_CTX_get_app_data(ctx)) == NULL) {
-		c = xmalloc(sizeof(*c));
-		EVP_CIPHER_CTX_set_app_data(ctx, c);
-	}
-	if (key != NULL)
-		AES_set_encrypt_key(key, EVP_CIPHER_CTX_key_length(ctx) * 8,
-		    &c->aes_ctx);
-	if (iv != NULL)
-		memcpy(c->aes_counter, iv, AES_BLOCK_SIZE);
-	return (1);
-}
-
-static int
-ssh_aes_ctr_cleanup(EVP_CIPHER_CTX *ctx)
-{
-	struct ssh_aes_ctr_ctx *c;
-
-	if ((c = EVP_CIPHER_CTX_get_app_data(ctx)) != NULL) {
-		memset(c, 0, sizeof(*c));
-		xfree(c);
-		EVP_CIPHER_CTX_set_app_data(ctx, NULL);
-	}
-	return (1);
-}
-
-void
-ssh_aes_ctr_iv(EVP_CIPHER_CTX *evp, int doset, u_char * iv, size_t len)
-{
-	struct ssh_aes_ctr_ctx *c;
-
-	if ((c = EVP_CIPHER_CTX_get_app_data(evp)) == NULL)
-		fatal("ssh_aes_ctr_iv: no context");
-	if (doset)
-		memcpy(c->aes_counter, iv, len);
-	else
-		memcpy(iv, c->aes_counter, len);
-}
-
-const EVP_CIPHER *
-evp_aes_128_ctr(void)
-{
-	static EVP_CIPHER aes_ctr;
-
-	memset(&aes_ctr, 0, sizeof(EVP_CIPHER));
-	aes_ctr.nid = NID_undef;
-	aes_ctr.block_size = AES_BLOCK_SIZE;
-	aes_ctr.iv_len = AES_BLOCK_SIZE;
-	aes_ctr.key_len = 16;
-	aes_ctr.init = ssh_aes_ctr_init;
-	aes_ctr.cleanup = ssh_aes_ctr_cleanup;
-	aes_ctr.do_cipher = ssh_aes_ctr;
-#ifndef SSH_OLD_EVP
-	aes_ctr.flags = EVP_CIPH_CBC_MODE | EVP_CIPH_VARIABLE_LENGTH |
-	    EVP_CIPH_ALWAYS_CALL_INIT | EVP_CIPH_CUSTOM_IV;
-#endif
-	return (&aes_ctr);
-}
diff -ruN ../openssh-6.0p1.virgin/cipher.h ./cipher.h
--- ../openssh-6.0p1.virgin/cipher.h	2009-01-28 00:38:41.000000000 -0500
+++ ./cipher.h	2012-09-02 14:47:58.754250886 -0400
@@ -78,7 +78,7 @@
     const u_char *, u_int, int);
 void	 cipher_crypt(CipherContext *, u_char *, const u_char *, u_int);
 void	 cipher_cleanup(CipherContext *);
-void	 cipher_set_key_string(CipherContext *, Cipher *, const char *, int);
+int	 cipher_set_key_string(CipherContext *, Cipher *, const char *, int);
 u_int	 cipher_blocksize(const Cipher *);
 u_int	 cipher_keylen(const Cipher *);
 u_int	 cipher_is_cbc(const Cipher *);
diff -ruN ../openssh-6.0p1.virgin/configure.ac ./configure.ac
--- ../openssh-6.0p1.virgin/configure.ac	2012-04-19 07:46:38.000000000 -0400
+++ ./configure.ac	2012-09-02 17:29:14.387090821 -0400
@@ -2102,6 +2102,39 @@
 	]
 )
 LIBS="-lcrypto $LIBS"
+AC_ARG_WITH(fips-dir,
+	[  --with-fips-dir=PATH     Specify path to OpenSSL FIPS installation ],
+	[
+		if test "x$withval" != "xno" ; then
+			case "$withval" in
+				# Relative paths
+				./*|../*)	withval="`pwd`/$withval"
+			esac
+			if test -d "$withval/lib"; then
+				if test -n "${need_dash_r}"; then
+					LDFLAGS="-L${withval}/lib -R${withval}/lib ${LDFLAGS}"
+				else
+					LDFLAGS="-L${withval}/lib -Wl,-R${withval} ${LDFLAGS}"
+				fi
+			else
+				if test -n "${need_dash_r}"; then
+					LDFLAGS="-L${withval} -R${withval} ${LDFLAGS}"
+				else
+					LDFLAGS="-L${withval} -Wl,-R${withval} ${LDFLAGS}"
+				fi
+			fi
+			if test -d "$withval/include"; then
+				CPPFLAGS="-DOPENSSL_FIPS_CAPABLE -I${withval}/include ${CPPFLAGS}"
+			else
+				CPPFLAGS="-DOPENSSL_FIPS_CAPABLE -I${withval} ${CPPFLAGS}"
+			fi
+		fi
+		AC_DEFINE(OPENSSL_FIPS_CAPABLE, 1, [FIPS capable] )
+		openssl_check_nonfatal=1
+		fips="yes"
+	]
+)
+LIBS="-lcrypto $LIBS"
 AC_TRY_LINK_FUNC([RAND_add], [AC_DEFINE([HAVE_OPENSSL], [1],
 	[Define if your ssl headers are included
 	with #include <openssl/header.h>])],
@@ -4310,6 +4343,7 @@
 H=`eval echo ${PRIVSEP_PATH}` ; H=`eval echo ${H}`
 I=`eval echo ${user_path}` ; I=`eval echo ${I}`
 J=`eval echo ${superuser_path}` ; J=`eval echo ${J}`
+K=`eval echo ${fips}` ; J=`eval echo ${K}`
 
 echo ""
 echo "OpenSSH has been configured with the following options:"
@@ -4366,6 +4400,8 @@
 echo "          +for ssh: ${SSHLIBS}"
 fi
 
+echo "                      fips support: $K"
+
 echo ""
 
 if test "x$MAKE_PACKAGE_SUPPORTED" = "xyes" ; then
diff -ruN ../openssh-6.0p1.virgin/key.c ./key.c
--- ../openssh-6.0p1.virgin/key.c	2011-10-18 01:06:16.000000000 -0400
+++ ./key.c	2012-09-02 14:51:59.995575677 -0400
@@ -70,6 +70,17 @@
 	return cert;
 }
 
+
+int key_fingerprint_alg(void)
+{
+#ifdef OPENSSL_FIPS_CAPABLE
+  if (FIPS_mode()) 
+    return SSH_FP_SHA1;
+  else
+#endif /* OPENSSL_FIPS_CAPABLE */
+    return SSH_FP_MD5;
+}
+
 Key *
 key_new(int type)
 {
diff -ruN ../openssh-6.0p1.virgin/key.h ./key.h
--- ../openssh-6.0p1.virgin/key.h	2010-11-04 19:19:49.000000000 -0400
+++ ./key.h	2012-09-02 14:47:59.114252848 -0400
@@ -33,6 +33,7 @@
 #include <openssl/ec.h>
 #endif
 
+
 typedef struct Key Key;
 enum types {
 	KEY_RSA1,
@@ -101,6 +102,7 @@
 int		 key_write(const Key *, FILE *);
 int		 key_read(Key *, char **);
 u_int		 key_size(const Key *);
+int 		 key_fingerprint_alg(void);
 
 Key	*key_generate(int, u_int);
 Key	*key_from_private(const Key *);
@@ -148,4 +150,5 @@
 void	key_dump_ec_key(const EC_KEY *);
 #endif
 
+
 #endif
diff -ruN ../openssh-6.0p1.virgin/mac.c ./mac.c
--- ../openssh-6.0p1.virgin/mac.c	2012-01-16 22:03:38.000000000 -0500
+++ ./mac.c	2012-09-02 14:52:28.875737438 -0400
@@ -49,14 +49,14 @@
 #define SSH_EVP		1	/* OpenSSL EVP-based MAC */
 #define SSH_UMAC	2	/* UMAC (not integrated with OpenSSL) */
 
-struct {
+static struct Macs {
 	char		*name;
 	int		type;
 	const EVP_MD *	(*mdfunc)(void);
 	int		truncatebits;	/* truncate digest if != 0 */
 	int		key_len;	/* just for UMAC */
 	int		len;		/* just for UMAC */
-} macs[] = {
+} all_macs[] = {
 	{ "hmac-sha1",			SSH_EVP, EVP_sha1, 0, -1, -1 },
 	{ "hmac-sha1-96",		SSH_EVP, EVP_sha1, 96, -1, -1 },
 #ifdef HAVE_EVP_SHA256
@@ -73,10 +73,33 @@
 	{ NULL,				0, NULL, 0, -1, -1 }
 };
 
+#ifdef OPENSSL_FIPS_CAPABLE
+static struct Macs fips_macs[] = {
+	{ "hmac-sha1",			SSH_EVP, EVP_sha1, 0, -1, -1 },
+	{ "hmac-sha1-96",		SSH_EVP, EVP_sha1, 96, -1, -1 },
+	{ NULL,				0, NULL, 0, -1, -1 }
+};
+#endif /* OPENSSL_FIPS_CAPABLE */
+
+/* return the correct list of ciphers depending on what mode we are 
+ * operating in (non-FIPS140 or FIPS140 mode)
+ */
+struct Macs *macs_list(void) 
+{
+#ifdef OPENSSL_FIPS_CAPABLE
+  if (FIPS_mode()) 
+    return fips_macs;
+  else
+#endif /* OPENSSL_FIPS_CAPABLE */
+    return all_macs;
+}
+
 static void
 mac_setup_by_id(Mac *mac, int which)
 {
 	int evp_len;
+	struct Macs *macs=macs_list();
+
 	mac->type = macs[which].type;
 	if (mac->type == SSH_EVP) {
 		mac->evp_md = (*macs[which].mdfunc)();
@@ -96,6 +119,7 @@
 mac_setup(Mac *mac, char *name)
 {
 	int i;
+	struct Macs *macs=macs_list();
 
 	for (i = 0; macs[i].name; i++) {
 		if (strcmp(name, macs[i].name) == 0) {
diff -ruN ../openssh-6.0p1.virgin/Makefile.in ./Makefile.in
--- ../openssh-6.0p1.virgin/Makefile.in	2012-04-03 21:27:57.000000000 -0400
+++ ./Makefile.in	2012-09-03 09:52:37.309980442 -0400
@@ -63,7 +63,7 @@
 
 LIBSSH_OBJS=acss.o authfd.o authfile.o bufaux.o bufbn.o buffer.o \
 	canohost.o channels.o cipher.o cipher-acss.o cipher-aes.o \
-	cipher-bf1.o cipher-ctr.o cipher-3des1.o cleanup.o \
+	cipher-bf1.o cipher-3des1.o cleanup.o \
 	compat.o compress.o crc32.o deattack.o fatal.o hostfile.o \
 	log.o match.o md-sha256.o moduli.o nchan.o packet.o \
 	readpass.o rsa.o ttymodes.o xmalloc.o addrmatch.o \
diff -ruN ../openssh-6.0p1.virgin/myproposal.h ./myproposal.h
--- ../openssh-6.0p1.virgin/myproposal.h	2011-08-16 20:29:03.000000000 -0400
+++ ./myproposal.h	2012-09-02 14:52:46.535836387 -0400
@@ -97,6 +97,16 @@
 #define	KEX_DEFAULT_COMP	"none,zlib@openssh.com,zlib"
 #define	KEX_DEFAULT_LANG	""
 
+#ifdef OPENSSL_FIPS_CAPABLE
+/* FIPS subset (note: matches cipher.c and mac.c lists) */
+#define	KEX_FIPS_ENCRYPT \
+	"aes128-ctr,aes192-ctr,aes256-ctr," \
+	"aes128-cbc,3des-cbc," \
+	"aes192-cbc,aes256-cbc,rijndael-cbc@lysator.liu.se"
+#define	KEX_FIPS_MAC \
+	"hmac-sha1,hmac-sha1-96"
+#endif /* OPENSSL_FIPS_CAPABLE */
+
 
 static char *myproposal[PROPOSAL_MAX] = {
 	KEX_DEFAULT_KEX,
diff -ruN ../openssh-6.0p1.virgin/openbsd-compat/bsd-arc4random.c ./openbsd-compat/bsd-arc4random.c
--- ../openssh-6.0p1.virgin/openbsd-compat/bsd-arc4random.c	2010-03-25 17:52:02.000000000 -0400
+++ ./openbsd-compat/bsd-arc4random.c	2012-09-03 11:08:34.977367533 -0400
@@ -43,25 +43,44 @@
 arc4random(void)
 {
 	unsigned int r = 0;
-	static int first_time = 1;
+#ifdef OPENSSL_FIPS_CAPABLE
+	if (FIPS_mode()) {
+		if (RAND_bytes(&r,sizeof(r)) <= 0) {
+			/* unfortunately there is no simple way to report this
+			 * to the caller for handling so this is done via
+			 * fatal() as per arc4random_stir
+			 */
+			fatal("Could not obtain random bytes (error %ld)",
+				ERR_get_error());
+		}
+	} else {
+#else /* !OPENSSL_FIPS_CAPABLE */
+		static int first_time = 1;
 
-	if (rc4_ready <= 0) {
-		if (first_time)
-			seed_rng();
-		first_time = 0;
-		arc4random_stir();
-	}
+		if (rc4_ready <= 0) {
+			if (first_time)
+				seed_rng();
+			first_time = 0;
+			arc4random_stir();
+		}
 
-	RC4(&rc4, sizeof(r), (unsigned char *)&r, (unsigned char *)&r);
+		RC4(&rc4, sizeof(r), (unsigned char *)&r, (unsigned char *)&r);
 
-	rc4_ready -= sizeof(r);
-	
+		rc4_ready -= sizeof(r);
+
+#endif /* OPENSSL_FIPS_CAPABLE */
+#ifdef OPENSSL_FIPS_CAPABLE
+	}	
+#endif
 	return(r);
 }
 
 void
 arc4random_stir(void)
 {
+#ifdef OPENSSL_FIPS_CAPABLE
+	return;
+#endif
 	unsigned char rand_buf[SEED_SIZE];
 	int i;
 
diff -ruN ../openssh-6.0p1.virgin/readconf.c ./readconf.c
--- ../openssh-6.0p1.virgin/readconf.c	2011-10-02 03:59:03.000000000 -0400
+++ ./readconf.c	2012-09-03 11:09:01.425526308 -0400
@@ -135,6 +135,9 @@
 	oTunnel, oTunnelDevice, oLocalCommand, oPermitLocalCommand,
 	oVisualHostKey, oUseRoaming, oZeroKnowledgePasswordAuthentication,
 	oKexAlgorithms, oIPQoS, oRequestTTY,
+#ifdef OPENSSL_FIPS_CAPABLE
+	oFIPS,
+#endif
 	oDeprecated, oUnsupported
 } OpCodes;
 
@@ -246,6 +249,9 @@
 	{ "kexalgorithms", oKexAlgorithms },
 	{ "ipqos", oIPQoS },
 	{ "requesttty", oRequestTTY },
+#ifdef OPENSSL_FIPS_CAPABLE
+	{ "fips", oFIPS },
+#endif
 
 	{ NULL, oBadOption }
 };
@@ -1048,6 +1054,11 @@
 		debug("%s line %d: Deprecated option \"%s\"",
 		    filename, linenum, keyword);
 		return 0;
+#ifdef OPENSSL_FIPS_CAPABLE
+	case oFIPS:
+		intptr = &options->fips_mode;
+		goto parse_flag;
+#endif
 
 	case oUnsupported:
 		error("%s line %d: Unsupported option \"%s\"",
@@ -1203,6 +1214,7 @@
 	options->ip_qos_interactive = -1;
 	options->ip_qos_bulk = -1;
 	options->request_tty = -1;
+	options->fips_mode = -1;
 }
 
 /*
@@ -1367,6 +1379,8 @@
 		options->ip_qos_bulk = IPTOS_THROUGHPUT;
 	if (options->request_tty == -1)
 		options->request_tty = REQUEST_TTY_AUTO;
+	if (options->fips_mode == -1)
+		options->fips_mode = 0;
 	/* options->local_command should not be set by default */
 	/* options->proxy_command should not be set by default */
 	/* options->user will be set in the main program if appropriate */
diff -ruN ../openssh-6.0p1.virgin/readconf.h ./readconf.h
--- ../openssh-6.0p1.virgin/readconf.h	2011-10-02 03:59:03.000000000 -0400
+++ ./readconf.h	2012-09-03 11:09:07.793562020 -0400
@@ -135,6 +135,9 @@
 	int	use_roaming;
 
 	int	request_tty;
+#ifdef OPENSSL_FIPS_CAPABLE
+	int	fips_mode;
+#endif
 }       Options;
 
 #define SSHCTL_MASTER_NO	0
diff -ruN ../openssh-6.0p1.virgin/servconf.c ./servconf.c
--- ../openssh-6.0p1.virgin/servconf.c	2011-10-02 03:57:38.000000000 -0400
+++ ./servconf.c	2012-09-03 11:09:12.513591735 -0400
@@ -138,6 +138,9 @@
 	options->authorized_principals_file = NULL;
 	options->ip_qos_interactive = -1;
 	options->ip_qos_bulk = -1;
+#ifdef OPENSSL_FIPS_CAPABLE
+	options->fips_mode = -1;
+#endif
 }
 
 void
@@ -290,6 +293,10 @@
 		options->compression = 0;
 	}
 #endif
+#ifdef OPENSSL_FIPS_CAPABLE
+	if (options->fips_mode == -1)
+		options->fips_mode = 0;
+#endif
 
 }
 
@@ -324,6 +331,9 @@
 	sZeroKnowledgePasswordAuthentication, sHostCertificate,
 	sRevokedKeys, sTrustedUserCAKeys, sAuthorizedPrincipalsFile,
 	sKexAlgorithms, sIPQoS,
+#ifdef OPENSSL_FIPS_CAPABLE
+	sFIPS,
+#endif
 	sDeprecated, sUnsupported
 } ServerOpCodes;
 
@@ -448,6 +458,7 @@
 	{ "authorizedprincipalsfile", sAuthorizedPrincipalsFile, SSHCFG_ALL },
 	{ "kexalgorithms", sKexAlgorithms, SSHCFG_GLOBAL },
 	{ "ipqos", sIPQoS, SSHCFG_ALL },
+	{ "FIPS", sFIPS, SSHCFG_ALL },
 	{ NULL, sBadOption, 0 }
 };
 
@@ -1401,6 +1412,11 @@
 		while (arg)
 		    arg = strdelim(&cp);
 		break;
+#ifdef OPENSSL_FIPS_CAPABLE
+	case sFIPS:
+		intptr = &options->fips_mode;
+		goto parse_flag;
+#endif
 
 	case sUnsupported:
 		logit("%s line %d: Unsupported option %s",
@@ -1793,6 +1809,9 @@
 
 	printf("ipqos %s ", iptos2str(o->ip_qos_interactive));
 	printf("%s\n", iptos2str(o->ip_qos_bulk));
+#ifdef OPENSSL_FIPS_CAPABLE
+	dump_cfg_fmtint(sFIPS, o->fips_mode);
+#endif
 
 	channel_print_adm_permitted_opens();
 }
diff -ruN ../openssh-6.0p1.virgin/servconf.h ./servconf.h
--- ../openssh-6.0p1.virgin/servconf.h	2011-06-22 18:30:03.000000000 -0400
+++ ./servconf.h	2012-09-03 11:09:16.993619004 -0400
@@ -166,6 +166,9 @@
 	char   *revoked_keys_file;
 	char   *trusted_user_ca_keys;
 	char   *authorized_principals_file;
+#ifdef OPENSSL_FIPS_CAPABLE
+	int	fips_mode;
+#endif
 }       ServerOptions;
 
 /*
diff -ruN ../openssh-6.0p1.virgin/ssh-add.c ./ssh-add.c
--- ../openssh-6.0p1.virgin/ssh-add.c	2011-11-03 19:51:51.000000000 -0400
+++ ./ssh-add.c	2012-09-02 14:47:59.502254970 -0400
@@ -301,7 +301,7 @@
 		    key = ssh_get_next_identity(ac, &comment, version)) {
 			had_identities = 1;
 			if (do_fp) {
-				fp = key_fingerprint(key, SSH_FP_MD5,
+				fp = key_fingerprint(key, key_fingerprint_alg(),
 				    SSH_FP_HEX);
 				printf("%d %s %s (%s)\n",
 				    key_size(key), fp, comment, key_type(key));
--- ../openssh-6.0p1.virgin/ssh-agent.c	2011-06-03 00:14:16.000000000 -0400
+++ ssh-agent.c	2012-09-04 13:15:17.867565401 -0400
@@ -199,7 +199,7 @@
 	char *p;
 	int ret = -1;
 
-	p = key_fingerprint(id->key, SSH_FP_MD5, SSH_FP_HEX);
+	p = key_fingerprint(id->key, key_fingerprint_alg(), SSH_FP_HEX);
 	if (ask_permission("Allow use of key %s?\nKey fingerprint %s.",
 	    id->comment, p))
 		ret = 0;
@@ -249,7 +249,7 @@
 	Identity *id;
 	int i, len;
 	Buffer msg;
-	MD5_CTX md;
+	EVP_MD_CTX md;
 	Key *key;
 
 	buffer_init(&msg);
@@ -285,10 +285,14 @@
 		}
 		memset(buf, 0, 32);
 		BN_bn2bin(challenge, buf + 32 - len);
-		MD5_Init(&md);
-		MD5_Update(&md, buf, 32);
-		MD5_Update(&md, session_id, 16);
-		MD5_Final(mdbuf, &md);
+
+		if (EVP_DigestInit(&md, EVP_md5()) <= 0)
+		  goto failure;
+		if (EVP_DigestUpdate(&md, buf, sizeof buf) <= 0)
+		  goto failure;
+		if (EVP_DigestUpdate(&md, session_id, sizeof session_id) <= 0)
+		  goto failure;
+		EVP_DigestFinal(&md, mdbuf, NULL);
 
 		/* Send the response. */
 		buffer_put_char(&msg, SSH_AGENT_RSA_RESPONSE);
--- ../openssh-6.0p1.virgin/ssh.c	2011-11-03 19:54:22.000000000 -0400
+++ ssh.c	2012-09-03 11:51:23.824598834 -0400
@@ -329,6 +329,17 @@
 	    "ACD:F:I:KL:MNO:PR:S:TVw:W:XYy")) != -1) {
 		switch (opt) {
 		case '1':
+#ifdef OPENSSL_FIPS_CAPABLE
+		      /* we need to check that we have selected the right 
+		       * SSH protocol for FIPS mode - otherwise it will simply 
+		       * not work and the error messages reported will not be 
+		       * particularly useful to the user; so if the user
+		       * explicitly requests protocol 1 we need to tell them
+		       * that it isn't acceptable in FIPS mode
+		       */
+			if (FIPS_mode())
+			  fatal("Protocol 1 is not allowed in FIPS mode");
+#endif /* OPENSSL_FIPS_CAPABLE */
 			options.protocol = SSH_PROTO_1;
 			break;
 		case '2':
@@ -721,6 +732,32 @@
 	/* reinit */
 	log_init(argv0, options.log_level, SYSLOG_FACILITY_USER, !use_syslog);
 
+#ifdef OPENSSL_FIPS_CAPABLE
+	/* note: OpenSSL itself uses OPENSSL_FIPS to indicate
+	 *       wanting to run in FIPS mode
+	 */
+	if (options.fips_mode || getenv("OPENSSL_FIPS")) {
+	  if (!FIPS_mode_set(1)) {
+	    /* make sure the error stack is available for some hint as
+	     * to why this operation failed
+	     */
+	    ERR_load_crypto_strings();
+	    ERR_print_errors_fp(stdout);
+	    printf("FIPS_mode_set(): failed to enter FIPS mode!\n");
+	    exit(1);
+	  }
+	  /* we need to check that we have selected the right 
+	   * SSH protocol for FIPS mode - otherwise it will simply 
+	   * not work and the error messages reported will not be 
+	   * particularly useful to the user; so if the user
+	   * explicitly requests protocol 1 we need to tell them
+	   * that it isn't acceptable in FIPS mode
+	   */
+	  if (SSH_PROTO_1 == options.protocol)
+	      fatal("Protocol 1 is not allowed in FIPS mode");
+	}
+#endif /* OPENSSL_FIPS_CAPABLE */
+
 	seed_rng();
 
 	if (options.user == NULL)
@@ -791,6 +828,20 @@
 
 	timeout_ms = options.connection_timeout * 1000;
 
+#ifdef OPENSSL_FIPS_CAPABLE
+	/* after all the configuration files have been processed we 
+	 * need to check that we have selected the right SSH protocol
+	 * for FIPS mode - otherwise it will simply not work and the error
+	 * messages reported will not be particularly useful to the user
+	 */
+	if (FIPS_mode()) {
+		options.protocol &= SSH_PROTO_2;
+		if (options.protocol == 0)
+			fatal("Protocol 2 disabled by configuration but required by FIPS mode");
+		debug("FIPS mode initialized");
+	}
+#endif /* OPENSSL_FIPS_CAPABLE */
+
 	/* Open a connection to the remote host. */
 	if (ssh_connect(host, &hostaddr, options.port,
 	    options.address_family, options.connection_attempts, &timeout_ms,
diff -ruN ../openssh-6.0p1.virgin/sshconnect2.c ./sshconnect2.c
--- ../openssh-6.0p1.virgin/sshconnect2.c	2011-05-29 07:42:34.000000000 -0400
+++ ./sshconnect2.c	2012-09-03 11:09:21.633649758 -0400
@@ -171,6 +171,12 @@
 		myproposal[PROPOSAL_ENC_ALGS_CTOS] =
 		myproposal[PROPOSAL_ENC_ALGS_STOC] = options.ciphers;
 	}
+#ifdef OPENSSL_FIPS_CAPABLE
+	else if (FIPS_mode()) {
+		myproposal[PROPOSAL_ENC_ALGS_CTOS] =
+		myproposal[PROPOSAL_ENC_ALGS_STOC] = KEX_FIPS_ENCRYPT;
+	}
+#endif /* OPENSSL_FIPS_CAPABLE */
 	myproposal[PROPOSAL_ENC_ALGS_CTOS] =
 	    compat_cipher_proposal(myproposal[PROPOSAL_ENC_ALGS_CTOS]);
 	myproposal[PROPOSAL_ENC_ALGS_STOC] =
@@ -186,6 +192,12 @@
 		myproposal[PROPOSAL_MAC_ALGS_CTOS] =
 		myproposal[PROPOSAL_MAC_ALGS_STOC] = options.macs;
 	}
+#ifdef OPENSSL_FIPS_CAPABLE
+ 	else if (FIPS_mode()) {
+		myproposal[PROPOSAL_MAC_ALGS_CTOS] =
+		myproposal[PROPOSAL_MAC_ALGS_STOC] = KEX_FIPS_MAC;
+	}
+#endif /* OPENSSL_FIPS_CAPABLE */
 	if (options.hostkeyalgorithms != NULL)
 		myproposal[PROPOSAL_SERVER_HOST_KEY_ALGS] =
 		    options.hostkeyalgorithms;
@@ -591,7 +603,7 @@
 		    key->type, pktype);
 		goto done;
 	}
-	fp = key_fingerprint(key, SSH_FP_MD5, SSH_FP_HEX);
+	fp = key_fingerprint(key, key_fingerprint_alg(), SSH_FP_HEX);
 	debug2("input_userauth_pk_ok: fp %s", fp);
 	xfree(fp);
 
@@ -1204,7 +1216,7 @@
 	int have_sig = 1;
 	char *fp;
 
-	fp = key_fingerprint(id->key, SSH_FP_MD5, SSH_FP_HEX);
+	fp = key_fingerprint(id->key, key_fingerprint_alg(), SSH_FP_HEX);
 	debug3("sign_and_send_pubkey: %s %s", key_type(id->key), fp);
 	xfree(fp);
 
diff -ruN ../openssh-6.0p1.virgin/sshconnect.c ./sshconnect.c
--- ../openssh-6.0p1.virgin/sshconnect.c	2011-05-29 07:42:34.000000000 -0400
+++ ./sshconnect.c	2012-09-02 14:47:59.934257327 -0400
@@ -556,7 +556,7 @@
 	snprintf(buf, sizeof buf, "SSH-%d.%d-%.100s%s",
 	    compat20 ? PROTOCOL_MAJOR_2 : PROTOCOL_MAJOR_1,
 	    compat20 ? PROTOCOL_MINOR_2 : minor1,
-	    SSH_VERSION, compat20 ? "\r\n" : "\n");
+	    SSH_VERSION SSH_FIPS, compat20 ? "\r\n" : "\n");
 	if (roaming_atomicio(vwrite, connection_out, buf, strlen(buf))
 	    != strlen(buf))
 		fatal("write: %.100s", strerror(errno));
@@ -805,8 +805,9 @@
 				    "key for IP address '%.128s' to the list "
 				    "of known hosts.", type, ip);
 		} else if (options.visual_host_key) {
-			fp = key_fingerprint(host_key, SSH_FP_MD5, SSH_FP_HEX);
-			ra = key_fingerprint(host_key, SSH_FP_MD5,
+			fp = key_fingerprint(host_key, key_fingerprint_alg(), 
+			    SSH_FP_HEX);
+			ra = key_fingerprint(host_key, key_fingerprint_alg(),
 			    SSH_FP_RANDOMART);
 			logit("Host key fingerprint is %s\n%s\n", fp, ra);
 			xfree(ra);
@@ -846,8 +847,9 @@
 			else
 				snprintf(msg1, sizeof(msg1), ".");
 			/* The default */
-			fp = key_fingerprint(host_key, SSH_FP_MD5, SSH_FP_HEX);
-			ra = key_fingerprint(host_key, SSH_FP_MD5,
+			fp = key_fingerprint(host_key, key_fingerprint_alg(), 
+			    SSH_FP_HEX);
+			ra = key_fingerprint(host_key, key_fingerprint_alg(),
 			    SSH_FP_RANDOMART);
 			msg2[0] = '\0';
 			if (options.verify_host_key_dns) {
@@ -863,10 +865,12 @@
 			snprintf(msg, sizeof(msg),
 			    "The authenticity of host '%.200s (%s)' can't be "
 			    "established%s\n"
-			    "%s key fingerprint is %s.%s%s\n%s"
+			    "%s key %sfingerprint is %s.%s%s\n%s"
 			    "Are you sure you want to continue connecting "
 			    "(yes/no)? ",
-			    host, ip, msg1, type, fp,
+			    host, ip, msg1, type, 
+			    key_fingerprint_alg()==SSH_FP_SHA1?"SHA1 ":"",
+			    fp,
 			    options.visual_host_key ? "\n" : "",
 			    options.visual_host_key ? ra : "",
 			    msg2);
@@ -1111,7 +1115,7 @@
 	int flags = 0;
 	char *fp;
 
-	fp = key_fingerprint(host_key, SSH_FP_MD5, SSH_FP_HEX);
+	fp = key_fingerprint(host_key, key_fingerprint_alg(), SSH_FP_HEX);
 	debug("Server host key: %s %s", key_type(host_key), fp);
 	xfree(fp);
 
@@ -1213,14 +1217,16 @@
 			continue;
 		if (!lookup_key_in_hostkeys_by_type(hostkeys, type[i], &found))
 			continue;
-		fp = key_fingerprint(found->key, SSH_FP_MD5, SSH_FP_HEX);
-		ra = key_fingerprint(found->key, SSH_FP_MD5, SSH_FP_RANDOMART);
+		fp = key_fingerprint(found->key, key_fingerprint_alg(), SSH_FP_HEX);
+		ra = key_fingerprint(found->key, key_fingerprint_alg(), SSH_FP_RANDOMART);
 		logit("WARNING: %s key found for host %s\n"
 		    "in %s:%lu\n"
-		    "%s key fingerprint %s.",
+		    "%s key %sfingerprint %s.\n%s\n",
 		    key_type(found->key),
 		    found->host, found->file, found->line,
-		    key_type(found->key), fp);
+		    key_type(found->key),
+		    key_fingerprint_alg()==SSH_FP_SHA1?"SHA1 ":"",
+		    fp, ra);
 		if (options.visual_host_key)
 			logit("%s", ra);
 		xfree(ra);
@@ -1234,8 +1240,9 @@
 warn_changed_key(Key *host_key)
 {
 	char *fp;
+	const char *type = key_type(host_key);
 
-	fp = key_fingerprint(host_key, SSH_FP_MD5, SSH_FP_HEX);
+	fp = key_fingerprint(host_key, key_fingerprint_alg(), SSH_FP_HEX);
 
 	error("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@");
 	error("@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @");
@@ -1243,8 +1250,8 @@
 	error("IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!");
 	error("Someone could be eavesdropping on you right now (man-in-the-middle attack)!");
 	error("It is also possible that a host key has just been changed.");
-	error("The fingerprint for the %s key sent by the remote host is\n%s.",
-	    key_type(host_key), fp);
+	error("The %sfingerprint for the %s key sent by the remote host is\n%s.",
+            key_fingerprint_alg()==SSH_FP_SHA1?"SHA1 ":"", type, fp);
 	error("Please contact your system administrator.");
 
 	xfree(fp);
--- ../openssh-6.0p1.virgin/sshd.c	2012-02-14 13:03:31.000000000 -0500
+++ sshd.c	2012-09-03 11:51:23.824598834 -0400
@@ -78,6 +78,8 @@
 #include <openssl/rand.h>
 #include "openbsd-compat/openssl-compat.h"
 
+#include <openssl/err.h>
+
 #ifdef HAVE_SECUREWARE
 #include <sys/security.h>
 #include <prot.h>
@@ -419,8 +421,8 @@
 		major = PROTOCOL_MAJOR_1;
 		minor = PROTOCOL_MINOR_1;
 	}
-	snprintf(buf, sizeof buf, "SSH-%d.%d-%.100s%s", major, minor,
-	    SSH_VERSION, newline);
+	snprintf(buf, sizeof buf, "SSH-%d.%d-%.100s%s%s", major, minor,
+	    SSH_VERSION SSH_FIPS, FIPS_mode()?"(enabled)":"(capable)", newline);
 	server_version_string = xstrdup(buf);
 
 	/* Send our protocol version identification. */
@@ -1550,6 +1552,24 @@
 	parse_server_config(&options, rexeced_flag ? "rexec" : config_file_name,
 	    &cfg, NULL, NULL, NULL);
 
+#ifdef OPENSSL_FIPS_CAPABLE
+	/* note: there should be a command line option to indicate FIPS140 
+	 *       mode; however OpenSSL itself uses OPENSSL_FIPS to indicate
+	 *       wanting to run in FIPS mode
+	 */
+	if (options.fips_mode || getenv("OPENSSL_FIPS")) {
+	  if (!FIPS_mode_set(1)) {
+	    /* make sure the error stack is available for some hint as
+	     * to why this operation failed
+	     */
+	    ERR_load_crypto_strings();
+	    ERR_print_errors_fp(stdout);
+	    printf("FIPS_mode_set(): failed to enter FIPS mode!\n");
+	    exit(1);
+	  }
+	}
+#endif /* OPENSSL_FIPS_CAPABLE */
+
 	seed_rng();
 
 	/* Fill in default values for those options not explicitly set. */
@@ -1612,6 +1632,12 @@
 		debug("private host key: #%d type %d %s", i, key->type,
 		    key_type(key));
 	}
+#ifdef OPENSSL_FIPS_CAPABLE
+	if ((options.protocol & SSH_PROTO_1) && FIPS_mode()) {
+		logit("Disabling protocol version 1. Not allowed in FIPS mode");
+		options.protocol &= ~SSH_PROTO_1;
+	}
+#endif /* OPENSSL_FIPS_CAPABLE */
 	if ((options.protocol & SSH_PROTO_1) && !sensitive_data.have_ssh1_key) {
 		logit("Disabling protocol version 1. Could not load host key");
 		options.protocol &= ~SSH_PROTO_1;
@@ -1776,6 +1802,12 @@
 	/* Initialize the random number generator. */
 	arc4random_stir();
 
+#ifdef OPENSSL_FIPS_CAPABLE
+	if (FIPS_mode()) {
+		logit("FIPS mode initialized");
+	}
+#endif /* OPENSSL_FIPS_CAPABLE */
+
 	/* Chdir to the root directory so that the current disk can be
 	   unmounted if desired. */
 	chdir("/");
@@ -2308,6 +2340,12 @@
 		myproposal[PROPOSAL_ENC_ALGS_CTOS] =
 		myproposal[PROPOSAL_ENC_ALGS_STOC] = options.ciphers;
 	}
+#ifdef OPENSSL_FIPS_CAPABLE
+	else if (FIPS_mode()) {
+		myproposal[PROPOSAL_ENC_ALGS_CTOS] =
+		myproposal[PROPOSAL_ENC_ALGS_STOC] = KEX_FIPS_ENCRYPT;
+	}
+#endif /* OPENSSL_FIPS_CAPABLE */
 	myproposal[PROPOSAL_ENC_ALGS_CTOS] =
 	    compat_cipher_proposal(myproposal[PROPOSAL_ENC_ALGS_CTOS]);
 	myproposal[PROPOSAL_ENC_ALGS_STOC] =
@@ -2317,6 +2355,12 @@
 		myproposal[PROPOSAL_MAC_ALGS_CTOS] =
 		myproposal[PROPOSAL_MAC_ALGS_STOC] = options.macs;
 	}
+#ifdef OPENSSL_FIPS_CAPABLE
+	else if (FIPS_mode()) {
+		myproposal[PROPOSAL_MAC_ALGS_CTOS] =
+		myproposal[PROPOSAL_MAC_ALGS_STOC] = KEX_FIPS_MAC;
+	}
+#endif /* OPENSSL_FIPS_CAPABLE */
 	if (options.compression == COMP_NONE) {
 		myproposal[PROPOSAL_COMP_ALGS_CTOS] =
 		myproposal[PROPOSAL_COMP_ALGS_STOC] = "none";
diff -ruN ../openssh-6.0p1.virgin/ssh-dss.c ./ssh-dss.c
--- ../openssh-6.0p1.virgin/ssh-dss.c	2010-08-31 08:36:39.000000000 -0400
+++ ./ssh-dss.c	2012-09-02 14:48:00.146258482 -0400
@@ -47,26 +47,48 @@
     const u_char *data, u_int datalen)
 {
 	DSA_SIG *sig;
-	const EVP_MD *evp_md = EVP_sha1();
+	const EVP_MD *evp_md = EVP_dss1();
 	EVP_MD_CTX md;
-	u_char digest[EVP_MAX_MD_SIZE], sigblob[SIGBLOB_LEN];
-	u_int rlen, slen, len, dlen;
+	u_char sigblob[SIGBLOB_LEN];
+	u_int rlen, slen, len;
 	Buffer b;
+	u_char *tsig;
+	const u_char *psig;
+	EVP_PKEY *pkey;
+	int ok;
 
 	if (key == NULL || key->dsa == NULL || (key->type != KEY_DSA &&
 	    key->type != KEY_DSA_CERT && key->type != KEY_DSA_CERT_V00)) {
 		error("ssh_dss_sign: no DSA key");
 		return -1;
 	}
-	EVP_DigestInit(&md, evp_md);
-	EVP_DigestUpdate(&md, data, datalen);
-	EVP_DigestFinal(&md, digest, &dlen);
+	pkey = EVP_PKEY_new();
+	EVP_PKEY_set1_DSA(pkey, key->dsa);
+	slen = EVP_PKEY_size(pkey);
+	tsig = xmalloc(slen);
+
+	EVP_MD_CTX_init(&md);
+	EVP_SignInit_ex(&md, evp_md, NULL);
+	EVP_SignUpdate(&md, data, datalen);
+	ok = EVP_SignFinal(&md, tsig, &len, pkey);
+	EVP_MD_CTX_cleanup(&md);
+	EVP_PKEY_free(pkey);
 
-	sig = DSA_do_sign(digest, dlen, key->dsa);
-	memset(digest, 'd', sizeof(digest));
+	if (ok != 1) {
+		xfree(tsig);
+		error("ssh_dss_sign: sign failed");
+		return -1;
+	}
+
+	psig = tsig;
+
+	/* Output of EVP_SignFinal() is encoded, convert to DSA_SIG */
+	sig = d2i_DSA_SIG(NULL, &psig, len);
+	memset(tsig, 'd', len);
+	xfree(tsig);
 
 	if (sig == NULL) {
-		error("ssh_dss_sign: sign failed");
+		error("ssh_dss_sign: DSA parse failed");
 		return -1;
 	}
 
@@ -110,12 +132,14 @@
     const u_char *data, u_int datalen)
 {
 	DSA_SIG *sig;
-	const EVP_MD *evp_md = EVP_sha1();
+	const EVP_MD *evp_md = EVP_dss1();
 	EVP_MD_CTX md;
-	u_char digest[EVP_MAX_MD_SIZE], *sigblob;
-	u_int len, dlen;
+	u_char *sigblob;
+	u_int len;
 	int rlen, ret;
 	Buffer b;
+        u_char *tsig, *psig;
+	EVP_PKEY *pkey;
 
 	if (key == NULL || key->dsa == NULL || (key->type != KEY_DSA &&
 	    key->type != KEY_DSA_CERT && key->type != KEY_DSA_CERT_V00)) {
@@ -171,15 +195,27 @@
 	memset(sigblob, 0, len);
 	xfree(sigblob);
 
-	/* sha1 the data */
-	EVP_DigestInit(&md, evp_md);
-	EVP_DigestUpdate(&md, data, datalen);
-	EVP_DigestFinal(&md, digest, &dlen);
-
-	ret = DSA_do_verify(digest, dlen, sig, key->dsa);
-	memset(digest, 'd', sizeof(digest));
-
-	DSA_SIG_free(sig);
+        /* Sig is in DSA_SIG structure, convert to encoded buffer */
+        len = i2d_DSA_SIG(sig, NULL);
+        tsig = xmalloc(len);
+        psig = tsig;
+        i2d_DSA_SIG(sig, &psig);
+        DSA_SIG_free(sig);
+  
+        pkey = EVP_PKEY_new();
+        EVP_PKEY_set1_DSA(pkey, key->dsa);
+  
+        /* now verify signature */
+        EVP_MD_CTX_init(&md);
+        EVP_VerifyInit(&md, evp_md);
+        EVP_VerifyUpdate(&md, data, datalen);
+        ret = EVP_VerifyFinal(&md, tsig, len, pkey);
+        EVP_MD_CTX_cleanup(&md);
+        EVP_PKEY_free(pkey);
+  
+        /* Cleanup buffer */
+        memset(tsig, 'd', len);
+        xfree(tsig);
 
 	debug("ssh_dss_verify: signature %s",
 	    ret == 1 ? "correct" : ret == 0 ? "incorrect" : "error");
diff -ruN ../openssh-6.0p1.virgin/ssh-keygen.c ./ssh-keygen.c
--- ../openssh-6.0p1.virgin/ssh-keygen.c	2012-02-05 15:41:31.000000000 -0500
+++ ./ssh-keygen.c	2012-09-03 11:09:26.177678006 -0400
@@ -749,7 +749,7 @@
 	enum fp_type fptype;
 	struct stat st;
 
-	fptype = print_bubblebabble ? SSH_FP_SHA1 : SSH_FP_MD5;
+	fptype = print_bubblebabble ? SSH_FP_SHA1 : key_fingerprint_alg();
 	rep =    print_bubblebabble ? SSH_FP_BUBBLEBABBLE : SSH_FP_HEX;
 
 	if (!have_identity)
@@ -761,7 +761,7 @@
 	public = key_load_public(identity_file, &comment);
 	if (public != NULL) {
 		fp = key_fingerprint(public, fptype, rep);
-		ra = key_fingerprint(public, SSH_FP_MD5, SSH_FP_RANDOMART);
+		ra = key_fingerprint(public, key_fingerprint_alg(), SSH_FP_RANDOMART);
 		printf("%u %s %s (%s)\n", key_size(public), fp, comment,
 		    key_type(public));
 		if (log_level >= SYSLOG_LEVEL_VERBOSE)
@@ -827,7 +827,7 @@
 		}
 		comment = *cp ? cp : comment;
 		fp = key_fingerprint(public, fptype, rep);
-		ra = key_fingerprint(public, SSH_FP_MD5, SSH_FP_RANDOMART);
+		ra = key_fingerprint(public, key_fingerprint_alg(), SSH_FP_RANDOMART);
 		printf("%u %s %s (%s)\n", key_size(public), fp,
 		    comment ? comment : "no comment", key_type(public));
 		if (log_level >= SYSLOG_LEVEL_VERBOSE)
@@ -948,10 +948,10 @@
 		enum fp_type fptype;
 		char *fp, *ra;
 
-		fptype = print_bubblebabble ? SSH_FP_SHA1 : SSH_FP_MD5;
+		fptype = print_bubblebabble ? SSH_FP_SHA1 : key_fingerprint_alg();
 		rep =    print_bubblebabble ? SSH_FP_BUBBLEBABBLE : SSH_FP_HEX;
 		fp = key_fingerprint(public, fptype, rep);
-		ra = key_fingerprint(public, SSH_FP_MD5, SSH_FP_RANDOMART);
+		ra = key_fingerprint(public, key_fingerprint_alg(), SSH_FP_RANDOMART);
 		printf("%u %s %s (%s)\n", key_size(public), fp, name,
 		    key_type(public));
 		if (log_level >= SYSLOG_LEVEL_VERBOSE)
@@ -1818,7 +1818,7 @@
 		fatal("%s is not a certificate", identity_file);
 	v00 = key->type == KEY_RSA_CERT_V00 || key->type == KEY_DSA_CERT_V00;
 
-	key_fp = key_fingerprint(key, SSH_FP_MD5, SSH_FP_HEX);
+	key_fp = key_fingerprint(key, key_fingerprint_alg(), SSH_FP_HEX);
 	ca_fp = key_fingerprint(key->cert->signature_key,
 	    SSH_FP_MD5, SSH_FP_HEX);
 
@@ -1935,6 +1935,24 @@
 	extern int optind;
 	extern char *optarg;
 
+#ifdef OPENSSL_FIPS_CAPABLE
+	/* note: there should be a command line option to indicate FIPS140 
+	 *       mode; however OpenSSL itself uses OPENSSL_FIPS to indicate
+	 *       wanting to run in FIPS mode
+	 */
+	if (getenv("OPENSSL_FIPS")) {
+	  if (!FIPS_mode_set(1)) {
+	    /* make sure the error stack is available for some hint as
+	     * to why this operation failed
+	     */
+	    ERR_load_crypto_strings();
+	    ERR_print_errors_fp(stdout);
+	    printf("FIPS_mode_set(): failed to enter FIPS mode!\n");
+	    exit(1);
+	  }
+	}
+#endif /* OPENSSL_FIPS_CAPABLE */
+
 	/* Ensure that fds 0, 1 and 2 are open or directed to /dev/null */
 	sanitise_stdfd();
 
@@ -2362,8 +2380,9 @@
 	fclose(f);
 
 	if (!quiet) {
-		char *fp = key_fingerprint(public, SSH_FP_MD5, SSH_FP_HEX);
-		char *ra = key_fingerprint(public, SSH_FP_MD5,
+		char *fp = key_fingerprint(public, key_fingerprint_alg(), 
+		    SSH_FP_HEX);
+		char *ra = key_fingerprint(public, key_fingerprint_alg(),
 		    SSH_FP_RANDOMART);
 		printf("Your public key has been saved in %s.\n",
 		    identity_file);
diff -ruN ../openssh-6.0p1.virgin/ssh-rsa.c ./ssh-rsa.c
--- ../openssh-6.0p1.virgin/ssh-rsa.c	2010-08-31 08:36:39.000000000 -0400
+++ ./ssh-rsa.c	2012-09-02 14:48:00.366259687 -0400
@@ -42,10 +42,11 @@
 {
 	const EVP_MD *evp_md;
 	EVP_MD_CTX md;
-	u_char digest[EVP_MAX_MD_SIZE], *sig;
-	u_int slen, dlen, len;
+	u_char *sig;
+	u_int slen, len;
 	int ok, nid;
 	Buffer b;
+	EVP_PKEY *pkey;
 
 	if (key == NULL || key->rsa == NULL || (key->type != KEY_RSA &&
 	    key->type != KEY_RSA_CERT && key->type != KEY_RSA_CERT_V00)) {
@@ -57,15 +58,17 @@
 		error("ssh_rsa_sign: EVP_get_digestbynid %d failed", nid);
 		return -1;
 	}
-	EVP_DigestInit(&md, evp_md);
-	EVP_DigestUpdate(&md, data, datalen);
-	EVP_DigestFinal(&md, digest, &dlen);
-
-	slen = RSA_size(key->rsa);
+	pkey = EVP_PKEY_new();
+	EVP_PKEY_set1_RSA(pkey, key->rsa);
+	slen = EVP_PKEY_size(pkey);
 	sig = xmalloc(slen);
 
-	ok = RSA_sign(nid, digest, dlen, sig, &len, key->rsa);
-	memset(digest, 'd', sizeof(digest));
+	EVP_MD_CTX_init(&md);
+	EVP_SignInit_ex(&md, evp_md, NULL);
+	EVP_SignUpdate(&md, data, datalen);
+	ok = EVP_SignFinal(&md, sig, &len, pkey);
+	EVP_MD_CTX_cleanup(&md);
+	EVP_PKEY_free(pkey);
 
 	if (ok != 1) {
 		int ecode = ERR_get_error();
@@ -111,9 +114,10 @@
 	const EVP_MD *evp_md;
 	EVP_MD_CTX md;
 	char *ktype;
-	u_char digest[EVP_MAX_MD_SIZE], *sigblob;
-	u_int len, dlen, modlen;
+	u_char *sigblob;
+	u_int len, modlen;
 	int rlen, ret, nid;
+	EVP_PKEY *pkey;
 
 	if (key == NULL || key->rsa == NULL || (key->type != KEY_RSA &&
 	    key->type != KEY_RSA_CERT && key->type != KEY_RSA_CERT_V00)) {
@@ -164,105 +168,17 @@
 		xfree(sigblob);
 		return -1;
 	}
-	EVP_DigestInit(&md, evp_md);
-	EVP_DigestUpdate(&md, data, datalen);
-	EVP_DigestFinal(&md, digest, &dlen);
+	pkey = EVP_PKEY_new();
+	EVP_PKEY_set1_RSA(pkey, key->rsa);
+	EVP_MD_CTX_init(&md);
+	EVP_VerifyInit_ex(&md, evp_md, NULL);
+	EVP_VerifyUpdate(&md, data, datalen);
+	ret = EVP_VerifyFinal(&md, sigblob, len, pkey);
+	EVP_MD_CTX_cleanup(&md);
+	EVP_PKEY_free(pkey);
 
-	ret = openssh_RSA_verify(nid, digest, dlen, sigblob, len, key->rsa);
-	memset(digest, 'd', sizeof(digest));
 	memset(sigblob, 's', len);
 	xfree(sigblob);
 	debug("ssh_rsa_verify: signature %scorrect", (ret==0) ? "in" : "");
 	return ret;
 }
-
-/*
- * See:
- * http://www.rsasecurity.com/rsalabs/pkcs/pkcs-1/
- * ftp://ftp.rsasecurity.com/pub/pkcs/pkcs-1/pkcs-1v2-1.asn
- */
-/*
- * id-sha1 OBJECT IDENTIFIER ::= { iso(1) identified-organization(3)
- *	oiw(14) secsig(3) algorithms(2) 26 }
- */
-static const u_char id_sha1[] = {
-	0x30, 0x21, /* type Sequence, length 0x21 (33) */
-	0x30, 0x09, /* type Sequence, length 0x09 */
-	0x06, 0x05, /* type OID, length 0x05 */
-	0x2b, 0x0e, 0x03, 0x02, 0x1a, /* id-sha1 OID */
-	0x05, 0x00, /* NULL */
-	0x04, 0x14  /* Octet string, length 0x14 (20), followed by sha1 hash */
-};
-/*
- * id-md5 OBJECT IDENTIFIER ::= { iso(1) member-body(2) us(840)
- *	rsadsi(113549) digestAlgorithm(2) 5 }
- */
-static const u_char id_md5[] = {
-	0x30, 0x20, /* type Sequence, length 0x20 (32) */
-	0x30, 0x0c, /* type Sequence, length 0x09 */
-	0x06, 0x08, /* type OID, length 0x05 */
-	0x2a, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x02, 0x05, /* id-md5 */
-	0x05, 0x00, /* NULL */
-	0x04, 0x10  /* Octet string, length 0x10 (16), followed by md5 hash */
-};
-
-static int
-openssh_RSA_verify(int type, u_char *hash, u_int hashlen,
-    u_char *sigbuf, u_int siglen, RSA *rsa)
-{
-	u_int ret, rsasize, oidlen = 0, hlen = 0;
-	int len, oidmatch, hashmatch;
-	const u_char *oid = NULL;
-	u_char *decrypted = NULL;
-
-	ret = 0;
-	switch (type) {
-	case NID_sha1:
-		oid = id_sha1;
-		oidlen = sizeof(id_sha1);
-		hlen = 20;
-		break;
-	case NID_md5:
-		oid = id_md5;
-		oidlen = sizeof(id_md5);
-		hlen = 16;
-		break;
-	default:
-		goto done;
-	}
-	if (hashlen != hlen) {
-		error("bad hashlen");
-		goto done;
-	}
-	rsasize = RSA_size(rsa);
-	if (siglen == 0 || siglen > rsasize) {
-		error("bad siglen");
-		goto done;
-	}
-	decrypted = xmalloc(rsasize);
-	if ((len = RSA_public_decrypt(siglen, sigbuf, decrypted, rsa,
-	    RSA_PKCS1_PADDING)) < 0) {
-		error("RSA_public_decrypt failed: %s",
-		    ERR_error_string(ERR_get_error(), NULL));
-		goto done;
-	}
-	if (len < 0 || (u_int)len != hlen + oidlen) {
-		error("bad decrypted len: %d != %d + %d", len, hlen, oidlen);
-		goto done;
-	}
-	oidmatch = timingsafe_bcmp(decrypted, oid, oidlen) == 0;
-	hashmatch = timingsafe_bcmp(decrypted + oidlen, hash, hlen) == 0;
-	if (!oidmatch) {
-		error("oid mismatch");
-		goto done;
-	}
-	if (!hashmatch) {
-		error("hash mismatch");
-		goto done;
-	}
-	ret = 1;
-done:
-	if (decrypted)
-		xfree(decrypted);
-	return ret;
-}
diff -ruN ../openssh-6.0p1.virgin/version.h ./version.h
--- ../openssh-6.0p1.virgin/version.h	2012-02-10 16:19:44.000000000 -0500
+++ ./version.h	2012-09-02 14:55:46.508844901 -0400
@@ -3,4 +3,12 @@
 #define SSH_VERSION	"OpenSSH_6.0"
 
 #define SSH_PORTABLE	"p1"
-#define SSH_RELEASE	SSH_VERSION SSH_PORTABLE
+
+/* it is important to provide an indication that FIPS is supported */
+#ifdef OPENSSL_FIPS_CAPABLE
+	#define SSH_FIPS        "-FIPS"
+#else
+	#define SSH_FIPS        ""
+#endif /* OPENSSL_FIPS_CAPABLE */
+#define SSH_RELEASE     SSH_VERSION SSH_PORTABLE SSH_FIPS
+
