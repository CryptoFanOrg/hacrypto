diff -ruN ../openssh-6.0p1.virgin/auth2-pubkey.c ./auth2-pubkey.c
--- ../openssh-6.0p1.virgin/auth2-pubkey.c	2011-10-02 04:00:00.000000000 -0400
+++ ./auth2-pubkey.c	2012-08-28 12:55:19.213367471 -0400
@@ -363,7 +363,7 @@
 			found_key = 1;
 			debug("matching key found: file %s, line %lu",
 			    file, linenum);
-			fp = key_fingerprint(found, SSH_FP_MD5, SSH_FP_HEX);
+			fp = key_fingerprint(found, key_fingerprint_alg(), SSH_FP_HEX);
 			verbose("Found matching %s key: %s",
 			    key_type(found), fp);
 			xfree(fp);
diff -ruN ../openssh-6.0p1.virgin/auth-rsa.c ./auth-rsa.c
--- ../openssh-6.0p1.virgin/auth-rsa.c	2011-05-29 07:39:38.000000000 -0400
+++ ./auth-rsa.c	2012-08-28 12:55:19.221366460 -0400
@@ -326,7 +326,7 @@
 	 * options; this will be reset if the options cause the
 	 * authentication to be rejected.
 	 */
-	fp = key_fingerprint(key, SSH_FP_MD5, SSH_FP_HEX);
+	fp = key_fingerprint(key, key_fingerprint_alg(), SSH_FP_HEX);
 	verbose("Found matching %s key: %s",
 	    key_type(key), fp);
 	xfree(fp);
diff -ruN ../openssh-6.0p1.virgin/cipher.c ./cipher.c
--- ../openssh-6.0p1.virgin/cipher.c	2009-01-28 00:38:41.000000000 -0500
+++ ./cipher.c	2012-08-28 12:55:19.229365587 -0400
@@ -54,10 +54,9 @@
 extern const EVP_CIPHER *evp_ssh1_bf(void);
 extern const EVP_CIPHER *evp_ssh1_3des(void);
 extern void ssh1_3des_iv(EVP_CIPHER_CTX *, int, u_char *, int);
-extern const EVP_CIPHER *evp_aes_128_ctr(void);
 extern void ssh_aes_ctr_iv(EVP_CIPHER_CTX *, int, u_char *, u_int);
 
-struct Cipher {
+static struct Cipher {
 	char	*name;
 	int	number;		/* for ssh1 only */
 	u_int	block_size;
@@ -72,25 +71,59 @@
 	{ "blowfish",		SSH_CIPHER_BLOWFISH, 8, 32, 0, 1, evp_ssh1_bf },
 
 	{ "3des-cbc",		SSH_CIPHER_SSH2, 8, 24, 0, 1, EVP_des_ede3_cbc },
+#ifndef OPENSSL_FIPS
 	{ "blowfish-cbc",	SSH_CIPHER_SSH2, 8, 16, 0, 1, EVP_bf_cbc },
 	{ "cast128-cbc",	SSH_CIPHER_SSH2, 8, 16, 0, 1, EVP_cast5_cbc },
 	{ "arcfour",		SSH_CIPHER_SSH2, 8, 16, 0, 0, EVP_rc4 },
 	{ "arcfour128",		SSH_CIPHER_SSH2, 8, 16, 1536, 0, EVP_rc4 },
 	{ "arcfour256",		SSH_CIPHER_SSH2, 8, 32, 1536, 0, EVP_rc4 },
+#endif
 	{ "aes128-cbc",		SSH_CIPHER_SSH2, 16, 16, 0, 1, EVP_aes_128_cbc },
 	{ "aes192-cbc",		SSH_CIPHER_SSH2, 16, 24, 0, 1, EVP_aes_192_cbc },
 	{ "aes256-cbc",		SSH_CIPHER_SSH2, 16, 32, 0, 1, EVP_aes_256_cbc },
 	{ "rijndael-cbc@lysator.liu.se",
 				SSH_CIPHER_SSH2, 16, 32, 0, 1, EVP_aes_256_cbc },
-	{ "aes128-ctr",		SSH_CIPHER_SSH2, 16, 16, 0, 0, evp_aes_128_ctr },
-	{ "aes192-ctr",		SSH_CIPHER_SSH2, 16, 24, 0, 0, evp_aes_128_ctr },
-	{ "aes256-ctr",		SSH_CIPHER_SSH2, 16, 32, 0, 0, evp_aes_128_ctr },
+	{ "aes128-ctr",		SSH_CIPHER_SSH2, 16, 16, 0, 0, EVP_aes_128_ctr },
+	{ "aes192-ctr",		SSH_CIPHER_SSH2, 16, 24, 0, 0, EVP_aes_192_ctr },
+	{ "aes256-ctr",		SSH_CIPHER_SSH2, 16, 32, 0, 0, EVP_aes_256_ctr },
 #ifdef USE_CIPHER_ACSS
 	{ "acss@openssh.org",	SSH_CIPHER_SSH2, 16, 5, 0, 0, EVP_acss },
 #endif
 	{ NULL,			SSH_CIPHER_INVALID, 0, 0, 0, 0, NULL }
 };
 
+#ifdef OPENSSL_FIPS
+/* subset of the ciphers table above which is relevant for FIPS140 usage */
+static struct Cipher fips_ciphers[] = {
+	{ "none",		SSH_CIPHER_NONE, 8, 0, 0, 0, EVP_enc_null },
+	{ "3des",		SSH_CIPHER_3DES, 8, 16, 0, 1, evp_ssh1_3des },
+	{ "3des-cbc",		SSH_CIPHER_SSH2, 8, 24, 0, 1, EVP_des_ede3_cbc },
+	{ "aes128-cbc",		SSH_CIPHER_SSH2, 16, 16, 0, 1, EVP_aes_128_cbc },
+	{ "aes192-cbc",		SSH_CIPHER_SSH2, 16, 24, 0, 1, EVP_aes_192_cbc },
+	{ "aes256-cbc",		SSH_CIPHER_SSH2, 16, 32, 0, 1, EVP_aes_256_cbc },
+	{ "rijndael-cbc@lysator.liu.se",
+				SSH_CIPHER_SSH2, 16, 32, 0, 1, EVP_aes_256_cbc },
+	{ "aes128-ctr",		SSH_CIPHER_SSH2, 16, 16, 0, 0, EVP_aes_128_ctr },
+	{ "aes192-ctr",		SSH_CIPHER_SSH2, 16, 24, 0, 0, EVP_aes_192_ctr },
+	{ "aes256-ctr",		SSH_CIPHER_SSH2, 16, 32, 0, 0, EVP_aes_256_ctr },
+	{ NULL,			SSH_CIPHER_INVALID, 0, 0, 0, 0, NULL }
+};
+#endif /* OPENSSL_FIPS */
+
+/* return the correct list of ciphers depending on what mode we are 
+ * operating in (non-FIPS140 or FIPS140 mode)
+ */
+struct Cipher *ciphers_list(void) 
+{
+#ifdef OPENSSL_FIPS
+  if (FIPS_mode()) 
+    return fips_ciphers;
+  else
+#endif /* OPENSSL_FIPS */
+    return ciphers;
+}
+
+
 /*--*/
 
 u_int
@@ -133,7 +166,7 @@
 cipher_by_name(const char *name)
 {
 	Cipher *c;
-	for (c = ciphers; c->name != NULL; c++)
+	for (c = ciphers_list(); c->name != NULL; c++)
 		if (strcmp(c->name, name) == 0)
 			return c;
 	return NULL;
@@ -143,7 +176,7 @@
 cipher_by_number(int id)
 {
 	Cipher *c;
-	for (c = ciphers; c->name != NULL; c++)
+	for (c = ciphers_list(); c->name != NULL; c++)
 		if (c->number == id)
 			return c;
 	return NULL;
@@ -187,7 +220,7 @@
 	Cipher *c;
 	if (name == NULL)
 		return -1;
-	for (c = ciphers; c->name != NULL; c++)
+	for (c = ciphers_list(); c->name != NULL; c++)
 		if (strcasecmp(c->name, name) == 0)
 			return c->number;
 	return -1;
@@ -294,14 +327,18 @@
  * passphrase and using the resulting 16 bytes as the key.
  */
 
-void
+int
 cipher_set_key_string(CipherContext *cc, Cipher *cipher,
     const char *passphrase, int do_encrypt)
 {
 	MD5_CTX md;
 	u_char digest[16];
 
-	MD5_Init(&md);
+	/* note: MD5_Init will fail when in FIPS140 mode and the 
+	 *       error code should have been checked
+	 */
+	if (MD5_Init(&md)<=0)
+	  return -1;
 	MD5_Update(&md, (const u_char *)passphrase, strlen(passphrase));
 	MD5_Final(digest, &md);
 
@@ -309,6 +346,7 @@
 
 	memset(digest, 0, sizeof(digest));
 	memset(&md, 0, sizeof(md));
+	return 0;
 }
 
 /*
@@ -351,10 +389,7 @@
 			ssh_rijndael_iv(&cc->evp, 0, iv, len);
 		else
 #endif
-		if (c->evptype == evp_aes_128_ctr)
-			ssh_aes_ctr_iv(&cc->evp, 0, iv, len);
-		else
-			memcpy(iv, cc->evp.iv, len);
+		memcpy(iv, cc->evp.iv, len);
 		break;
 	case SSH_CIPHER_3DES:
 		ssh1_3des_iv(&cc->evp, 0, iv, 24);
@@ -382,10 +417,7 @@
 			ssh_rijndael_iv(&cc->evp, 1, iv, evplen);
 		else
 #endif
-		if (c->evptype == evp_aes_128_ctr)
-			ssh_aes_ctr_iv(&cc->evp, 1, iv, evplen);
-		else
-			memcpy(cc->evp.iv, iv, evplen);
+		memcpy(cc->evp.iv, iv, evplen);
 		break;
 	case SSH_CIPHER_3DES:
 		ssh1_3des_iv(&cc->evp, 1, iv, 24);
@@ -409,7 +441,11 @@
 	Cipher *c = cc->cipher;
 	int plen = 0;
 
+#ifdef OPENSSL_FIPS
+	if (c->evptype == EVP_acss) {
+#else
 	if (c->evptype == EVP_rc4 || c->evptype == EVP_acss) {
+#endif
 		plen = EVP_X_STATE_LEN(cc->evp);
 		if (dat == NULL)
 			return (plen);
@@ -424,7 +460,11 @@
 	Cipher *c = cc->cipher;
 	int plen;
 
+#ifdef OPENSSL_FIPS
+	if (c->evptype == EVP_acss) {
+#else
 	if (c->evptype == EVP_rc4 || c->evptype == EVP_acss) {
+#endif
 		plen = EVP_X_STATE_LEN(cc->evp);
 		memcpy(EVP_X_STATE(cc->evp), dat, plen);
 	}
diff -ruN ../openssh-6.0p1.virgin/cipher-ctr.c ./cipher-ctr.c
--- ../openssh-6.0p1.virgin/cipher-ctr.c	2010-10-07 07:06:42.000000000 -0400
+++ ./cipher-ctr.c	2012-08-28 12:55:19.237364840 -0400
@@ -14,6 +14,7 @@
  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  */
+#ifndef OPENSSL_FIPS
 #include "includes.h"
 
 #include <sys/types.h>
@@ -141,6 +142,16 @@
 #ifndef SSH_OLD_EVP
 	aes_ctr.flags = EVP_CIPH_CBC_MODE | EVP_CIPH_VARIABLE_LENGTH |
 	    EVP_CIPH_ALWAYS_CALL_INIT | EVP_CIPH_CUSTOM_IV;
+#ifdef OPENSSL_FIPS
+	/* note: required to indicate AES context of usage is okay 
+	 *       when using the non-FIPS openssl build to call into
+	 *       the fips_canister when not using the specific FIPS
+	 *       methods to create the EVP and RSA and DSA objects even
+	 *	 though the code ends up in the same (correct) place
+	 */
+	aes_ctr.flags |= EVP_CIPH_FLAG_FIPS;
+#endif /* OPENSSL_FIPS */
 #endif
 	return (&aes_ctr);
 }
+#endif
diff -ruN ../openssh-6.0p1.virgin/cipher.h ./cipher.h
--- ../openssh-6.0p1.virgin/cipher.h	2009-01-28 00:38:41.000000000 -0500
+++ ./cipher.h	2012-08-28 12:55:19.245364185 -0400
@@ -78,7 +78,7 @@
     const u_char *, u_int, int);
 void	 cipher_crypt(CipherContext *, u_char *, const u_char *, u_int);
 void	 cipher_cleanup(CipherContext *);
-void	 cipher_set_key_string(CipherContext *, Cipher *, const char *, int);
+int	 cipher_set_key_string(CipherContext *, Cipher *, const char *, int);
 u_int	 cipher_blocksize(const Cipher *);
 u_int	 cipher_keylen(const Cipher *);
 u_int	 cipher_is_cbc(const Cipher *);
diff -ruN ../openssh-6.0p1.virgin/configure.ac ./configure.ac
--- ../openssh-6.0p1.virgin/configure.ac	2012-04-19 07:46:38.000000000 -0400
+++ ./configure.ac	2012-08-28 12:55:19.281361207 -0400
@@ -2102,6 +2102,39 @@
 	]
 )
 LIBS="-lcrypto $LIBS"
+AC_ARG_WITH(fips-dir,
+	[  --with-fips-dir=PATH     Specify path to OpenSSL FIPS installation ],
+	[
+		if test "x$withval" != "xno" ; then
+			case "$withval" in
+				# Relative paths
+				./*|../*)	withval="`pwd`/$withval"
+			esac
+			if test -d "$withval/lib"; then
+				if test -n "${need_dash_r}"; then
+					LDFLAGS="-L${withval}/lib -R${withval}/lib ${LDFLAGS}"
+				else
+					LDFLAGS="-L${withval}/lib -Wl,-R${withval} ${LDFLAGS}"
+				fi
+			else
+				if test -n "${need_dash_r}"; then
+					LDFLAGS="-L${withval} -R${withval} ${LDFLAGS}"
+				else
+					LDFLAGS="-L${withval} -Wl,-R${withval} ${LDFLAGS}"
+				fi
+			fi
+			if test -d "$withval/include"; then
+				CPPFLAGS="-DOPENSSL_FIPS -I${withval}/include ${CPPFLAGS}"
+			else
+				CPPFLAGS="-DOPENSSL_FIPS -I${withval} ${CPPFLAGS}"
+			fi
+		fi
+		AC_DEFINE(OPENSSL_FIPS, 1, [FIPS enabled] )
+		openssl_check_nonfatal=1
+		fips="yes"
+	]
+)
+LIBS="-lcrypto $LIBS"
 AC_TRY_LINK_FUNC([RAND_add], [AC_DEFINE([HAVE_OPENSSL], [1],
 	[Define if your ssl headers are included
 	with #include <openssl/header.h>])],
@@ -4310,6 +4343,7 @@
 H=`eval echo ${PRIVSEP_PATH}` ; H=`eval echo ${H}`
 I=`eval echo ${user_path}` ; I=`eval echo ${I}`
 J=`eval echo ${superuser_path}` ; J=`eval echo ${J}`
+K=`eval echo ${fips}` ; J=`eval echo ${K}`
 
 echo ""
 echo "OpenSSH has been configured with the following options:"
@@ -4366,6 +4400,8 @@
 echo "          +for ssh: ${SSHLIBS}"
 fi
 
+echo "                      fips support: $K"
+
 echo ""
 
 if test "x$MAKE_PACKAGE_SUPPORTED" = "xyes" ; then
diff -ruN ../openssh-6.0p1.virgin/key.c ./key.c
--- ../openssh-6.0p1.virgin/key.c	2011-10-18 01:06:16.000000000 -0400
+++ ./key.c	2012-08-28 12:55:19.293360687 -0400
@@ -70,6 +70,17 @@
 	return cert;
 }
 
+
+int key_fingerprint_alg(void)
+{
+#ifdef OPENSSL_FIPS
+  if (FIPS_mode()) 
+    return SSH_FP_SHA1;
+  else
+#endif /* OPENSSL_FIPS */
+    return SSH_FP_MD5;
+}
+
 Key *
 key_new(int type)
 {
diff -ruN ../openssh-6.0p1.virgin/key.h ./key.h
--- ../openssh-6.0p1.virgin/key.h	2010-11-04 19:19:49.000000000 -0400
+++ ./key.h	2012-08-28 12:55:19.305360222 -0400
@@ -33,6 +33,7 @@
 #include <openssl/ec.h>
 #endif
 
+
 typedef struct Key Key;
 enum types {
 	KEY_RSA1,
@@ -101,6 +102,7 @@
 int		 key_write(const Key *, FILE *);
 int		 key_read(Key *, char **);
 u_int		 key_size(const Key *);
+int 		 key_fingerprint_alg(void);
 
 Key	*key_generate(int, u_int);
 Key	*key_from_private(const Key *);
@@ -148,4 +150,5 @@
 void	key_dump_ec_key(const EC_KEY *);
 #endif
 
+
 #endif
diff -ruN ../openssh-6.0p1.virgin/mac.c ./mac.c
--- ../openssh-6.0p1.virgin/mac.c	2012-01-16 22:03:38.000000000 -0500
+++ ./mac.c	2012-08-28 12:55:19.309360129 -0400
@@ -49,14 +49,14 @@
 #define SSH_EVP		1	/* OpenSSL EVP-based MAC */
 #define SSH_UMAC	2	/* UMAC (not integrated with OpenSSL) */
 
-struct {
+static struct Macs {
 	char		*name;
 	int		type;
 	const EVP_MD *	(*mdfunc)(void);
 	int		truncatebits;	/* truncate digest if != 0 */
 	int		key_len;	/* just for UMAC */
 	int		len;		/* just for UMAC */
-} macs[] = {
+} all_macs[] = {
 	{ "hmac-sha1",			SSH_EVP, EVP_sha1, 0, -1, -1 },
 	{ "hmac-sha1-96",		SSH_EVP, EVP_sha1, 96, -1, -1 },
 #ifdef HAVE_EVP_SHA256
@@ -73,10 +73,33 @@
 	{ NULL,				0, NULL, 0, -1, -1 }
 };
 
+#ifdef OPENSSL_FIPS
+static struct Macs fips_macs[] = {
+	{ "hmac-sha1",			SSH_EVP, EVP_sha1, 0, -1, -1 },
+	{ "hmac-sha1-96",		SSH_EVP, EVP_sha1, 96, -1, -1 },
+	{ NULL,				0, NULL, 0, -1, -1 }
+};
+#endif /* OPENSSL_FIPS */
+
+/* return the correct list of ciphers depending on what mode we are 
+ * operating in (non-FIPS140 or FIPS140 mode)
+ */
+struct Macs *macs_list(void) 
+{
+#ifdef OPENSSL_FIPS
+  if (FIPS_mode()) 
+    return fips_macs;
+  else
+#endif /* OPENSSL_FIPS */
+    return all_macs;
+}
+
 static void
 mac_setup_by_id(Mac *mac, int which)
 {
 	int evp_len;
+	struct Macs *macs=macs_list();
+
 	mac->type = macs[which].type;
 	if (mac->type == SSH_EVP) {
 		mac->evp_md = (*macs[which].mdfunc)();
@@ -96,6 +119,7 @@
 mac_setup(Mac *mac, char *name)
 {
 	int i;
+	struct Macs *macs=macs_list();
 
 	for (i = 0; macs[i].name; i++) {
 		if (strcmp(name, macs[i].name) == 0) {
diff -ruN ../openssh-6.0p1.virgin/myproposal.h ./myproposal.h
--- ../openssh-6.0p1.virgin/myproposal.h	2011-08-16 20:29:03.000000000 -0400
+++ ./myproposal.h	2012-08-28 12:55:19.317360001 -0400
@@ -97,6 +97,16 @@
 #define	KEX_DEFAULT_COMP	"none,zlib@openssh.com,zlib"
 #define	KEX_DEFAULT_LANG	""
 
+#ifdef OPENSSL_FIPS
+/* FIPS subset (note: matches cipher.c and mac.c lists) */
+#define	KEX_FIPS_ENCRYPT \
+	"aes128-ctr,aes192-ctr,aes256-ctr," \
+	"aes128-cbc,3des-cbc," \
+	"aes192-cbc,aes256-cbc,rijndael-cbc@lysator.liu.se"
+#define	KEX_FIPS_MAC \
+	"hmac-sha1,hmac-sha1-96"
+#endif /* OPENSSL_FIPS */
+
 
 static char *myproposal[PROPOSAL_MAX] = {
 	KEX_DEFAULT_KEX,
diff -ruN ../openssh-6.0p1.virgin/openbsd-compat/bsd-arc4random.c ./openbsd-compat/bsd-arc4random.c
--- ../openssh-6.0p1.virgin/openbsd-compat/bsd-arc4random.c	2010-03-25 17:52:02.000000000 -0400
+++ ./openbsd-compat/bsd-arc4random.c	2012-08-28 12:55:19.333360320 -0400
@@ -27,7 +27,9 @@
 #ifndef HAVE_ARC4RANDOM
 
 #include <openssl/rand.h>
+#ifndef OPENSSL_FIPS
 #include <openssl/rc4.h>
+#endif
 #include <openssl/err.h>
 
 /* Size of key to use */
@@ -37,12 +39,24 @@
 #define REKEY_BYTES	(1 << 24)
 
 static int rc4_ready = 0;
+#ifndef OPENSSL_FIPS
 static RC4_KEY rc4;
+#endif
 
 unsigned int
 arc4random(void)
 {
 	unsigned int r = 0;
+#ifdef OPENSSL_FIPS
+	if (RAND_bytes(&r,sizeof(r)) <= 0) {
+		/* unfortunately there is no simple way to report this
+		 * to the caller for handling so this is done via
+		 * fatal() as per arc4random_stir
+		 */
+		fatal("Could not obtain random bytes (error %ld)",
+			ERR_get_error());
+	}
+#else /* !OPENSSL_FIPS */
 	static int first_time = 1;
 
 	if (rc4_ready <= 0) {
@@ -56,12 +70,14 @@
 
 	rc4_ready -= sizeof(r);
 	
+#endif /* OPENSSL_FIPS */
 	return(r);
 }
 
 void
 arc4random_stir(void)
 {
+#ifndef OPENSSL_FIPS
 	unsigned char rand_buf[SEED_SIZE];
 	int i;
 
@@ -81,6 +97,7 @@
 	memset(rand_buf, 0, sizeof(rand_buf));
 
 	rc4_ready = REKEY_BYTES;
+#endif /* !OPENSSL_FIPS */
 }
 #endif /* !HAVE_ARC4RANDOM */
 
diff -ruN ../openssh-6.0p1.virgin/ssh-add.c ./ssh-add.c
--- ../openssh-6.0p1.virgin/ssh-add.c	2011-11-03 19:51:51.000000000 -0400
+++ ./ssh-add.c	2012-08-28 12:55:19.341360407 -0400
@@ -301,7 +301,7 @@
 		    key = ssh_get_next_identity(ac, &comment, version)) {
 			had_identities = 1;
 			if (do_fp) {
-				fp = key_fingerprint(key, SSH_FP_MD5,
+				fp = key_fingerprint(key, key_fingerprint_alg(),
 				    SSH_FP_HEX);
 				printf("%d %s %s (%s)\n",
 				    key_size(key), fp, comment, key_type(key));
diff -ruN ../openssh-6.0p1.virgin/ssh-agent.c ./ssh-agent.c
--- ../openssh-6.0p1.virgin/ssh-agent.c	2011-06-03 00:14:16.000000000 -0400
+++ ./ssh-agent.c	2012-08-28 12:55:19.349360459 -0400
@@ -199,7 +199,7 @@
 	char *p;
 	int ret = -1;
 
-	p = key_fingerprint(id->key, SSH_FP_MD5, SSH_FP_HEX);
+	p = key_fingerprint(id->key, key_fingerprint_alg(), SSH_FP_HEX);
 	if (ask_permission("Allow use of key %s?\nKey fingerprint %s.",
 	    id->comment, p))
 		ret = 0;
@@ -285,7 +285,13 @@
 		}
 		memset(buf, 0, 32);
 		BN_bn2bin(challenge, buf + 32 - len);
-		MD5_Init(&md);
+
+		/* note: MD5_Init will fail when in FIPS140 mode and the 
+		 *       error code should have been checked
+		 */
+		if (MD5_Init(&md)<=0) {
+		  goto failure;
+		}
 		MD5_Update(&md, buf, 32);
 		MD5_Update(&md, session_id, 16);
 		MD5_Final(mdbuf, &md);
diff -ruN ../openssh-6.0p1.virgin/ssh.c ./ssh.c
--- ../openssh-6.0p1.virgin/ssh.c	2011-11-03 19:54:22.000000000 -0400
+++ ssh.c	2012-08-28 13:31:53.662181902 -0400
@@ -249,6 +249,24 @@
 	struct servent *sp;
 	Forward fwd;
 
+#ifdef OPENSSL_FIPS
+	/* note: there should be a command line option to indicate FIPS140 
+	 *       mode; however OpenSSL itself uses OPENSSL_FIPS to indicate
+	 *       wanting to run in FIPS mode
+	 */
+	if (getenv("OPENSSL_FIPS")) {
+	  if (!FIPS_mode_set(1)) {
+	    /* make sure the error stack is available for some hint as
+	     * to why this operation failed
+	     */
+	    ERR_load_crypto_strings();
+	    ERR_print_errors_fp(stdout);
+	    printf("FIPS_mode_set(): failed to enter FIPS mode!\n");
+	    exit(1);
+	  }
+	}
+#endif /* OPENSSL_FIPS */
+
 	/* Ensure that fds 0, 1 and 2 are open or directed to /dev/null */
 	sanitise_stdfd();
 
@@ -329,6 +347,17 @@
 	    "ACD:F:I:KL:MNO:PR:S:TVw:W:XYy")) != -1) {
 		switch (opt) {
 		case '1':
+#ifdef OPENSSL_FIPS
+		      /* we need to check that we have selected the right 
+		       * SSH protocol for FIPS mode - otherwise it will simply 
+		       * not work and the error messages reported will not be 
+		       * particularly useful to the user; so if the user
+		       * explicitly requests protocol 1 we need to tell them
+		       * that it isn't acceptable in FIPS mode
+		       */
+			if (FIPS_mode())
+			  fatal("Protocol 1 is not allowed in FIPS mode");
+#endif /* OPENSSL_FIPS */
 			options.protocol = SSH_PROTO_1;
 			break;
 		case '2':
@@ -791,6 +820,20 @@
 
 	timeout_ms = options.connection_timeout * 1000;
 
+#ifdef OPENSSL_FIPS
+	/* after all the configuration files have been processed we 
+	 * need to check that we have selected the right SSH protocol
+	 * for FIPS mode - otherwise it will simply not work and the error
+	 * messages reported will not be particularly useful to the user
+	 */
+	if (FIPS_mode()) {
+		options.protocol &= SSH_PROTO_2;
+		if (options.protocol == 0)
+			fatal("Protocol 2 disabled by configuration but required by FIPS mode");
+		debug("FIPS mode initialized");
+	}
+#endif /* OPENSSL_FIPS */
+
 	/* Open a connection to the remote host. */
 	if (ssh_connect(host, &hostaddr, options.port,
 	    options.address_family, options.connection_attempts, &timeout_ms,
diff -ruN ../openssh-6.0p1.virgin/sshconnect2.c ./sshconnect2.c
--- ../openssh-6.0p1.virgin/sshconnect2.c	2011-05-29 07:42:34.000000000 -0400
+++ ./sshconnect2.c	2012-08-28 12:55:19.373360739 -0400
@@ -171,6 +171,12 @@
 		myproposal[PROPOSAL_ENC_ALGS_CTOS] =
 		myproposal[PROPOSAL_ENC_ALGS_STOC] = options.ciphers;
 	}
+#ifdef OPENSSL_FIPS
+	else if (FIPS_mode()) {
+		myproposal[PROPOSAL_ENC_ALGS_CTOS] =
+		myproposal[PROPOSAL_ENC_ALGS_STOC] = KEX_FIPS_ENCRYPT;
+	}
+#endif /* OPENSSL_FIPS */
 	myproposal[PROPOSAL_ENC_ALGS_CTOS] =
 	    compat_cipher_proposal(myproposal[PROPOSAL_ENC_ALGS_CTOS]);
 	myproposal[PROPOSAL_ENC_ALGS_STOC] =
@@ -186,6 +192,12 @@
 		myproposal[PROPOSAL_MAC_ALGS_CTOS] =
 		myproposal[PROPOSAL_MAC_ALGS_STOC] = options.macs;
 	}
+#ifdef OPENSSL_FIPS
+ 	else if (FIPS_mode()) {
+		myproposal[PROPOSAL_MAC_ALGS_CTOS] =
+		myproposal[PROPOSAL_MAC_ALGS_STOC] = KEX_FIPS_MAC;
+	}
+#endif /* OPENSSL_FIPS */
 	if (options.hostkeyalgorithms != NULL)
 		myproposal[PROPOSAL_SERVER_HOST_KEY_ALGS] =
 		    options.hostkeyalgorithms;
@@ -591,7 +603,7 @@
 		    key->type, pktype);
 		goto done;
 	}
-	fp = key_fingerprint(key, SSH_FP_MD5, SSH_FP_HEX);
+	fp = key_fingerprint(key, key_fingerprint_alg(), SSH_FP_HEX);
 	debug2("input_userauth_pk_ok: fp %s", fp);
 	xfree(fp);
 
diff -ruN ../openssh-6.0p1.virgin/sshconnect.c ./sshconnect.c
--- ../openssh-6.0p1.virgin/sshconnect.c	2011-05-29 07:42:34.000000000 -0400
+++ ./sshconnect.c	2012-08-28 12:55:19.381360826 -0400
@@ -556,7 +556,7 @@
 	snprintf(buf, sizeof buf, "SSH-%d.%d-%.100s%s",
 	    compat20 ? PROTOCOL_MAJOR_2 : PROTOCOL_MAJOR_1,
 	    compat20 ? PROTOCOL_MINOR_2 : minor1,
-	    SSH_VERSION, compat20 ? "\r\n" : "\n");
+	    SSH_VERSION SSH_FIPS, compat20 ? "\r\n" : "\n");
 	if (roaming_atomicio(vwrite, connection_out, buf, strlen(buf))
 	    != strlen(buf))
 		fatal("write: %.100s", strerror(errno));
@@ -805,8 +805,9 @@
 				    "key for IP address '%.128s' to the list "
 				    "of known hosts.", type, ip);
 		} else if (options.visual_host_key) {
-			fp = key_fingerprint(host_key, SSH_FP_MD5, SSH_FP_HEX);
-			ra = key_fingerprint(host_key, SSH_FP_MD5,
+			fp = key_fingerprint(host_key, key_fingerprint_alg(), 
+			    SSH_FP_HEX);
+			ra = key_fingerprint(host_key, key_fingerprint_alg(),
 			    SSH_FP_RANDOMART);
 			logit("Host key fingerprint is %s\n%s\n", fp, ra);
 			xfree(ra);
@@ -846,8 +847,9 @@
 			else
 				snprintf(msg1, sizeof(msg1), ".");
 			/* The default */
-			fp = key_fingerprint(host_key, SSH_FP_MD5, SSH_FP_HEX);
-			ra = key_fingerprint(host_key, SSH_FP_MD5,
+			fp = key_fingerprint(host_key, key_fingerprint_alg(), 
+			    SSH_FP_HEX);
+			ra = key_fingerprint(host_key, key_fingerprint_alg(),
 			    SSH_FP_RANDOMART);
 			msg2[0] = '\0';
 			if (options.verify_host_key_dns) {
@@ -863,10 +865,12 @@
 			snprintf(msg, sizeof(msg),
 			    "The authenticity of host '%.200s (%s)' can't be "
 			    "established%s\n"
-			    "%s key fingerprint is %s.%s%s\n%s"
+			    "%s key %sfingerprint is %s.%s%s\n%s"
 			    "Are you sure you want to continue connecting "
 			    "(yes/no)? ",
-			    host, ip, msg1, type, fp,
+			    host, ip, msg1, type, 
+			    key_fingerprint_alg()==SSH_FP_SHA1?"SHA1 ":"",
+			    fp,
 			    options.visual_host_key ? "\n" : "",
 			    options.visual_host_key ? ra : "",
 			    msg2);
@@ -1111,7 +1115,7 @@
 	int flags = 0;
 	char *fp;
 
-	fp = key_fingerprint(host_key, SSH_FP_MD5, SSH_FP_HEX);
+	fp = key_fingerprint(host_key, key_fingerprint_alg(), SSH_FP_HEX);
 	debug("Server host key: %s %s", key_type(host_key), fp);
 	xfree(fp);
 
@@ -1213,14 +1217,16 @@
 			continue;
 		if (!lookup_key_in_hostkeys_by_type(hostkeys, type[i], &found))
 			continue;
-		fp = key_fingerprint(found->key, SSH_FP_MD5, SSH_FP_HEX);
-		ra = key_fingerprint(found->key, SSH_FP_MD5, SSH_FP_RANDOMART);
+		fp = key_fingerprint(found->key, key_fingerprint_alg(), SSH_FP_HEX);
+		ra = key_fingerprint(found->key, key_fingerprint_alg(), SSH_FP_RANDOMART);
 		logit("WARNING: %s key found for host %s\n"
 		    "in %s:%lu\n"
-		    "%s key fingerprint %s.",
+		    "%s key %sfingerprint %s.\n%s\n",
 		    key_type(found->key),
 		    found->host, found->file, found->line,
-		    key_type(found->key), fp);
+		    key_type(found->key),
+		    key_fingerprint_alg()==SSH_FP_SHA1?"SHA1 ":"",
+		    fp, ra);
 		if (options.visual_host_key)
 			logit("%s", ra);
 		xfree(ra);
@@ -1234,8 +1240,9 @@
 warn_changed_key(Key *host_key)
 {
 	char *fp;
+	const char *type = key_type(host_key);
 
-	fp = key_fingerprint(host_key, SSH_FP_MD5, SSH_FP_HEX);
+	fp = key_fingerprint(host_key, key_fingerprint_alg(), SSH_FP_HEX);
 
 	error("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@");
 	error("@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @");
@@ -1243,8 +1250,8 @@
 	error("IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!");
 	error("Someone could be eavesdropping on you right now (man-in-the-middle attack)!");
 	error("It is also possible that a host key has just been changed.");
-	error("The fingerprint for the %s key sent by the remote host is\n%s.",
-	    key_type(host_key), fp);
+	error("The %sfingerprint for the %s key sent by the remote host is\n%s.",
+            key_fingerprint_alg()==SSH_FP_SHA1?"SHA1 ":"", type, fp);
 	error("Please contact your system administrator.");
 
 	xfree(fp);
diff -ruN ../openssh-6.0p1.virgin/sshd.c ./sshd.c
--- ../openssh-6.0p1.virgin/sshd.c	2012-02-14 13:03:31.000000000 -0500
+++ ./sshd.c	2012-08-28 12:55:19.397361005 -0400
@@ -78,6 +78,10 @@
 #include <openssl/rand.h>
 #include "openbsd-compat/openssl-compat.h"
 
+#ifdef OPENSSL_FIPS
+#include <openssl/err.h>
+#endif /* OPENSSL_FIPS */
+
 #ifdef HAVE_SECUREWARE
 #include <sys/security.h>
 #include <prot.h>
@@ -419,8 +423,8 @@
 		major = PROTOCOL_MAJOR_1;
 		minor = PROTOCOL_MINOR_1;
 	}
-	snprintf(buf, sizeof buf, "SSH-%d.%d-%.100s%s", major, minor,
-	    SSH_VERSION, newline);
+	snprintf(buf, sizeof buf, "SSH-%d.%d-%.100s%s%s", major, minor,
+	    SSH_VERSION SSH_FIPS, FIPS_mode()?"(enabled)":"(capable)", newline);
 	server_version_string = xstrdup(buf);
 
 	/* Send our protocol version identification. */
@@ -1329,6 +1333,24 @@
 	Key *key;
 	Authctxt *authctxt;
 
+#ifdef OPENSSL_FIPS
+	/* note: there should be a command line option to indicate FIPS140 
+	 *       mode; however OpenSSL itself uses OPENSSL_FIPS to indicate
+	 *       wanting to run in FIPS mode
+	 */
+	if (getenv("OPENSSL_FIPS")) {
+	  if (!FIPS_mode_set(1)) {
+	    /* make sure the error stack is available for some hint as
+	     * to why this operation failed
+	     */
+	    ERR_load_crypto_strings();
+	    ERR_print_errors_fp(stdout);
+	    printf("FIPS_mode_set(): failed to enter FIPS mode!\n");
+	    exit(1);
+	  }
+	}
+#endif /* OPENSSL_FIPS */
+
 #ifdef HAVE_SECUREWARE
 	(void)set_auth_parameters(ac, av);
 #endif
@@ -1612,6 +1634,12 @@
 		debug("private host key: #%d type %d %s", i, key->type,
 		    key_type(key));
 	}
+#ifdef OPENSSL_FIPS
+	if ((options.protocol & SSH_PROTO_1) && FIPS_mode()) {
+		logit("Disabling protocol version 1. Not allowed in FIPS mode");
+		options.protocol &= ~SSH_PROTO_1;
+	}
+#endif /* OPENSSL_FIPS */
 	if ((options.protocol & SSH_PROTO_1) && !sensitive_data.have_ssh1_key) {
 		logit("Disabling protocol version 1. Could not load host key");
 		options.protocol &= ~SSH_PROTO_1;
@@ -1776,6 +1804,12 @@
 	/* Initialize the random number generator. */
 	arc4random_stir();
 
+#ifdef OPENSSL_FIPS
+	if (FIPS_mode()) {
+		logit("FIPS mode initialized");
+	}
+#endif /* OPENSSL_FIPS */
+
 	/* Chdir to the root directory so that the current disk can be
 	   unmounted if desired. */
 	chdir("/");
@@ -2308,6 +2342,12 @@
 		myproposal[PROPOSAL_ENC_ALGS_CTOS] =
 		myproposal[PROPOSAL_ENC_ALGS_STOC] = options.ciphers;
 	}
+#ifdef OPENSSL_FIPS
+	else if (FIPS_mode()) {
+		myproposal[PROPOSAL_ENC_ALGS_CTOS] =
+		myproposal[PROPOSAL_ENC_ALGS_STOC] = KEX_FIPS_ENCRYPT;
+	}
+#endif /* OPENSSL_FIPS */
 	myproposal[PROPOSAL_ENC_ALGS_CTOS] =
 	    compat_cipher_proposal(myproposal[PROPOSAL_ENC_ALGS_CTOS]);
 	myproposal[PROPOSAL_ENC_ALGS_STOC] =
@@ -2317,6 +2357,12 @@
 		myproposal[PROPOSAL_MAC_ALGS_CTOS] =
 		myproposal[PROPOSAL_MAC_ALGS_STOC] = options.macs;
 	}
+#ifdef OPENSSL_FIPS
+	else if (FIPS_mode()) {
+		myproposal[PROPOSAL_MAC_ALGS_CTOS] =
+		myproposal[PROPOSAL_MAC_ALGS_STOC] = KEX_FIPS_MAC;
+	}
+#endif /* OPENSSL_FIPS */
 	if (options.compression == COMP_NONE) {
 		myproposal[PROPOSAL_COMP_ALGS_CTOS] =
 		myproposal[PROPOSAL_COMP_ALGS_STOC] = "none";
diff -ruN ../openssh-6.0p1.virgin/ssh-dss.c ./ssh-dss.c
--- ../openssh-6.0p1.virgin/ssh-dss.c	2010-08-31 08:36:39.000000000 -0400
+++ ./ssh-dss.c	2012-08-28 12:55:19.405361096 -0400
@@ -47,26 +47,48 @@
     const u_char *data, u_int datalen)
 {
 	DSA_SIG *sig;
-	const EVP_MD *evp_md = EVP_sha1();
+	const EVP_MD *evp_md = EVP_dss1();
 	EVP_MD_CTX md;
-	u_char digest[EVP_MAX_MD_SIZE], sigblob[SIGBLOB_LEN];
-	u_int rlen, slen, len, dlen;
+	u_char sigblob[SIGBLOB_LEN];
+	u_int rlen, slen, len;
 	Buffer b;
+	u_char *tsig;
+	const u_char *psig;
+	EVP_PKEY *pkey;
+	int ok;
 
 	if (key == NULL || key->dsa == NULL || (key->type != KEY_DSA &&
 	    key->type != KEY_DSA_CERT && key->type != KEY_DSA_CERT_V00)) {
 		error("ssh_dss_sign: no DSA key");
 		return -1;
 	}
-	EVP_DigestInit(&md, evp_md);
-	EVP_DigestUpdate(&md, data, datalen);
-	EVP_DigestFinal(&md, digest, &dlen);
+	pkey = EVP_PKEY_new();
+	EVP_PKEY_set1_DSA(pkey, key->dsa);
+	slen = EVP_PKEY_size(pkey);
+	tsig = xmalloc(slen);
+
+	EVP_MD_CTX_init(&md);
+	EVP_SignInit_ex(&md, evp_md, NULL);
+	EVP_SignUpdate(&md, data, datalen);
+	ok = EVP_SignFinal(&md, tsig, &len, pkey);
+	EVP_MD_CTX_cleanup(&md);
+	EVP_PKEY_free(pkey);
 
-	sig = DSA_do_sign(digest, dlen, key->dsa);
-	memset(digest, 'd', sizeof(digest));
+	if (ok != 1) {
+		xfree(tsig);
+		error("ssh_dss_sign: sign failed");
+		return -1;
+	}
+
+	psig = tsig;
+
+	/* Output of EVP_SignFinal() is encoded, convert to DSA_SIG */
+	sig = d2i_DSA_SIG(NULL, &psig, len);
+	memset(tsig, 'd', len);
+	xfree(tsig);
 
 	if (sig == NULL) {
-		error("ssh_dss_sign: sign failed");
+		error("ssh_dss_sign: DSA parse failed");
 		return -1;
 	}
 
@@ -110,12 +132,14 @@
     const u_char *data, u_int datalen)
 {
 	DSA_SIG *sig;
-	const EVP_MD *evp_md = EVP_sha1();
+	const EVP_MD *evp_md = EVP_dss1();
 	EVP_MD_CTX md;
-	u_char digest[EVP_MAX_MD_SIZE], *sigblob;
-	u_int len, dlen;
+	u_char *sigblob;
+	u_int len;
 	int rlen, ret;
 	Buffer b;
+        u_char *tsig, *psig;
+	EVP_PKEY *pkey;
 
 	if (key == NULL || key->dsa == NULL || (key->type != KEY_DSA &&
 	    key->type != KEY_DSA_CERT && key->type != KEY_DSA_CERT_V00)) {
@@ -171,15 +195,27 @@
 	memset(sigblob, 0, len);
 	xfree(sigblob);
 
-	/* sha1 the data */
-	EVP_DigestInit(&md, evp_md);
-	EVP_DigestUpdate(&md, data, datalen);
-	EVP_DigestFinal(&md, digest, &dlen);
-
-	ret = DSA_do_verify(digest, dlen, sig, key->dsa);
-	memset(digest, 'd', sizeof(digest));
-
-	DSA_SIG_free(sig);
+        /* Sig is in DSA_SIG structure, convert to encoded buffer */
+        len = i2d_DSA_SIG(sig, NULL);
+        tsig = xmalloc(len);
+        psig = tsig;
+        i2d_DSA_SIG(sig, &psig);
+        DSA_SIG_free(sig);
+  
+        pkey = EVP_PKEY_new();
+        EVP_PKEY_set1_DSA(pkey, key->dsa);
+  
+        /* now verify signature */
+        EVP_MD_CTX_init(&md);
+        EVP_VerifyInit(&md, evp_md);
+        EVP_VerifyUpdate(&md, data, datalen);
+        ret = EVP_VerifyFinal(&md, tsig, len, pkey);
+        EVP_MD_CTX_cleanup(&md);
+        EVP_PKEY_free(pkey);
+  
+        /* Cleanup buffer */
+        memset(tsig, 'd', len);
+        xfree(tsig);
 
 	debug("ssh_dss_verify: signature %s",
 	    ret == 1 ? "correct" : ret == 0 ? "incorrect" : "error");
diff -ruN ../openssh-6.0p1.virgin/ssh-keygen.c ./ssh-keygen.c
--- ../openssh-6.0p1.virgin/ssh-keygen.c	2012-02-05 15:41:31.000000000 -0500
+++ ./ssh-keygen.c	2012-08-28 12:55:19.417361231 -0400
@@ -749,7 +749,7 @@
 	enum fp_type fptype;
 	struct stat st;
 
-	fptype = print_bubblebabble ? SSH_FP_SHA1 : SSH_FP_MD5;
+	fptype = print_bubblebabble ? SSH_FP_SHA1 : key_fingerprint_alg();
 	rep =    print_bubblebabble ? SSH_FP_BUBBLEBABBLE : SSH_FP_HEX;
 
 	if (!have_identity)
@@ -948,7 +948,7 @@
 		enum fp_type fptype;
 		char *fp, *ra;
 
-		fptype = print_bubblebabble ? SSH_FP_SHA1 : SSH_FP_MD5;
+		fptype = print_bubblebabble ? SSH_FP_SHA1 : key_fingerprint_alg();
 		rep =    print_bubblebabble ? SSH_FP_BUBBLEBABBLE : SSH_FP_HEX;
 		fp = key_fingerprint(public, fptype, rep);
 		ra = key_fingerprint(public, SSH_FP_MD5, SSH_FP_RANDOMART);
@@ -1935,6 +1935,24 @@
 	extern int optind;
 	extern char *optarg;
 
+#ifdef OPENSSL_FIPS
+	/* note: there should be a command line option to indicate FIPS140 
+	 *       mode; however OpenSSL itself uses OPENSSL_FIPS to indicate
+	 *       wanting to run in FIPS mode
+	 */
+	if (getenv("OPENSSL_FIPS")) {
+	  if (!FIPS_mode_set(1)) {
+	    /* make sure the error stack is available for some hint as
+	     * to why this operation failed
+	     */
+	    ERR_load_crypto_strings();
+	    ERR_print_errors_fp(stdout);
+	    printf("FIPS_mode_set(): failed to enter FIPS mode!\n");
+	    exit(1);
+	  }
+	}
+#endif /* OPENSSL_FIPS */
+
 	/* Ensure that fds 0, 1 and 2 are open or directed to /dev/null */
 	sanitise_stdfd();
 
@@ -2362,8 +2380,9 @@
 	fclose(f);
 
 	if (!quiet) {
-		char *fp = key_fingerprint(public, SSH_FP_MD5, SSH_FP_HEX);
-		char *ra = key_fingerprint(public, SSH_FP_MD5,
+		char *fp = key_fingerprint(public, key_fingerprint_alg(), 
+		    SSH_FP_HEX);
+		char *ra = key_fingerprint(public, key_fingerprint_alg(),
 		    SSH_FP_RANDOMART);
 		printf("Your public key has been saved in %s.\n",
 		    identity_file);
diff -ruN ../openssh-6.0p1.virgin/ssh-rsa.c ./ssh-rsa.c
--- ../openssh-6.0p1.virgin/ssh-rsa.c	2010-08-31 08:36:39.000000000 -0400
+++ ./ssh-rsa.c	2012-08-28 12:55:19.429361366 -0400
@@ -42,10 +42,11 @@
 {
 	const EVP_MD *evp_md;
 	EVP_MD_CTX md;
-	u_char digest[EVP_MAX_MD_SIZE], *sig;
-	u_int slen, dlen, len;
+	u_char *sig;
+	u_int slen, len;
 	int ok, nid;
 	Buffer b;
+	EVP_PKEY *pkey;
 
 	if (key == NULL || key->rsa == NULL || (key->type != KEY_RSA &&
 	    key->type != KEY_RSA_CERT && key->type != KEY_RSA_CERT_V00)) {
@@ -57,15 +58,17 @@
 		error("ssh_rsa_sign: EVP_get_digestbynid %d failed", nid);
 		return -1;
 	}
-	EVP_DigestInit(&md, evp_md);
-	EVP_DigestUpdate(&md, data, datalen);
-	EVP_DigestFinal(&md, digest, &dlen);
-
-	slen = RSA_size(key->rsa);
+	pkey = EVP_PKEY_new();
+	EVP_PKEY_set1_RSA(pkey, key->rsa);
+	slen = EVP_PKEY_size(pkey);
 	sig = xmalloc(slen);
 
-	ok = RSA_sign(nid, digest, dlen, sig, &len, key->rsa);
-	memset(digest, 'd', sizeof(digest));
+	EVP_MD_CTX_init(&md);
+	EVP_SignInit_ex(&md, evp_md, NULL);
+	EVP_SignUpdate(&md, data, datalen);
+	ok = EVP_SignFinal(&md, sig, &len, pkey);
+	EVP_MD_CTX_cleanup(&md);
+	EVP_PKEY_free(pkey);
 
 	if (ok != 1) {
 		int ecode = ERR_get_error();
@@ -111,9 +114,10 @@
 	const EVP_MD *evp_md;
 	EVP_MD_CTX md;
 	char *ktype;
-	u_char digest[EVP_MAX_MD_SIZE], *sigblob;
-	u_int len, dlen, modlen;
+	u_char *sigblob;
+	u_int len, modlen;
 	int rlen, ret, nid;
+	EVP_PKEY *pkey;
 
 	if (key == NULL || key->rsa == NULL || (key->type != KEY_RSA &&
 	    key->type != KEY_RSA_CERT && key->type != KEY_RSA_CERT_V00)) {
@@ -164,105 +168,17 @@
 		xfree(sigblob);
 		return -1;
 	}
-	EVP_DigestInit(&md, evp_md);
-	EVP_DigestUpdate(&md, data, datalen);
-	EVP_DigestFinal(&md, digest, &dlen);
+	pkey = EVP_PKEY_new();
+	EVP_PKEY_set1_RSA(pkey, key->rsa);
+	EVP_MD_CTX_init(&md);
+	EVP_VerifyInit_ex(&md, evp_md, NULL);
+	EVP_VerifyUpdate(&md, data, datalen);
+	ret = EVP_VerifyFinal(&md, sigblob, len, pkey);
+	EVP_MD_CTX_cleanup(&md);
+	EVP_PKEY_free(pkey);
 
-	ret = openssh_RSA_verify(nid, digest, dlen, sigblob, len, key->rsa);
-	memset(digest, 'd', sizeof(digest));
 	memset(sigblob, 's', len);
 	xfree(sigblob);
 	debug("ssh_rsa_verify: signature %scorrect", (ret==0) ? "in" : "");
 	return ret;
 }
-
-/*
- * See:
- * http://www.rsasecurity.com/rsalabs/pkcs/pkcs-1/
- * ftp://ftp.rsasecurity.com/pub/pkcs/pkcs-1/pkcs-1v2-1.asn
- */
-/*
- * id-sha1 OBJECT IDENTIFIER ::= { iso(1) identified-organization(3)
- *	oiw(14) secsig(3) algorithms(2) 26 }
- */
-static const u_char id_sha1[] = {
-	0x30, 0x21, /* type Sequence, length 0x21 (33) */
-	0x30, 0x09, /* type Sequence, length 0x09 */
-	0x06, 0x05, /* type OID, length 0x05 */
-	0x2b, 0x0e, 0x03, 0x02, 0x1a, /* id-sha1 OID */
-	0x05, 0x00, /* NULL */
-	0x04, 0x14  /* Octet string, length 0x14 (20), followed by sha1 hash */
-};
-/*
- * id-md5 OBJECT IDENTIFIER ::= { iso(1) member-body(2) us(840)
- *	rsadsi(113549) digestAlgorithm(2) 5 }
- */
-static const u_char id_md5[] = {
-	0x30, 0x20, /* type Sequence, length 0x20 (32) */
-	0x30, 0x0c, /* type Sequence, length 0x09 */
-	0x06, 0x08, /* type OID, length 0x05 */
-	0x2a, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x02, 0x05, /* id-md5 */
-	0x05, 0x00, /* NULL */
-	0x04, 0x10  /* Octet string, length 0x10 (16), followed by md5 hash */
-};
-
-static int
-openssh_RSA_verify(int type, u_char *hash, u_int hashlen,
-    u_char *sigbuf, u_int siglen, RSA *rsa)
-{
-	u_int ret, rsasize, oidlen = 0, hlen = 0;
-	int len, oidmatch, hashmatch;
-	const u_char *oid = NULL;
-	u_char *decrypted = NULL;
-
-	ret = 0;
-	switch (type) {
-	case NID_sha1:
-		oid = id_sha1;
-		oidlen = sizeof(id_sha1);
-		hlen = 20;
-		break;
-	case NID_md5:
-		oid = id_md5;
-		oidlen = sizeof(id_md5);
-		hlen = 16;
-		break;
-	default:
-		goto done;
-	}
-	if (hashlen != hlen) {
-		error("bad hashlen");
-		goto done;
-	}
-	rsasize = RSA_size(rsa);
-	if (siglen == 0 || siglen > rsasize) {
-		error("bad siglen");
-		goto done;
-	}
-	decrypted = xmalloc(rsasize);
-	if ((len = RSA_public_decrypt(siglen, sigbuf, decrypted, rsa,
-	    RSA_PKCS1_PADDING)) < 0) {
-		error("RSA_public_decrypt failed: %s",
-		    ERR_error_string(ERR_get_error(), NULL));
-		goto done;
-	}
-	if (len < 0 || (u_int)len != hlen + oidlen) {
-		error("bad decrypted len: %d != %d + %d", len, hlen, oidlen);
-		goto done;
-	}
-	oidmatch = timingsafe_bcmp(decrypted, oid, oidlen) == 0;
-	hashmatch = timingsafe_bcmp(decrypted + oidlen, hash, hlen) == 0;
-	if (!oidmatch) {
-		error("oid mismatch");
-		goto done;
-	}
-	if (!hashmatch) {
-		error("hash mismatch");
-		goto done;
-	}
-	ret = 1;
-done:
-	if (decrypted)
-		xfree(decrypted);
-	return ret;
-}
diff -ruN ../openssh-6.0p1.virgin/version.h ./version.h
--- ../openssh-6.0p1.virgin/version.h	2012-02-10 16:19:44.000000000 -0500
+++ ./version.h	2012-08-28 12:55:19.437361456 -0400
@@ -3,4 +3,12 @@
 #define SSH_VERSION	"OpenSSH_6.0"
 
 #define SSH_PORTABLE	"p1"
-#define SSH_RELEASE	SSH_VERSION SSH_PORTABLE
+
+/* it is important to provide an indication that FIPS is supported */
+#ifdef OPENSSL_FIPS
+	#define SSH_FIPS        "-FIPS"
+#else
+	#define SSH_FIPS        ""
+#endif /* OPENSSL_FIPS */
+#define SSH_RELEASE     SSH_VERSION SSH_PORTABLE SSH_FIPS
+
