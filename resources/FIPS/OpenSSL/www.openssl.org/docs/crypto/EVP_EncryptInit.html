<html>
<head>
<!--
     Copyright (c) 1998-2014 The OpenSSL Project, http://www.openssl.org/
     Author:   OpenSSL (openssl@openssl.org)
     Modified: 2014-08-29 01:00:23.
     Generated from ``EVP_EncryptInit.wml'' via WML 2.0.11 (19-Aug-2006).
               by OpenSSL (openssl@openssl.org)
               on 2014-08-29 01:00:38.

     DO NOT EDIT THIS FILE DIRECTLY! INSTEAD EDIT ``EVP_EncryptInit.wml''.
-->
<meta name="Copyright" content="1998-2014 The OpenSSL Project, http://www.openssl.org/">
<meta name="Author"    content="OpenSSL, openssl@openssl.org">
<meta name="Generator" content="WML 2.0.11 (19-Aug-2006)">
<meta name="Modified"  content="2014-08-29 01:00:23">
<title>OpenSSL: Documents, EVP_EncryptInit(3)</title>
<style type="text/css"><!--
BODY { position: absolute; left: 0px; top: 0px; background: #666699; }
A { text-decoration: none; font-weight: bold; }
A:link { text-decoration: none; font-weight: bold; color: #666699; }
A:visited { text-decoration: none; font-weight: bold; color: #666699; }
A:hover { text-decoration: none; font-weight: bold; color: #666699; text-decoration: underline; }
#red { color: #cc3333; }
#sf { font-family: arial,helvetica; font-variant: normal; font-style: normal; }
#sfl { font-weight: bold; font-family: arial,helvetica; font-size: 16pt; line-height: 16pt; font-variant: normal; font-style: normal; }
H1 { font-weight: bold; font-size: 18pt; line-height: 18pt; font-family: arial,helvetica; font-variant: normal; font-style: normal; }
H2 { font-weight: bold; font-size: 14pt; line-height: 14pt; font-family: arial,helvetica; font-variant: normal; font-style: normal; }
H3 { font-weight: bold; font-size: 12pt; line-height: 12pt; font-family: arial,helvetica; font-variant: normal; font-style: normal; }
--></style>
</head>
<body link="#6666cc" alink="#6666cc" vlink="#6666cc" bgcolor="#666699" text="#000000"
      marginheight="0" leftmargin="0" rightmargin="0" topmargin="0">
<table width="100%" cellspacing="0" cellpadding="0" border="0" summary="">
  <tr><td align="left" width="100" bgcolor="#666699"><img src="../../images/page-head-tl.jpg" alt="OpenSSL" width="100" height="80"></td><td align="left" colspan="2" width="600" bgcolor="#666699"><img src="../../images/page-head-tm.jpg" alt="" width="600" height="80"></td><td align="right" width="20" bgcolor="#666699">&nbsp;&nbsp;&nbsp;</td><td align="right" width="50" bgcolor="#666699">&nbsp;</td></tr>
  <tr><td align="left" width="100"><img src="../../images/page-head-bl.jpg" alt="" width="100" height="20"></td><td align="left" width="20"><img src="../../images/page-head-bm.jpg" alt="" width="20" height="20"></td><td align="left" width="100%" bgcolor="#ffffff">
<table cellspacing="0" cellpadding="0" border="0" summary="">
        <tr>
<td><font face="Arial,Helvetica">&nbsp;<a href="../index.html" onmouseover="self.status = '../'; return true" onmouseout="self.status = ''; return true" onfocus="self.status = '../'; return true" onblur="self.status = ''; return true"><font color="#666666">Documents</font></a></font>&nbsp;</td><td>|</td>
<td><font face="Arial,Helvetica">&nbsp;<a href="../apps/openssl.html" onmouseover="self.status = '../apps/openssl.html'; return true" onmouseout="self.status = ''; return true" onfocus="self.status = '../apps/openssl.html'; return true" onblur="self.status = ''; return true"><font color="#666666">openssl(1)</font></a></font>&nbsp;</td><td>|</td>
<td><font face="Arial,Helvetica">&nbsp;<a href="../ssl/ssl.html" onmouseover="self.status = '../ssl/ssl.html'; return true" onmouseout="self.status = ''; return true" onfocus="self.status = '../ssl/ssl.html'; return true" onblur="self.status = ''; return true"><font color="#666666">ssl(3)</font></a></font>&nbsp;</td><td>|</td>
<td><font face="Arial,Helvetica">&nbsp;<a href="crypto.html" onmouseover="self.status = '../crypto/crypto.html'; return true" onmouseout="self.status = ''; return true" onfocus="self.status = '../crypto/crypto.html'; return true" onblur="self.status = ''; return true"><font color="#666666">crypto(3)</font></a></font>&nbsp;</td><td>|</td>
<td><font face="Arial,Helvetica">&nbsp;<a href="../HOWTO/index.html" onmouseover="self.status = '../HOWTO/'; return true" onmouseout="self.status = ''; return true" onfocus="self.status = '../HOWTO/'; return true" onblur="self.status = ''; return true"><font color="#666666">HOWTO</font></a></font>&nbsp;</td><td>|</td>
<td><font face="Arial,Helvetica">&nbsp;<a href="http://wiki.openssl.org/" onmouseover="self.status = 'http://wiki.openssl.org/'; return true" onmouseout="self.status = ''; return true" onfocus="self.status = 'http://wiki.openssl.org/'; return true" onblur="self.status = ''; return true"><font color="#666666">Wiki</font></a></font>&nbsp;</td><td>|</td>
<td><font face="Arial,Helvetica">&nbsp;<a href="../fips/index.html" onmouseover="self.status = '../fips/'; return true" onmouseout="self.status = ''; return true" onfocus="self.status = '../fips/'; return true" onblur="self.status = ''; return true"><font color="#666666">FIPS140</font></a></font>&nbsp;</td><td>|</td>
<td><font face="Arial,Helvetica">&nbsp;<a href="../misc/index.html" onmouseover="self.status = '../misc/'; return true" onmouseout="self.status = ''; return true" onfocus="self.status = '../misc/'; return true" onblur="self.status = ''; return true"><font color="#666666">misc</font></a></font>&nbsp;</td><td></td>
</tr>
      </table>
</td><td align="right" width="20"><img src="../../images/page-corner-tr.gif" alt="" width="20" height="20"></td><td align="right" width="50" bgcolor="#666699">&nbsp;</td></tr>
  <tr><td align="left" valign="top" width="100" bgcolor="#666699"><table cellspacing="0" cellpadding="0" border="0" summary=""><tr><td><img src="../../images/page-navbar-top.jpg" alt="" width="100" height="11"></td></tr>
<script type="text/javascript" language="JavaScript">
<!-- Hiding the code
function nb_imgNormal(imgName) {
    if (document.images) {
        document[imgName].src = eval(imgName + '_n.src');
        self.status = '';
    }
}
function nb_imgSelect(imgName) {
    if (document.images) {
        document[imgName].src = eval(imgName + '_s.src');
        self.status = '';
    }
}
function nb_imgOver(imgName, nohints, descript) {
    if (document.images) {
        document[imgName].src = eval(imgName + '_o.src');
        if (! nohints) self.status = descript;
    }
}
// done hiding -->
</script>
<script type="text/javascript" language="JavaScript">
<!-- Hiding the code
if (document.images) {
    nb_img1_title_n = new Image();
    nb_img1_title_n.src = '../../images/page-navbar-ti-n.jpg';
    nb_img1_title_o = new Image();
    nb_img1_title_o.src = '../../images/page-navbar-ti-s.jpg';
    nb_img1_FAQ_n = new Image();
    nb_img1_FAQ_n.src = '../../images/page-navbar-fq-n.jpg';
    nb_img1_FAQ_o = new Image();
    nb_img1_FAQ_o.src = '../../images/page-navbar-fq-s.jpg';
    nb_img1_about_n = new Image();
    nb_img1_about_n.src = '../../images/page-navbar-ab-n.jpg';
    nb_img1_about_o = new Image();
    nb_img1_about_o.src = '../../images/page-navbar-ab-s.jpg';
    nb_img1_news_n = new Image();
    nb_img1_news_n.src = '../../images/page-navbar-ne-n.jpg';
    nb_img1_news_o = new Image();
    nb_img1_news_o.src = '../../images/page-navbar-ne-s.jpg';
    nb_img1_docs_s = new Image();
    nb_img1_docs_s.src = '../../images/page-navbar-do-s.jpg';
    nb_img1_docs_o = new Image();
    nb_img1_docs_o.src = '../../images/page-navbar-do-s.jpg';
    nb_img1_source_n = new Image();
    nb_img1_source_n.src = '../../images/page-navbar-so-n.jpg';
    nb_img1_source_o = new Image();
    nb_img1_source_o.src = '../../images/page-navbar-so-s.jpg';
    nb_img1_contrib_n = new Image();
    nb_img1_contrib_n.src = '../../images/page-navbar-co-n.jpg';
    nb_img1_contrib_o = new Image();
    nb_img1_contrib_o.src = '../../images/page-navbar-co-s.jpg';
    nb_img1_support_n = new Image();
    nb_img1_support_n.src = '../../images/page-navbar-su-n.jpg';
    nb_img1_support_o = new Image();
    nb_img1_support_o.src = '../../images/page-navbar-su-s.jpg';
    nb_img1_related_n = new Image();
    nb_img1_related_n.src = '../../images/page-navbar-re-n.jpg';
    nb_img1_related_o = new Image();
    nb_img1_related_o.src = '../../images/page-navbar-re-s.jpg';
}
// done hiding -->
</script>
<tr><td><a href="../../index.html" onmouseover="nb_imgOver('nb_img1_title', 0, 'Title'); return true" onmouseout="nb_imgNormal('nb_img1_title'); return true" onfocus="nb_imgOver('nb_img1_title', 0, 'Title'); return true" onblur="nb_imgNormal('nb_img1_title'); return true"><img name="nb_img1_title" src="../../images/page-navbar-ti-n.jpg" alt="Title" border="0" width="100" height="27"></a></td></tr>
<tr><td><a href="../../support/faq.html" onmouseover="nb_imgOver('nb_img1_FAQ', 0, 'FAQ'); return true" onmouseout="nb_imgNormal('nb_img1_FAQ'); return true" onfocus="nb_imgOver('nb_img1_FAQ', 0, 'FAQ'); return true" onblur="nb_imgNormal('nb_img1_FAQ'); return true"><img name="nb_img1_FAQ" src="../../images/page-navbar-fq-n.jpg" alt="FAQ" border="0" width="100" height="27"></a></td></tr>
<tr><td><a href="../../about/index.html" onmouseover="nb_imgOver('nb_img1_about', 0, 'About'); return true" onmouseout="nb_imgNormal('nb_img1_about'); return true" onfocus="nb_imgOver('nb_img1_about', 0, 'About'); return true" onblur="nb_imgNormal('nb_img1_about'); return true"><img name="nb_img1_about" src="../../images/page-navbar-ab-n.jpg" alt="About" border="0" width="100" height="27"></a></td></tr>
<tr><td><a href="../../news/index.html" onmouseover="nb_imgOver('nb_img1_news', 0, 'News'); return true" onmouseout="nb_imgNormal('nb_img1_news'); return true" onfocus="nb_imgOver('nb_img1_news', 0, 'News'); return true" onblur="nb_imgNormal('nb_img1_news'); return true"><img name="nb_img1_news" src="../../images/page-navbar-ne-n.jpg" alt="News" border="0" width="100" height="27"></a></td></tr>
<tr><td><a href="../index.html" onmouseover="nb_imgOver('nb_img1_docs', 0, 'Documents'); return true" onmouseout="nb_imgSelect('nb_img1_docs'); return true" onfocus="nb_imgOver('nb_img1_docs', 0, 'Documents'); return true" onblur="nb_imgSelect('nb_img1_docs'); return true"><img name="nb_img1_docs" src="../../images/page-navbar-do-s.jpg" alt="Documents" border="0" width="100" height="27"></a></td></tr>
<tr><td><a href="../../source/index.html" onmouseover="nb_imgOver('nb_img1_source', 0, 'Source'); return true" onmouseout="nb_imgNormal('nb_img1_source'); return true" onfocus="nb_imgOver('nb_img1_source', 0, 'Source'); return true" onblur="nb_imgNormal('nb_img1_source'); return true"><img name="nb_img1_source" src="../../images/page-navbar-so-n.jpg" alt="Source" border="0" width="100" height="27"></a></td></tr>
<tr><td><a href="../../contrib/index.html" onmouseover="nb_imgOver('nb_img1_contrib', 0, 'Contribution'); return true" onmouseout="nb_imgNormal('nb_img1_contrib'); return true" onfocus="nb_imgOver('nb_img1_contrib', 0, 'Contribution'); return true" onblur="nb_imgNormal('nb_img1_contrib'); return true"><img name="nb_img1_contrib" src="../../images/page-navbar-co-n.jpg" alt="Contribution" border="0" width="100" height="27"></a></td></tr>
<tr><td><a href="../../support/index.html" onmouseover="nb_imgOver('nb_img1_support', 0, 'Support'); return true" onmouseout="nb_imgNormal('nb_img1_support'); return true" onfocus="nb_imgOver('nb_img1_support', 0, 'Support'); return true" onblur="nb_imgNormal('nb_img1_support'); return true"><img name="nb_img1_support" src="../../images/page-navbar-su-n.jpg" alt="Support" border="0" width="100" height="27"></a></td></tr>
<tr><td><a href="../../related/index.html" onmouseover="nb_imgOver('nb_img1_related', 0, 'Related'); return true" onmouseout="nb_imgNormal('nb_img1_related'); return true" onfocus="nb_imgOver('nb_img1_related', 0, 'Related'); return true" onblur="nb_imgNormal('nb_img1_related'); return true"><img name="nb_img1_related" src="../../images/page-navbar-re-n.jpg" alt="Related" border="0" width="100" height="27"></a></td></tr>
    <tr><td><img src="../../images/page-navbar-bot.jpg" alt="" width="100" height="150"><br><p></td></tr>
  </table>
</td><td align="left" valign="top" width="20" bgcolor="#ffffff">&nbsp;</td><td align="left" valign="top" bgcolor="#ffffff"><br>
        
<h1>EVP_EncryptInit(3)</h1>
<!-- INDEX BEGIN -->
<UL>
	<LI><A HREF="EVP_EncryptInit.html#NAME">NAME</A>
	<LI><A HREF="EVP_EncryptInit.html#SYNOPSIS">SYNOPSIS</A>
	<LI><A HREF="EVP_EncryptInit.html#DESCRIPTION">DESCRIPTION</A>
	<LI><A HREF="EVP_EncryptInit.html#RETURN_VALUES">RETURN VALUES</A>
	<LI><A HREF="EVP_EncryptInit.html#CIPHER_LISTING">CIPHER LISTING</A>
	<LI><A HREF="EVP_EncryptInit.html#GCM_Mode">GCM Mode</A>
	<LI><A HREF="EVP_EncryptInit.html#CCM_Mode">CCM Mode</A>
	<LI><A HREF="EVP_EncryptInit.html#NOTES">NOTES</A>
	<LI><A HREF="EVP_EncryptInit.html#BUGS">BUGS</A>
	<LI><A HREF="EVP_EncryptInit.html#EXAMPLES">EXAMPLES</A>
	<LI><A HREF="EVP_EncryptInit.html#SEE_ALSO">SEE ALSO</A>
	<LI><A HREF="EVP_EncryptInit.html#HISTORY">HISTORY</A>
</UL>
<!-- INDEX END -->
<HR>
<P>
<HR>
<H1><A NAME="NAME">NAME</A></H1>
<P>
EVP_CIPHER_CTX_init, EVP_EncryptInit_ex, EVP_EncryptUpdate,
EVP_EncryptFinal_ex, EVP_DecryptInit_ex, EVP_DecryptUpdate,
EVP_DecryptFinal_ex, EVP_CipherInit_ex, EVP_CipherUpdate,
EVP_CipherFinal_ex, EVP_CIPHER_CTX_set_key_length, EVP_CIPHER_CTX_ctrl,
EVP_CIPHER_CTX_cleanup, EVP_EncryptInit, EVP_EncryptFinal, EVP_DecryptInit,
EVP_DecryptFinal, EVP_CipherInit, EVP_CipherFinal, EVP_get_cipherbyname,
EVP_get_cipherbynid, EVP_get_cipherbyobj, EVP_CIPHER_nid,
EVP_CIPHER_block_size, EVP_CIPHER_key_length, EVP_CIPHER_iv_length,
EVP_CIPHER_flags, EVP_CIPHER_mode, EVP_CIPHER_type, EVP_CIPHER_CTX_cipher,
EVP_CIPHER_CTX_nid, EVP_CIPHER_CTX_block_size, EVP_CIPHER_CTX_key_length,
EVP_CIPHER_CTX_iv_length, EVP_CIPHER_CTX_get_app_data,
EVP_CIPHER_CTX_set_app_data, EVP_CIPHER_CTX_type, EVP_CIPHER_CTX_flags,
EVP_CIPHER_CTX_mode, EVP_CIPHER_param_to_asn1, EVP_CIPHER_asn1_to_param,
EVP_CIPHER_CTX_set_padding, EVP_enc_null, EVP_des_cbc, EVP_des_ecb,
EVP_des_cfb, EVP_des_ofb, EVP_des_ede_cbc, EVP_des_ede, EVP_des_ede_ofb,
EVP_des_ede_cfb, EVP_des_ede3_cbc, EVP_des_ede3, EVP_des_ede3_ofb,
EVP_des_ede3_cfb, EVP_desx_cbc, EVP_rc4, EVP_rc4_40, EVP_idea_cbc,
EVP_idea_ecb, EVP_idea_cfb, EVP_idea_ofb, EVP_idea_cbc, EVP_rc2_cbc,
EVP_rc2_ecb, EVP_rc2_cfb, EVP_rc2_ofb, EVP_rc2_40_cbc, EVP_rc2_64_cbc,
EVP_bf_cbc, EVP_bf_ecb, EVP_bf_cfb, EVP_bf_ofb, EVP_cast5_cbc,
EVP_cast5_ecb, EVP_cast5_cfb, EVP_cast5_ofb, EVP_rc5_32_12_16_cbc,
EVP_rc5_32_12_16_ecb, EVP_rc5_32_12_16_cfb, EVP_rc5_32_12_16_ofb,
EVP_aes_128_cbc, EVP_aes_128_ecb, EVP_aes_128_cfb, EVP_aes_128_ofb,
EVP_aes_192_cbc, EVP_aes_192_ecb, EVP_aes_192_cfb, EVP_aes_192_ofb,
EVP_aes_256_cbc, EVP_aes_256_ecb, EVP_aes_256_cfb, EVP_aes_256_ofb,
EVP_aes_128_gcm, EVP_aes_192_gcm, EVP_aes_256_gcm, EVP_aes_128_ccm,
EVP_aes_192_ccm, EVP_aes_256_ccm - EVP cipher routines
</P>
<P>
<HR>
<H1><A NAME="SYNOPSIS">SYNOPSIS</A></H1>
<PRE> #include &lt;openssl/evp.h&gt;
</PRE>
<PRE> void EVP_CIPHER_CTX_init(EVP_CIPHER_CTX *a);
</PRE>
<PRE> int EVP_EncryptInit_ex(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type,
         ENGINE *impl, unsigned char *key, unsigned char *iv);
 int EVP_EncryptUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out,
         int *outl, unsigned char *in, int inl);
 int EVP_EncryptFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char *out,
         int *outl);
</PRE>
<PRE> int EVP_DecryptInit_ex(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type,
         ENGINE *impl, unsigned char *key, unsigned char *iv);
 int EVP_DecryptUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out,
         int *outl, unsigned char *in, int inl);
 int EVP_DecryptFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char *outm,
         int *outl);
</PRE>
<PRE> int EVP_CipherInit_ex(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type,
         ENGINE *impl, unsigned char *key, unsigned char *iv, int enc);
 int EVP_CipherUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out,
         int *outl, unsigned char *in, int inl);
 int EVP_CipherFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char *outm,
         int *outl);
</PRE>
<PRE> int EVP_EncryptInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type,
         unsigned char *key, unsigned char *iv);
 int EVP_EncryptFinal(EVP_CIPHER_CTX *ctx, unsigned char *out,
         int *outl);
</PRE>
<PRE> int EVP_DecryptInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type,
         unsigned char *key, unsigned char *iv);
 int EVP_DecryptFinal(EVP_CIPHER_CTX *ctx, unsigned char *outm,
         int *outl);
</PRE>
<PRE> int EVP_CipherInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type,
         unsigned char *key, unsigned char *iv, int enc);
 int EVP_CipherFinal(EVP_CIPHER_CTX *ctx, unsigned char *outm,
         int *outl);
</PRE>
<PRE> int EVP_CIPHER_CTX_set_padding(EVP_CIPHER_CTX *x, int padding);
 int EVP_CIPHER_CTX_set_key_length(EVP_CIPHER_CTX *x, int keylen);
 int EVP_CIPHER_CTX_ctrl(EVP_CIPHER_CTX *ctx, int type, int arg, void *ptr);
 int EVP_CIPHER_CTX_cleanup(EVP_CIPHER_CTX *a);
</PRE>
<PRE> const EVP_CIPHER *EVP_get_cipherbyname(const char *name);
 #define EVP_get_cipherbynid(a) EVP_get_cipherbyname(OBJ_nid2sn(a))
 #define EVP_get_cipherbyobj(a) EVP_get_cipherbynid(OBJ_obj2nid(a))
</PRE>
<PRE> #define EVP_CIPHER_nid(e)              ((e)-&gt;nid)
 #define EVP_CIPHER_block_size(e)       ((e)-&gt;block_size)
 #define EVP_CIPHER_key_length(e)       ((e)-&gt;key_len)
 #define EVP_CIPHER_iv_length(e)                ((e)-&gt;iv_len)
 #define EVP_CIPHER_flags(e)            ((e)-&gt;flags)
 #define EVP_CIPHER_mode(e)             ((e)-&gt;flags) &amp; EVP_CIPH_MODE)
 int EVP_CIPHER_type(const EVP_CIPHER *ctx);
</PRE>
<PRE> #define EVP_CIPHER_CTX_cipher(e)       ((e)-&gt;cipher)
 #define EVP_CIPHER_CTX_nid(e)          ((e)-&gt;cipher-&gt;nid)
 #define EVP_CIPHER_CTX_block_size(e)   ((e)-&gt;cipher-&gt;block_size)
 #define EVP_CIPHER_CTX_key_length(e)   ((e)-&gt;key_len)
 #define EVP_CIPHER_CTX_iv_length(e)    ((e)-&gt;cipher-&gt;iv_len)
 #define EVP_CIPHER_CTX_get_app_data(e) ((e)-&gt;app_data)
 #define EVP_CIPHER_CTX_set_app_data(e,d) ((e)-&gt;app_data=(char *)(d))
 #define EVP_CIPHER_CTX_type(c)         EVP_CIPHER_type(EVP_CIPHER_CTX_cipher(c))
 #define EVP_CIPHER_CTX_flags(e)                ((e)-&gt;cipher-&gt;flags)
 #define EVP_CIPHER_CTX_mode(e)         ((e)-&gt;cipher-&gt;flags &amp; EVP_CIPH_MODE)
</PRE>
<PRE> int EVP_CIPHER_param_to_asn1(EVP_CIPHER_CTX *c, ASN1_TYPE *type);
 int EVP_CIPHER_asn1_to_param(EVP_CIPHER_CTX *c, ASN1_TYPE *type);
</PRE>
<P>
<HR>
<H1><A NAME="DESCRIPTION">DESCRIPTION</A></H1>
<P>
The EVP cipher routines are a high level interface to certain symmetric
ciphers.
</P>
<P>
<CODE>EVP_CIPHER_CTX_init()</CODE> initializes cipher contex <STRONG>ctx</STRONG>.
</P>
<P>
<CODE>EVP_EncryptInit_ex()</CODE> sets up cipher context <STRONG>ctx</STRONG> for encryption with cipher <STRONG>type</STRONG> from ENGINE <STRONG>impl</STRONG>. <STRONG>ctx</STRONG> must be initialized before calling this function. <STRONG>type</STRONG> is normally supplied by a function such as <CODE>EVP_des_cbc().</CODE> If <STRONG>impl</STRONG> is NULL then the default implementation is used. <STRONG>key</STRONG> is the symmetric key to use and <STRONG>iv</STRONG> is the IV to use (if necessary), the actual number of bytes used for the
key and IV depends on the cipher. It is possible to set all parameters to
NULL except <STRONG>type</STRONG> in an initial call and supply the remaining parameters in subsequent calls,
all of which have <STRONG>type</STRONG>
set to NULL. This is done when the default cipher parameters are not
appropriate.
</P>
<P>
<CODE>EVP_EncryptUpdate()</CODE> encrypts <STRONG>inl</STRONG> bytes from the buffer <STRONG>in</STRONG> and writes the encrypted version to <STRONG>out</STRONG>. This function can be called multiple times to encrypt successive blocks
of data. The amount of data written depends on the block alignment of the
encrypted data: as a result the amount of data written may be anything from
zero bytes to (inl + cipher_block_size - 1) so <STRONG>outl</STRONG> should contain sufficient room. The actual number of bytes written is
placed in <STRONG>outl</STRONG>.
</P>
<P>
If padding is enabled (the default) then <CODE>EVP_EncryptFinal_ex()</CODE>
encrypts the ``final'' data, that is any data that remains in a partial
block. It uses <A HREF="EVP_EncryptInit.html#NOTES">standard block padding</A> (aka PKCS padding). The encrypted final data is written to <STRONG>out</STRONG> which should have sufficient space for one cipher block. The number of
bytes written is placed in <STRONG>outl</STRONG>. After this function is called the encryption operation is finished and no
further calls to <CODE>EVP_EncryptUpdate()</CODE> should be made.
</P>
<P>
If padding is disabled then <CODE>EVP_EncryptFinal_ex()</CODE> will not
encrypt any more data and it will return an error if any data remains in a
partial block: that is if the total data length is not a multiple of the
block size.
</P>
<P>
<CODE>EVP_DecryptInit_ex(),</CODE> <CODE>EVP_DecryptUpdate()</CODE> and
<CODE>EVP_DecryptFinal_ex()</CODE> are the corresponding decryption
operations. <CODE>EVP_DecryptFinal()</CODE> will return an error code if
padding is enabled and the final block is not correctly formatted. The
parameters and restrictions are identical to the encryption operations
except that if padding is enabled the decrypted data buffer <STRONG>out</STRONG>
passed to <CODE>EVP_DecryptUpdate()</CODE> should have sufficient room for
(<STRONG>inl</STRONG> + cipher_block_size) bytes unless the cipher block size is 1 in which case <STRONG>inl</STRONG> bytes is sufficient.
</P>
<P>
<CODE>EVP_CipherInit_ex(),</CODE> <CODE>EVP_CipherUpdate()</CODE> and
<CODE>EVP_CipherFinal_ex()</CODE> are functions that can be used for
decryption or encryption. The operation performed depends on the value of
the <STRONG>enc</STRONG> parameter. It should be set to 1 for encryption, 0 for decryption and -1 to
leave the value unchanged (the actual value of 'enc' being supplied in a
previous call).
</P>
<P>
<CODE>EVP_CIPHER_CTX_cleanup()</CODE> clears all information from a cipher
context and free up any allocated memory associate with it. It should be
called after all operations using a cipher are complete so sensitive
information does not remain in memory.
</P>
<P>
<CODE>EVP_EncryptInit(),</CODE> <CODE>EVP_DecryptInit()</CODE> and
<CODE>EVP_CipherInit()</CODE> behave in a similar way to
<CODE>EVP_EncryptInit_ex(),</CODE> <CODE>EVP_DecryptInit_ex()</CODE> and
<CODE>EVP_CipherInit_ex()</CODE> except the <STRONG>ctx</STRONG> parameter does not need to be initialized and they always use the default
cipher implementation.
</P>
<P>
<CODE>EVP_EncryptFinal(),</CODE> <CODE>EVP_DecryptFinal()</CODE> and
<CODE>EVP_CipherFinal()</CODE> are identical to
<CODE>EVP_EncryptFinal_ex(),</CODE> <CODE>EVP_DecryptFinal_ex()</CODE> and
<CODE>EVP_CipherFinal_ex().</CODE> In previous releases they also cleaned
up the <STRONG>ctx</STRONG>, but this is no longer done and <CODE>EVP_CIPHER_CTX_clean()</CODE> must
be called to free any context resources.
</P>
<P>
<CODE>EVP_get_cipherbyname(),</CODE> <CODE>EVP_get_cipherbynid()</CODE> and
<CODE>EVP_get_cipherbyobj()</CODE> return an EVP_CIPHER structure when
passed a cipher name, a NID or an ASN1_OBJECT structure.
</P>
<P>
<CODE>EVP_CIPHER_nid()</CODE> and <CODE>EVP_CIPHER_CTX_nid()</CODE> return
the NID of a cipher when passed an <STRONG>EVP_CIPHER</STRONG> or <STRONG>EVP_CIPHER_CTX</STRONG> structure. The actual NID value is an internal value which may not have a
corresponding OBJECT IDENTIFIER.
</P>
<P>
<CODE>EVP_CIPHER_CTX_set_padding()</CODE> enables or disables padding. By
default encryption operations are padded using standard block padding and
the padding is checked and removed when decrypting. If the <STRONG>pad</STRONG> parameter is zero then no padding is performed, the total amount of data
encrypted or decrypted must then be a multiple of the block size or an
error will occur.
</P>
<P>
<CODE>EVP_CIPHER_key_length()</CODE> and
<CODE>EVP_CIPHER_CTX_key_length()</CODE> return the key length of a cipher
when passed an <STRONG>EVP_CIPHER</STRONG> or <STRONG>EVP_CIPHER_CTX</STRONG>
structure. The constant <STRONG>EVP_MAX_KEY_LENGTH</STRONG> is the maximum key length for all ciphers. Note: although
<CODE>EVP_CIPHER_key_length()</CODE> is fixed for a given cipher, the value
of <CODE>EVP_CIPHER_CTX_key_length()</CODE> may be different for variable
key length ciphers.
</P>
<P>
<CODE>EVP_CIPHER_CTX_set_key_length()</CODE> sets the key length of the
cipher ctx. If the cipher is a fixed length cipher then attempting to set
the key length to any value other than the fixed value is an error.
</P>
<P>
<CODE>EVP_CIPHER_iv_length()</CODE> and
<CODE>EVP_CIPHER_CTX_iv_length()</CODE> return the IV length of a cipher
when passed an <STRONG>EVP_CIPHER</STRONG> or <STRONG>EVP_CIPHER_CTX</STRONG>. It will return zero if the cipher does not use an IV. The constant
<STRONG>EVP_MAX_IV_LENGTH</STRONG> is the maximum IV length for all ciphers.
</P>
<P>
<CODE>EVP_CIPHER_block_size()</CODE> and
<CODE>EVP_CIPHER_CTX_block_size()</CODE> return the block size of a cipher
when passed an <STRONG>EVP_CIPHER</STRONG> or <STRONG>EVP_CIPHER_CTX</STRONG>
structure. The constant <STRONG>EVP_MAX_IV_LENGTH</STRONG> is also the maximum block length for all ciphers.
</P>
<P>
<CODE>EVP_CIPHER_type()</CODE> and <CODE>EVP_CIPHER_CTX_type()</CODE>
return the type of the passed cipher or context. This ``type'' is the
actual NID of the cipher OBJECT IDENTIFIER as such it ignores the cipher
parameters and 40 bit RC2 and 128 bit RC2 have the same NID. If the cipher
does not have an object identifier or does not have ASN1 support this
function will return
<STRONG>NID_undef</STRONG>.
</P>
<P>
<CODE>EVP_CIPHER_CTX_cipher()</CODE> returns the <STRONG>EVP_CIPHER</STRONG> structure when passed an <STRONG>EVP_CIPHER_CTX</STRONG> structure.
</P>
<P>
<CODE>EVP_CIPHER_mode()</CODE> and <CODE>EVP_CIPHER_CTX_mode()</CODE>
return the block cipher mode: EVP_CIPH_ECB_MODE, EVP_CIPH_CBC_MODE,
EVP_CIPH_CFB_MODE or EVP_CIPH_OFB_MODE. If the cipher is a stream cipher
then EVP_CIPH_STREAM_CIPHER is returned.
</P>
<P>
<CODE>EVP_CIPHER_param_to_asn1()</CODE> sets the AlgorithmIdentifier
``parameter'' based on the passed cipher. This will typically include any
parameters and an IV. The cipher IV (if any) must be set when this call is
made. This call should be made before the cipher is actually ``used''
(before any <CODE>EVP_EncryptUpdate(),</CODE>
<CODE>EVP_DecryptUpdate()</CODE> calls for example). This function may fail
if the cipher does not have any ASN1 support.
</P>
<P>
<CODE>EVP_CIPHER_asn1_to_param()</CODE> sets the cipher parameters based on
an ASN1 AlgorithmIdentifier ``parameter''. The precise effect depends on
the cipher In the case of RC2, for example, it will set the IV and
effective key length. This function should be called after the base cipher
type is set but before the key is set. For example
<CODE>EVP_CipherInit()</CODE> will be called with the IV and key set to
NULL, <CODE>EVP_CIPHER_asn1_to_param()</CODE> will be called and finally
<CODE>EVP_CipherInit()</CODE> again with all parameters except the key set
to NULL. It is possible for this function to fail if the cipher does not
have any ASN1 support or the parameters cannot be set (for example the RC2
effective key length is not supported.
</P>
<P>
<CODE>EVP_CIPHER_CTX_ctrl()</CODE> allows various cipher specific
parameters to be determined and set.
</P>
<P>
<HR>
<H1><A NAME="RETURN_VALUES">RETURN VALUES</A></H1>
<P>
<CODE>EVP_EncryptInit_ex(),</CODE> <CODE>EVP_EncryptUpdate()</CODE> and
<CODE>EVP_EncryptFinal_ex()</CODE> return 1 for success and 0 for failure.
</P>
<P>
<CODE>EVP_DecryptInit_ex()</CODE> and <CODE>EVP_DecryptUpdate()</CODE>
return 1 for success and 0 for failure. <CODE>EVP_DecryptFinal_ex()</CODE>
returns 0 if the decrypt failed or 1 for success.
</P>
<P>
<CODE>EVP_CipherInit_ex()</CODE> and <CODE>EVP_CipherUpdate()</CODE> return
1 for success and 0 for failure. <CODE>EVP_CipherFinal_ex()</CODE> returns
0 for a decryption failure or 1 for success.
</P>
<P>
<CODE>EVP_CIPHER_CTX_cleanup()</CODE> returns 1 for success and 0 for
failure.
</P>
<P>
<CODE>EVP_get_cipherbyname(),</CODE> <CODE>EVP_get_cipherbynid()</CODE> and
<CODE>EVP_get_cipherbyobj()</CODE> return an <STRONG>EVP_CIPHER</STRONG> structure or NULL on error.
</P>
<P>
<CODE>EVP_CIPHER_nid()</CODE> and <CODE>EVP_CIPHER_CTX_nid()</CODE> return
a NID.
</P>
<P>
<CODE>EVP_CIPHER_block_size()</CODE> and
<CODE>EVP_CIPHER_CTX_block_size()</CODE> return the block size.
</P>
<P>
<CODE>EVP_CIPHER_key_length()</CODE> and
<CODE>EVP_CIPHER_CTX_key_length()</CODE> return the key length.
</P>
<P>
<CODE>EVP_CIPHER_CTX_set_padding()</CODE> always returns 1.
</P>
<P>
<CODE>EVP_CIPHER_iv_length()</CODE> and
<CODE>EVP_CIPHER_CTX_iv_length()</CODE> return the IV length or zero if the
cipher does not use an IV.
</P>
<P>
<CODE>EVP_CIPHER_type()</CODE> and <CODE>EVP_CIPHER_CTX_type()</CODE>
return the NID of the cipher's OBJECT IDENTIFIER or NID_undef if it has no
defined OBJECT IDENTIFIER.
</P>
<P>
<CODE>EVP_CIPHER_CTX_cipher()</CODE> returns an <STRONG>EVP_CIPHER</STRONG> structure.
</P>
<P>
<CODE>EVP_CIPHER_param_to_asn1()</CODE> and
<CODE>EVP_CIPHER_asn1_to_param()</CODE> return 1 for success or zero for
failure.
</P>
<P>
<HR>
<H1><A NAME="CIPHER_LISTING">CIPHER LISTING</A></H1>
<P>
All algorithms have a fixed key length unless otherwise stated.
</P>
<DL>
<DT><STRONG><A NAME="item_EVP_enc_null">EVP_enc_null()</A></STRONG><DD>
<P>
Null cipher: does nothing.
</P>
<DT><STRONG><A NAME="item_EVP_aes_128_cbc">EVP_aes_128_cbc(), EVP_aes_128_ecb(), EVP_aes_128_cfb(), EVP_aes_128_ofb()</A></STRONG><DD>
<P>
AES with a 128-bit key in CBC, ECB, CFB and OFB modes respectively.
</P>
<DT><STRONG><A NAME="item_EVP_aes_192_cbc">EVP_aes_192_cbc(), EVP_aes_192_ecb(), EVP_aes_192_cfb(), EVP_aes_192_ofb()</A></STRONG><DD>
<P>
AES with a 192-bit key in CBC, ECB, CFB and OFB modes respectively.
</P>
<DT><STRONG><A NAME="item_EVP_aes_256_cbc">EVP_aes_256_cbc(), EVP_aes_256_ecb(), EVP_aes_256_cfb(), EVP_aes_256_ofb()</A></STRONG><DD>
<P>
AES with a 256-bit key in CBC, ECB, CFB and OFB modes respectively.
</P>
<DT><STRONG><A NAME="item_EVP_des_cbc">EVP_des_cbc(), EVP_des_ecb(), EVP_des_cfb(), EVP_des_ofb()</A></STRONG><DD>
<P>
DES in CBC, ECB, CFB and OFB modes respectively.
</P>
<DT><STRONG><A NAME="item_EVP_des_ede_cbc">EVP_des_ede_cbc(), EVP_des_ede(), EVP_des_ede_ofb(), EVP_des_ede_cfb()</A></STRONG><DD>
<P>
Two key triple DES in CBC, ECB, CFB and OFB modes respectively.
</P>
<DT><STRONG><A NAME="item_EVP_des_ede3_cbc">EVP_des_ede3_cbc(), EVP_des_ede3(), EVP_des_ede3_ofb(), EVP_des_ede3_cfb()</A></STRONG><DD>
<P>
Three key triple DES in CBC, ECB, CFB and OFB modes respectively.
</P>
<DT><STRONG><A NAME="item_EVP_desx_cbc">EVP_desx_cbc()</A></STRONG><DD>
<P>
DESX algorithm in CBC mode.
</P>
<DT><STRONG><A NAME="item_EVP_rc4">EVP_rc4()</A></STRONG><DD>
<P>
RC4 stream cipher. This is a variable key length cipher with default key
length 128 bits.
</P>
<DT><STRONG><A NAME="item_EVP_rc4_40">EVP_rc4_40()</A></STRONG><DD>
<P>
RC4 stream cipher with 40 bit key length. This is obsolete and new code
should use <CODE>EVP_rc4()</CODE> and the
<CODE>EVP_CIPHER_CTX_set_key_length()</CODE> function.
</P>
<DT><STRONG><A NAME="item_EVP_idea_cbc">EVP_idea_cbc() EVP_idea_ecb(), EVP_idea_cfb(), EVP_idea_ofb(), EVP_idea_cbc()</A></STRONG><DD>
<P>
IDEA encryption algorithm in CBC, ECB, CFB and OFB modes respectively.
</P>
<DT><STRONG><A NAME="item_EVP_rc2_cbc">EVP_rc2_cbc(), EVP_rc2_ecb(), EVP_rc2_cfb(), EVP_rc2_ofb()</A></STRONG><DD>
<P>
RC2 encryption algorithm in CBC, ECB, CFB and OFB modes respectively. This
is a variable key length cipher with an additional parameter called
``effective key bits'' or ``effective key length''. By default both are set
to 128 bits.
</P>
<DT><STRONG><A NAME="item_EVP_rc2_40_cbc">EVP_rc2_40_cbc(), EVP_rc2_64_cbc()</A></STRONG><DD>
<P>
RC2 algorithm in CBC mode with a default key length and effective key
length of 40 and 64 bits. These are obsolete and new code should use
<CODE>EVP_rc2_cbc(),</CODE> <CODE>EVP_CIPHER_CTX_set_key_length()</CODE>
and <CODE>EVP_CIPHER_CTX_ctrl()</CODE> to set the key length and effective
key length.
</P>
<DT><STRONG><A NAME="item_EVP_bf_cbc">EVP_bf_cbc(), EVP_bf_ecb(), EVP_bf_cfb(), EVP_bf_ofb()</A></STRONG><DD>
<P>
Blowfish encryption algorithm in CBC, ECB, CFB and OFB modes respectively.
This is a variable key length cipher.
</P>
<DT><STRONG><A NAME="item_EVP_cast5_cbc">EVP_cast5_cbc(), EVP_cast5_ecb(), EVP_cast5_cfb(), EVP_cast5_ofb()</A></STRONG><DD>
<P>
CAST encryption algorithm in CBC, ECB, CFB and OFB modes respectively. This
is a variable key length cipher.
</P>
<DT><STRONG><A NAME="item_EVP_rc5_32_12_16_cbc">EVP_rc5_32_12_16_cbc(), EVP_rc5_32_12_16_ecb(), EVP_rc5_32_12_16_cfb(), EVP_rc5_32_12_16_ofb()</A></STRONG><DD>
<P>
RC5 encryption algorithm in CBC, ECB, CFB and OFB modes respectively. This
is a variable key length cipher with an additional ``number of rounds''
parameter. By default the key length is set to 128 bits and 12 rounds.
</P>
<DT><STRONG><A NAME="item_EVP_aes_128_gcm">EVP_aes_128_gcm(), EVP_aes_192_gcm(), EVP_aes_256_gcm()</A></STRONG><DD>
<P>
AES Galois Counter Mode (GCM) for 128, 192 and 256 bit keys respectively.
These ciphers require additional control operations to function correctly:
see
<A HREF="EVP_EncryptInit.html#GCM_mode">GCM mode</A> section below for details.
</P>
<DT><STRONG><A NAME="item_EVP_aes_128_ccm">EVP_aes_128_ccm(), EVP_aes_192_ccm(), EVP_aes_256_ccm()</A></STRONG><DD>
<P>
AES Counter with CBC-MAC Mode (CCM) for 128, 192 and 256 bit keys
respectively. These ciphers require additional control operations to
function correctly: see CCM mode section below for details.
</P>
</DL>
<P>
<HR>
<H1><A NAME="GCM_Mode">GCM Mode</A></H1>
<P>
For GCM mode ciphers the behaviour of the EVP interface is subtly altered
and several GCM specific ctrl operations are supported.
</P>
<P>
To specify any additional authenticated data (AAD) a call to
<CODE>EVP_CipherUpdate(),</CODE> <CODE>EVP_EncryptUpdate()</CODE> or
<CODE>EVP_DecryptUpdate()</CODE> should be made with the output parameter <STRONG>out</STRONG> set to <STRONG>NULL</STRONG>.
</P>
<P>
When decrypting the return value of <CODE>EVP_DecryptFinal()</CODE> or
<CODE>EVP_CipherFinal()</CODE> indicates if the operation was successful.
If it does not indicate success the authentication operation has failed and
any output data <STRONG>MUST NOT</STRONG>
be used as it is corrupted.
</P>
<P>
The following ctrls are supported in GCM mode:
</P>
<PRE> EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_GCM_SET_IVLEN, ivlen, NULL);
</PRE>
<P>
Sets the GCM IV length: this call can only be made before specifying an IV.
If not called a default IV length is used (96 bits for AES).
</P>
<PRE> EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_GCM_GET_TAG, taglen, tag);
</PRE>
<P>
Writes <STRONG>taglen</STRONG> bytes of the tag value to the buffer indicated by <STRONG>tag</STRONG>. This call can only be made when encrypting data and <STRONG>after</STRONG> all data has been processed (e.g. after an <CODE>EVP_EncryptFinal()</CODE>
call).
</P>
<PRE> EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_GCM_SET_TAG, taglen, tag);
</PRE>
<P>
Sets the expected tag to <STRONG>taglen</STRONG> bytes from <STRONG>tag</STRONG>. This call is only legal when decrypting data and must be made <STRONG>before</STRONG> any data is processed (e.g. before any <CODE>EVP_DecryptUpdate()</CODE>
call).
</P>
<P>
See <A HREF="EVP_EncryptInit.html#EXAMPLES">EXAMPLES</A> below for an example of the use of GCM mode.
</P>
<P>
<HR>
<H1><A NAME="CCM_Mode">CCM Mode</A></H1>
<P>
The behaviour of CCM mode ciphers is similar to CCM mode but with a few
additional requirements and different ctrl values.
</P>
<P>
Like GCM mode any additional authenticated data (AAD) is passed by calling
<CODE>EVP_CipherUpdate(),</CODE> <CODE>EVP_EncryptUpdate()</CODE> or
<CODE>EVP_DecryptUpdate()</CODE> with the output parameter <STRONG>out</STRONG> set to <STRONG>NULL</STRONG>. Additionally the total plaintext or ciphertext length <STRONG>MUST</STRONG> be passed to <CODE>EVP_CipherUpdate(),</CODE>
<CODE>EVP_EncryptUpdate()</CODE> or <CODE>EVP_DecryptUpdate()</CODE> with
the output and input parameters (<STRONG>in</STRONG> and <STRONG>out</STRONG>) set to <STRONG>NULL</STRONG> and the length passed in the <STRONG>inl</STRONG> parameter.
</P>
<P>
The following ctrls are supported in CCM mode:
</P>
<PRE> EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_CCM_SET_TAG, taglen, tag);
</PRE>
<P>
This call is made to set the expected <STRONG>CCM</STRONG> tag value when decrypting or the length of the tag (with the <STRONG>tag</STRONG> parameter set to NULL) when encrypting. The tag length is often referred to
as <STRONG>M</STRONG>. If not set a default value is used (12 for AES).
</P>
<PRE> EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_CCM_SET_L, ivlen, NULL);
</PRE>
<P>
Sets the CCM <STRONG>L</STRONG> value. If not set a default is used (8 for AES).
</P>
<PRE> EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_CCM_SET_IVLEN, ivlen, NULL);
</PRE>
<P>
Sets the CCM nonce (IV) length: this call can only be made before
specifying an nonce value. The nonce length is given by <STRONG>15 - L</STRONG> so it is 7 by default for AES.
</P>
<P>
<HR>
<H1><A NAME="NOTES">NOTES</A></H1>
<P>
Where possible the <STRONG>EVP</STRONG> interface to symmetric ciphers should be used in preference to the low
level interfaces. This is because the code then becomes transparent to the
cipher used and much more flexible. Additionally, the
<STRONG>EVP</STRONG> interface will ensure the use of platform specific cryptographic
acceleration such as AES-NI (the low level interfaces do not provide the
guarantee).
</P>
<P>
PKCS padding works by adding <STRONG>n</STRONG> padding bytes of value <STRONG>n</STRONG> to make the total length of the encrypted data a multiple of the block
size. Padding is always added so if the data is already a multiple of the
block size <STRONG>n</STRONG> will equal the block size. For example if the block size is 8 and 11 bytes
are to be encrypted then 5 padding bytes of value 5 will be added.
</P>
<P>
When decrypting the final block is checked to see if it has the correct
form.
</P>
<P>
Although the decryption operation can produce an error if padding is
enabled, it is not a strong test that the input data or key is correct. A
random block has better than 1 in 256 chance of being of the correct format
and problems with the input data earlier on will not produce a final
decrypt error.
</P>
<P>
If padding is disabled then the decryption operation will always succeed if
the total amount of data decrypted is a multiple of the block size.
</P>
<P>
The functions <CODE>EVP_EncryptInit(),</CODE>
<CODE>EVP_EncryptFinal(),</CODE> <CODE>EVP_DecryptInit(),</CODE>
<CODE>EVP_CipherInit()</CODE> and <CODE>EVP_CipherFinal()</CODE> are
obsolete but are retained for compatibility with existing code. New code
should use <CODE>EVP_EncryptInit_ex(),</CODE>
<CODE>EVP_EncryptFinal_ex(),</CODE> <CODE>EVP_DecryptInit_ex(),</CODE>
<CODE>EVP_DecryptFinal_ex(),</CODE> <CODE>EVP_CipherInit_ex()</CODE> and
<CODE>EVP_CipherFinal_ex()</CODE> because they can reuse an existing
context without allocating and freeing it up on each call.
</P>
<P>
<HR>
<H1><A NAME="BUGS">BUGS</A></H1>
<P>
For RC5 the number of rounds can currently only be set to 8, 12 or 16. This
is a limitation of the current RC5 code rather than the EVP interface.
</P>
<P>
EVP_MAX_KEY_LENGTH and EVP_MAX_IV_LENGTH only refer to the internal ciphers
with default key lengths. If custom ciphers exceed these values the results
are unpredictable. This is because it has become standard practice to
define a generic key as a fixed unsigned char array containing
EVP_MAX_KEY_LENGTH bytes.
</P>
<P>
The ASN1 code is incomplete (and sometimes inaccurate) it has only been
tested for certain common S/MIME ciphers (RC2, DES, triple DES) in CBC
mode.
</P>
<P>
<HR>
<H1><A NAME="EXAMPLES">EXAMPLES</A></H1>
<P>
Encrypt a string using IDEA:
</P>
<PRE> int do_crypt(char *outfile)
        {
        unsigned char outbuf&#91;1024&#93;;
        int outlen, tmplen;
        /* Bogus key and IV: we'd normally set these from
         * another source.
         */
        unsigned char key&#91;&#93; = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};
        unsigned char iv&#91;&#93; = {1,2,3,4,5,6,7,8};
        char intext&#91;&#93; = &quot;Some Crypto Text&quot;;
        EVP_CIPHER_CTX ctx;
        FILE *out;
</PRE>
<PRE>        EVP_CIPHER_CTX_init(&amp;ctx);
        EVP_EncryptInit_ex(&amp;ctx, EVP_idea_cbc(), NULL, key, iv);
</PRE>
<PRE>        if(!EVP_EncryptUpdate(&amp;ctx, outbuf, &amp;outlen, intext, strlen(intext)))
                {
                /* Error */
                return 0;
                }
        /* Buffer passed to EVP_EncryptFinal() must be after data just
         * encrypted to avoid overwriting it.
         */
        if(!EVP_EncryptFinal_ex(&amp;ctx, outbuf + outlen, &amp;tmplen))
                {
                /* Error */
                return 0;
                }
        outlen += tmplen;
        EVP_CIPHER_CTX_cleanup(&amp;ctx);
        /* Need binary mode for fopen because encrypted data is
         * binary data. Also cannot use strlen() on it because
         * it wont be null terminated and may contain embedded
         * nulls.
         */
        out = fopen(outfile, &quot;wb&quot;);
        fwrite(outbuf, 1, outlen, out);
        fclose(out);
        return 1;
        }
</PRE>
<P>
The ciphertext from the above example can be decrypted using the <STRONG>openssl</STRONG>
utility with the command line (shown on two lines for clarity):
</P>
<PRE> openssl idea -d &lt;filename
          -K 000102030405060708090A0B0C0D0E0F -iv 0102030405060708
</PRE>
<P>
General encryption and decryption function example using FILE I/O and
AES128 with a 128-bit key:
</P>
<PRE> int do_crypt(FILE *in, FILE *out, int do_encrypt)
        {
        /* Allow enough space in output buffer for additional block */
        unsigned char inbuf&#91;1024&#93;, outbuf&#91;1024 + EVP_MAX_BLOCK_LENGTH&#93;;
        int inlen, outlen;
        EVP_CIPHER_CTX ctx;
        /* Bogus key and IV: we'd normally set these from
         * another source.
         */
        unsigned char key&#91;&#93; = &quot;0123456789abcdeF&quot;;
        unsigned char iv&#91;&#93; = &quot;1234567887654321&quot;;
</PRE>
<PRE>        /* Don't set key or IV right away; we want to check lengths */
        EVP_CIPHER_CTX_init(&amp;ctx);
        EVP_CipherInit_ex(&amp;ctx, EVP_aes_128_cbc(), NULL, NULL, NULL,
                do_encrypt);
        OPENSSL_assert(EVP_CIPHER_CTX_key_length(&amp;ctx) == 16);
        OPENSSL_assert(EVP_CIPHER_CTX_iv_length(&amp;ctx) == 16);
</PRE>
<PRE>        /* Now we can set key and IV */
        EVP_CipherInit_ex(&amp;ctx, NULL, NULL, key, iv, do_encrypt);
</PRE>
<PRE>        for(;;)
                {
                inlen = fread(inbuf, 1, 1024, in);
                if(inlen &lt;= 0) break;
                if(!EVP_CipherUpdate(&amp;ctx, outbuf, &amp;outlen, inbuf, inlen))
                        {
                        /* Error */
                        EVP_CIPHER_CTX_cleanup(&amp;ctx);
                        return 0;
                        }
                fwrite(outbuf, 1, outlen, out);
                }
        if(!EVP_CipherFinal_ex(&amp;ctx, outbuf, &amp;outlen))
                {
                /* Error */
                EVP_CIPHER_CTX_cleanup(&amp;ctx);
                return 0;
                }
        fwrite(outbuf, 1, outlen, out);
</PRE>
<PRE>        EVP_CIPHER_CTX_cleanup(&amp;ctx);
        return 1;
        }
</PRE>
<P>
<HR>
<H1><A NAME="SEE_ALSO">SEE ALSO</A></H1>
<P>
<A HREF="evp.html#">evp(3)</A>
</P>
<P>
<HR>
<H1><A NAME="HISTORY">HISTORY</A></H1>
<P>
<CODE>EVP_CIPHER_CTX_init(),</CODE> <CODE>EVP_EncryptInit_ex(),</CODE>
<CODE>EVP_EncryptFinal_ex(),</CODE> <CODE>EVP_DecryptInit_ex(),</CODE>
<CODE>EVP_DecryptFinal_ex(),</CODE> <CODE>EVP_CipherInit_ex(),</CODE>
<CODE>EVP_CipherFinal_ex()</CODE> and
<CODE>EVP_CIPHER_CTX_set_padding()</CODE> appeared in OpenSSL 0.9.7.
</P>
<P>
IDEA appeared in OpenSSL 0.9.7 but was often disabled due to patent
concerns; the last patents expired in 2012.
</P>
        </td><td align="right" width="20" bgcolor="#ffffff">&nbsp;&nbsp;&nbsp;</td><td align="right" width="50" bgcolor="#666699">&nbsp;</td></tr>
  <tr><td align="left" valign="top" width="100" bgcolor="#666699">&nbsp;</td><td align="left" width="20"><img src="../../images/page-corner-bl.gif" alt="" width="20" height="20"></td><td align="left" valign="top" bgcolor="#ffffff">&nbsp;</td><td align="right" width="20"><img src="../../images/page-corner-br.gif" alt="" width="20" height="20"></td><td align="right" width="50" bgcolor="#666699">&nbsp;</td></tr>
  <tr><td colspan="5" bgcolor="#666699">&nbsp;</td></tr>
</table>
</body>
</html>

