<html>
<head>
<!--
     Copyright (c) 1998-2014 The OpenSSL Project, http://www.openssl.org/
     Author:   OpenSSL (openssl@openssl.org)
     Modified: 2014-08-29 01:00:23.
     Generated from ``des.wml'' via WML 2.0.11 (19-Aug-2006).
               by OpenSSL (openssl@openssl.org)
               on 2014-08-29 01:00:50.

     DO NOT EDIT THIS FILE DIRECTLY! INSTEAD EDIT ``des.wml''.
-->
<meta name="Copyright" content="1998-2014 The OpenSSL Project, http://www.openssl.org/">
<meta name="Author"    content="OpenSSL, openssl@openssl.org">
<meta name="Generator" content="WML 2.0.11 (19-Aug-2006)">
<meta name="Modified"  content="2014-08-29 01:00:23">
<title>OpenSSL: Documents, des(3)</title>
<style type="text/css"><!--
BODY { position: absolute; left: 0px; top: 0px; background: #666699; }
A { text-decoration: none; font-weight: bold; }
A:link { text-decoration: none; font-weight: bold; color: #666699; }
A:visited { text-decoration: none; font-weight: bold; color: #666699; }
A:hover { text-decoration: none; font-weight: bold; color: #666699; text-decoration: underline; }
#red { color: #cc3333; }
#sf { font-family: arial,helvetica; font-variant: normal; font-style: normal; }
#sfl { font-weight: bold; font-family: arial,helvetica; font-size: 16pt; line-height: 16pt; font-variant: normal; font-style: normal; }
H1 { font-weight: bold; font-size: 18pt; line-height: 18pt; font-family: arial,helvetica; font-variant: normal; font-style: normal; }
H2 { font-weight: bold; font-size: 14pt; line-height: 14pt; font-family: arial,helvetica; font-variant: normal; font-style: normal; }
H3 { font-weight: bold; font-size: 12pt; line-height: 12pt; font-family: arial,helvetica; font-variant: normal; font-style: normal; }
--></style>
</head>
<body link="#6666cc" alink="#6666cc" vlink="#6666cc" bgcolor="#666699" text="#000000"
      marginheight="0" leftmargin="0" rightmargin="0" topmargin="0">
<table width="100%" cellspacing="0" cellpadding="0" border="0" summary="">
  <tr><td align="left" width="100" bgcolor="#666699"><img src="../../images/page-head-tl.jpg" alt="OpenSSL" width="100" height="80"></td><td align="left" colspan="2" width="600" bgcolor="#666699"><img src="../../images/page-head-tm.jpg" alt="" width="600" height="80"></td><td align="right" width="20" bgcolor="#666699">&nbsp;&nbsp;&nbsp;</td><td align="right" width="50" bgcolor="#666699">&nbsp;</td></tr>
  <tr><td align="left" width="100"><img src="../../images/page-head-bl.jpg" alt="" width="100" height="20"></td><td align="left" width="20"><img src="../../images/page-head-bm.jpg" alt="" width="20" height="20"></td><td align="left" width="100%" bgcolor="#ffffff">
<table cellspacing="0" cellpadding="0" border="0" summary="">
        <tr>
<td><font face="Arial,Helvetica">&nbsp;<a href="../index.html" onmouseover="self.status = '../'; return true" onmouseout="self.status = ''; return true" onfocus="self.status = '../'; return true" onblur="self.status = ''; return true"><font color="#666666">Documents</font></a></font>&nbsp;</td><td>|</td>
<td><font face="Arial,Helvetica">&nbsp;<a href="../apps/openssl.html" onmouseover="self.status = '../apps/openssl.html'; return true" onmouseout="self.status = ''; return true" onfocus="self.status = '../apps/openssl.html'; return true" onblur="self.status = ''; return true"><font color="#666666">openssl(1)</font></a></font>&nbsp;</td><td>|</td>
<td><font face="Arial,Helvetica">&nbsp;<a href="../ssl/ssl.html" onmouseover="self.status = '../ssl/ssl.html'; return true" onmouseout="self.status = ''; return true" onfocus="self.status = '../ssl/ssl.html'; return true" onblur="self.status = ''; return true"><font color="#666666">ssl(3)</font></a></font>&nbsp;</td><td>|</td>
<td><font face="Arial,Helvetica">&nbsp;<a href="crypto.html" onmouseover="self.status = '../crypto/crypto.html'; return true" onmouseout="self.status = ''; return true" onfocus="self.status = '../crypto/crypto.html'; return true" onblur="self.status = ''; return true"><font color="#666666">crypto(3)</font></a></font>&nbsp;</td><td>|</td>
<td><font face="Arial,Helvetica">&nbsp;<a href="../HOWTO/index.html" onmouseover="self.status = '../HOWTO/'; return true" onmouseout="self.status = ''; return true" onfocus="self.status = '../HOWTO/'; return true" onblur="self.status = ''; return true"><font color="#666666">HOWTO</font></a></font>&nbsp;</td><td>|</td>
<td><font face="Arial,Helvetica">&nbsp;<a href="http://wiki.openssl.org/" onmouseover="self.status = 'http://wiki.openssl.org/'; return true" onmouseout="self.status = ''; return true" onfocus="self.status = 'http://wiki.openssl.org/'; return true" onblur="self.status = ''; return true"><font color="#666666">Wiki</font></a></font>&nbsp;</td><td>|</td>
<td><font face="Arial,Helvetica">&nbsp;<a href="../fips/index.html" onmouseover="self.status = '../fips/'; return true" onmouseout="self.status = ''; return true" onfocus="self.status = '../fips/'; return true" onblur="self.status = ''; return true"><font color="#666666">FIPS140</font></a></font>&nbsp;</td><td>|</td>
<td><font face="Arial,Helvetica">&nbsp;<a href="../misc/index.html" onmouseover="self.status = '../misc/'; return true" onmouseout="self.status = ''; return true" onfocus="self.status = '../misc/'; return true" onblur="self.status = ''; return true"><font color="#666666">misc</font></a></font>&nbsp;</td><td></td>
</tr>
      </table>
</td><td align="right" width="20"><img src="../../images/page-corner-tr.gif" alt="" width="20" height="20"></td><td align="right" width="50" bgcolor="#666699">&nbsp;</td></tr>
  <tr><td align="left" valign="top" width="100" bgcolor="#666699"><table cellspacing="0" cellpadding="0" border="0" summary=""><tr><td><img src="../../images/page-navbar-top.jpg" alt="" width="100" height="11"></td></tr>
<script type="text/javascript" language="JavaScript">
<!-- Hiding the code
function nb_imgNormal(imgName) {
    if (document.images) {
        document[imgName].src = eval(imgName + '_n.src');
        self.status = '';
    }
}
function nb_imgSelect(imgName) {
    if (document.images) {
        document[imgName].src = eval(imgName + '_s.src');
        self.status = '';
    }
}
function nb_imgOver(imgName, nohints, descript) {
    if (document.images) {
        document[imgName].src = eval(imgName + '_o.src');
        if (! nohints) self.status = descript;
    }
}
// done hiding -->
</script>
<script type="text/javascript" language="JavaScript">
<!-- Hiding the code
if (document.images) {
    nb_img1_title_n = new Image();
    nb_img1_title_n.src = '../../images/page-navbar-ti-n.jpg';
    nb_img1_title_o = new Image();
    nb_img1_title_o.src = '../../images/page-navbar-ti-s.jpg';
    nb_img1_FAQ_n = new Image();
    nb_img1_FAQ_n.src = '../../images/page-navbar-fq-n.jpg';
    nb_img1_FAQ_o = new Image();
    nb_img1_FAQ_o.src = '../../images/page-navbar-fq-s.jpg';
    nb_img1_about_n = new Image();
    nb_img1_about_n.src = '../../images/page-navbar-ab-n.jpg';
    nb_img1_about_o = new Image();
    nb_img1_about_o.src = '../../images/page-navbar-ab-s.jpg';
    nb_img1_news_n = new Image();
    nb_img1_news_n.src = '../../images/page-navbar-ne-n.jpg';
    nb_img1_news_o = new Image();
    nb_img1_news_o.src = '../../images/page-navbar-ne-s.jpg';
    nb_img1_docs_s = new Image();
    nb_img1_docs_s.src = '../../images/page-navbar-do-s.jpg';
    nb_img1_docs_o = new Image();
    nb_img1_docs_o.src = '../../images/page-navbar-do-s.jpg';
    nb_img1_source_n = new Image();
    nb_img1_source_n.src = '../../images/page-navbar-so-n.jpg';
    nb_img1_source_o = new Image();
    nb_img1_source_o.src = '../../images/page-navbar-so-s.jpg';
    nb_img1_contrib_n = new Image();
    nb_img1_contrib_n.src = '../../images/page-navbar-co-n.jpg';
    nb_img1_contrib_o = new Image();
    nb_img1_contrib_o.src = '../../images/page-navbar-co-s.jpg';
    nb_img1_support_n = new Image();
    nb_img1_support_n.src = '../../images/page-navbar-su-n.jpg';
    nb_img1_support_o = new Image();
    nb_img1_support_o.src = '../../images/page-navbar-su-s.jpg';
    nb_img1_related_n = new Image();
    nb_img1_related_n.src = '../../images/page-navbar-re-n.jpg';
    nb_img1_related_o = new Image();
    nb_img1_related_o.src = '../../images/page-navbar-re-s.jpg';
}
// done hiding -->
</script>
<tr><td><a href="../../index.html" onmouseover="nb_imgOver('nb_img1_title', 0, 'Title'); return true" onmouseout="nb_imgNormal('nb_img1_title'); return true" onfocus="nb_imgOver('nb_img1_title', 0, 'Title'); return true" onblur="nb_imgNormal('nb_img1_title'); return true"><img name="nb_img1_title" src="../../images/page-navbar-ti-n.jpg" alt="Title" border="0" width="100" height="27"></a></td></tr>
<tr><td><a href="../../support/faq.html" onmouseover="nb_imgOver('nb_img1_FAQ', 0, 'FAQ'); return true" onmouseout="nb_imgNormal('nb_img1_FAQ'); return true" onfocus="nb_imgOver('nb_img1_FAQ', 0, 'FAQ'); return true" onblur="nb_imgNormal('nb_img1_FAQ'); return true"><img name="nb_img1_FAQ" src="../../images/page-navbar-fq-n.jpg" alt="FAQ" border="0" width="100" height="27"></a></td></tr>
<tr><td><a href="../../about/index.html" onmouseover="nb_imgOver('nb_img1_about', 0, 'About'); return true" onmouseout="nb_imgNormal('nb_img1_about'); return true" onfocus="nb_imgOver('nb_img1_about', 0, 'About'); return true" onblur="nb_imgNormal('nb_img1_about'); return true"><img name="nb_img1_about" src="../../images/page-navbar-ab-n.jpg" alt="About" border="0" width="100" height="27"></a></td></tr>
<tr><td><a href="../../news/index.html" onmouseover="nb_imgOver('nb_img1_news', 0, 'News'); return true" onmouseout="nb_imgNormal('nb_img1_news'); return true" onfocus="nb_imgOver('nb_img1_news', 0, 'News'); return true" onblur="nb_imgNormal('nb_img1_news'); return true"><img name="nb_img1_news" src="../../images/page-navbar-ne-n.jpg" alt="News" border="0" width="100" height="27"></a></td></tr>
<tr><td><a href="../index.html" onmouseover="nb_imgOver('nb_img1_docs', 0, 'Documents'); return true" onmouseout="nb_imgSelect('nb_img1_docs'); return true" onfocus="nb_imgOver('nb_img1_docs', 0, 'Documents'); return true" onblur="nb_imgSelect('nb_img1_docs'); return true"><img name="nb_img1_docs" src="../../images/page-navbar-do-s.jpg" alt="Documents" border="0" width="100" height="27"></a></td></tr>
<tr><td><a href="../../source/index.html" onmouseover="nb_imgOver('nb_img1_source', 0, 'Source'); return true" onmouseout="nb_imgNormal('nb_img1_source'); return true" onfocus="nb_imgOver('nb_img1_source', 0, 'Source'); return true" onblur="nb_imgNormal('nb_img1_source'); return true"><img name="nb_img1_source" src="../../images/page-navbar-so-n.jpg" alt="Source" border="0" width="100" height="27"></a></td></tr>
<tr><td><a href="../../contrib/index.html" onmouseover="nb_imgOver('nb_img1_contrib', 0, 'Contribution'); return true" onmouseout="nb_imgNormal('nb_img1_contrib'); return true" onfocus="nb_imgOver('nb_img1_contrib', 0, 'Contribution'); return true" onblur="nb_imgNormal('nb_img1_contrib'); return true"><img name="nb_img1_contrib" src="../../images/page-navbar-co-n.jpg" alt="Contribution" border="0" width="100" height="27"></a></td></tr>
<tr><td><a href="../../support/index.html" onmouseover="nb_imgOver('nb_img1_support', 0, 'Support'); return true" onmouseout="nb_imgNormal('nb_img1_support'); return true" onfocus="nb_imgOver('nb_img1_support', 0, 'Support'); return true" onblur="nb_imgNormal('nb_img1_support'); return true"><img name="nb_img1_support" src="../../images/page-navbar-su-n.jpg" alt="Support" border="0" width="100" height="27"></a></td></tr>
<tr><td><a href="../../related/index.html" onmouseover="nb_imgOver('nb_img1_related', 0, 'Related'); return true" onmouseout="nb_imgNormal('nb_img1_related'); return true" onfocus="nb_imgOver('nb_img1_related', 0, 'Related'); return true" onblur="nb_imgNormal('nb_img1_related'); return true"><img name="nb_img1_related" src="../../images/page-navbar-re-n.jpg" alt="Related" border="0" width="100" height="27"></a></td></tr>
    <tr><td><img src="../../images/page-navbar-bot.jpg" alt="" width="100" height="150"><br><p></td></tr>
  </table>
</td><td align="left" valign="top" width="20" bgcolor="#ffffff">&nbsp;</td><td align="left" valign="top" bgcolor="#ffffff"><br>
        
<h1>des(3)</h1>
<!-- INDEX BEGIN -->
<UL>
	<LI><A HREF="des.html#NAME">NAME</A>
	<LI><A HREF="des.html#SYNOPSIS">SYNOPSIS</A>
	<LI><A HREF="des.html#DESCRIPTION">DESCRIPTION</A>
	<LI><A HREF="des.html#BUGS">BUGS</A>
	<LI><A HREF="des.html#CONFORMING_TO">CONFORMING TO</A>
	<LI><A HREF="des.html#NOTES">NOTES</A>
	<LI><A HREF="des.html#HISTORY">HISTORY</A>
	<LI><A HREF="des.html#AUTHOR">AUTHOR</A>
	<LI><A HREF="des.html#SEE_ALSO">SEE ALSO</A>
</UL>
<!-- INDEX END -->
<HR>
<P>
<HR>
<H1><A NAME="NAME">NAME</A></H1>
<P>
DES_random_key, DES_set_key, DES_key_sched, DES_set_key_checked,
DES_set_key_unchecked, DES_set_odd_parity, DES_is_weak_key,
DES_ecb_encrypt, DES_ecb2_encrypt, DES_ecb3_encrypt, DES_ncbc_encrypt,
DES_cfb_encrypt, DES_ofb_encrypt, DES_pcbc_encrypt, DES_cfb64_encrypt,
DES_ofb64_encrypt, DES_xcbc_encrypt, DES_ede2_cbc_encrypt,
DES_ede2_cfb64_encrypt, DES_ede2_ofb64_encrypt, DES_ede3_cbc_encrypt,
DES_ede3_cbcm_encrypt, DES_ede3_cfb64_encrypt, DES_ede3_ofb64_encrypt,
DES_cbc_cksum, DES_quad_cksum, DES_string_to_key, DES_string_to_2keys,
DES_fcrypt, DES_crypt, DES_enc_read, DES_enc_write - DES encryption
</P>
<P>
<HR>
<H1><A NAME="SYNOPSIS">SYNOPSIS</A></H1>
<PRE> #include &lt;openssl/des.h&gt;
</PRE>
<PRE> void DES_random_key(DES_cblock *ret);
</PRE>
<PRE> int DES_set_key(const_DES_cblock *key, DES_key_schedule *schedule);
 int DES_key_sched(const_DES_cblock *key, DES_key_schedule *schedule);
 int DES_set_key_checked(const_DES_cblock *key,
        DES_key_schedule *schedule);
 void DES_set_key_unchecked(const_DES_cblock *key,
        DES_key_schedule *schedule);
</PRE>
<PRE> void DES_set_odd_parity(DES_cblock *key);
 int DES_is_weak_key(const_DES_cblock *key);
</PRE>
<PRE> void DES_ecb_encrypt(const_DES_cblock *input, DES_cblock *output,
        DES_key_schedule *ks, int enc);
 void DES_ecb2_encrypt(const_DES_cblock *input, DES_cblock *output,
        DES_key_schedule *ks1, DES_key_schedule *ks2, int enc);
 void DES_ecb3_encrypt(const_DES_cblock *input, DES_cblock *output,
        DES_key_schedule *ks1, DES_key_schedule *ks2,
        DES_key_schedule *ks3, int enc);
</PRE>
<PRE> void DES_ncbc_encrypt(const unsigned char *input, unsigned char *output,
        long length, DES_key_schedule *schedule, DES_cblock *ivec,
        int enc);
 void DES_cfb_encrypt(const unsigned char *in, unsigned char *out,
        int numbits, long length, DES_key_schedule *schedule,
        DES_cblock *ivec, int enc);
 void DES_ofb_encrypt(const unsigned char *in, unsigned char *out,
        int numbits, long length, DES_key_schedule *schedule,
        DES_cblock *ivec);
 void DES_pcbc_encrypt(const unsigned char *input, unsigned char *output,
        long length, DES_key_schedule *schedule, DES_cblock *ivec,
        int enc);
 void DES_cfb64_encrypt(const unsigned char *in, unsigned char *out,
        long length, DES_key_schedule *schedule, DES_cblock *ivec,
        int *num, int enc);
 void DES_ofb64_encrypt(const unsigned char *in, unsigned char *out,
        long length, DES_key_schedule *schedule, DES_cblock *ivec,
        int *num);
</PRE>
<PRE> void DES_xcbc_encrypt(const unsigned char *input, unsigned char *output,
        long length, DES_key_schedule *schedule, DES_cblock *ivec,
        const_DES_cblock *inw, const_DES_cblock *outw, int enc);
</PRE>
<PRE> void DES_ede2_cbc_encrypt(const unsigned char *input,
        unsigned char *output, long length, DES_key_schedule *ks1,
        DES_key_schedule *ks2, DES_cblock *ivec, int enc);
 void DES_ede2_cfb64_encrypt(const unsigned char *in,
        unsigned char *out, long length, DES_key_schedule *ks1,
        DES_key_schedule *ks2, DES_cblock *ivec, int *num, int enc);
 void DES_ede2_ofb64_encrypt(const unsigned char *in,
        unsigned char *out, long length, DES_key_schedule *ks1,
        DES_key_schedule *ks2, DES_cblock *ivec, int *num);
</PRE>
<PRE> void DES_ede3_cbc_encrypt(const unsigned char *input,
        unsigned char *output, long length, DES_key_schedule *ks1,
        DES_key_schedule *ks2, DES_key_schedule *ks3, DES_cblock *ivec,
        int enc);
 void DES_ede3_cbcm_encrypt(const unsigned char *in, unsigned char *out,
        long length, DES_key_schedule *ks1, DES_key_schedule *ks2,
        DES_key_schedule *ks3, DES_cblock *ivec1, DES_cblock *ivec2,
        int enc);
 void DES_ede3_cfb64_encrypt(const unsigned char *in, unsigned char *out,
        long length, DES_key_schedule *ks1, DES_key_schedule *ks2,
        DES_key_schedule *ks3, DES_cblock *ivec, int *num, int enc);
 void DES_ede3_ofb64_encrypt(const unsigned char *in, unsigned char *out,
        long length, DES_key_schedule *ks1,
        DES_key_schedule *ks2, DES_key_schedule *ks3,
        DES_cblock *ivec, int *num);
</PRE>
<PRE> DES_LONG DES_cbc_cksum(const unsigned char *input, DES_cblock *output,
        long length, DES_key_schedule *schedule,
        const_DES_cblock *ivec);
 DES_LONG DES_quad_cksum(const unsigned char *input, DES_cblock output&#91;&#93;,
        long length, int out_count, DES_cblock *seed);
 void DES_string_to_key(const char *str, DES_cblock *key);
 void DES_string_to_2keys(const char *str, DES_cblock *key1,
        DES_cblock *key2);
</PRE>
<PRE> char *DES_fcrypt(const char *buf, const char *salt, char *ret);
 char *DES_crypt(const char *buf, const char *salt);
</PRE>
<PRE> int DES_enc_read(int fd, void *buf, int len, DES_key_schedule *sched,
        DES_cblock *iv);
 int DES_enc_write(int fd, const void *buf, int len,
        DES_key_schedule *sched, DES_cblock *iv);
</PRE>
<P>
<HR>
<H1><A NAME="DESCRIPTION">DESCRIPTION</A></H1>
<P>
This library contains a fast implementation of the DES encryption
algorithm.
</P>
<P>
There are two phases to the use of DES encryption. The first is the
generation of a <EM>DES_key_schedule</EM> from a key, the second is the actual encryption. A DES key is of type <EM>DES_cblock</EM>. This type is consists of 8 bytes with odd parity. The least significant
bit in each byte is the parity bit. The key schedule is an expanded form of
the key; it is used to speed the encryption process.
</P>
<P>
<CODE>DES_random_key()</CODE> generates a random key. The PRNG must be
seeded prior to using this function (see <A HREF="rand.html#">rand(3)</A>). If the PRNG could not generate a secure key, 0 is returned.
</P>
<P>
Before a DES key can be used, it must be converted into the architecture
dependent <EM>DES_key_schedule</EM> via the <CODE>DES_set_key_checked()</CODE> or
<CODE>DES_set_key_unchecked()</CODE> function.
</P>
<P>
<CODE>DES_set_key_checked()</CODE> will check that the key passed is of odd
parity and is not a week or semi-weak key. If the parity is wrong, then -1
is returned. If the key is a weak key, then -2 is returned. If an error is
returned, the key schedule is not generated.
</P>
<P>
<CODE>DES_set_key()</CODE> works like <CODE>DES_set_key_checked()</CODE> if
the <EM>DES_check_key</EM> flag is non-zero, otherwise like <CODE>DES_set_key_unchecked().</CODE>
These functions are available for compatibility; it is recommended to use a
function that does not depend on a global variable.
</P>
<P>
<CODE>DES_set_odd_parity()</CODE> sets the parity of the passed <EM>key</EM> to odd.
</P>
<P>
<CODE>DES_is_weak_key()</CODE> returns 1 if the passed key is a weak key, 0
if it is ok.
</P>
<P>
The following routines mostly operate on an input and output stream of
<EM>DES_cblock</EM>s.
</P>
<P>
<CODE>DES_ecb_encrypt()</CODE> is the basic DES encryption routine that
encrypts or decrypts a single 8-byte <EM>DES_cblock</EM> in <EM>electronic code book</EM>
(ECB) mode. It always transforms the input data, pointed to by
<EM>input</EM>, into the output data, pointed to by the <EM>output</EM> argument. If the <EM>encrypt</EM> argument is non-zero (DES_ENCRYPT), the <EM>input</EM>
(cleartext) is encrypted in to the <EM>output</EM> (ciphertext) using the key_schedule specified by the <EM>schedule</EM> argument, previously set via
<EM>DES_set_key</EM>. If <EM>encrypt</EM> is zero (DES_DECRYPT), the <EM>input</EM> (now ciphertext) is decrypted into the <EM>output</EM> (now cleartext). Input and output may overlap.
<CODE>DES_ecb_encrypt()</CODE> does not return a value.
</P>
<P>
<CODE>DES_ecb3_encrypt()</CODE> encrypts/decrypts the <EM>input</EM> block by using three-key Triple-DES encryption in ECB mode. This involves
encrypting the input with <EM>ks1</EM>, decrypting with the key schedule <EM>ks2</EM>, and then encrypting with <EM>ks3</EM>. This routine greatly reduces the chances of brute force breaking of DES
and has the advantage of if <EM>ks1</EM>,
<EM>ks2</EM> and <EM>ks3</EM> are the same, it is equivalent to just encryption using ECB mode and <EM>ks1</EM> as the key.
</P>
<P>
The macro <CODE>DES_ecb2_encrypt()</CODE> is provided to perform two-key
Triple-DES encryption by using <EM>ks1</EM> for the final encryption.
</P>
<P>
<CODE>DES_ncbc_encrypt()</CODE> encrypts/decrypts using the <EM>cipher-block-chaining</EM>
(CBC) mode of DES. If the <EM>encrypt</EM> argument is non-zero, the routine cipher-block-chain encrypts the cleartext
data pointed to by the <EM>input</EM> argument into the ciphertext pointed to by the <EM>output</EM>
argument, using the key schedule provided by the <EM>schedule</EM> argument, and initialization vector provided by the <EM>ivec</EM> argument. If the
<EM>length</EM> argument is not an integral multiple of eight bytes, the last block is
copied to a temporary area and zero filled. The output is always an
integral multiple of eight bytes.
</P>
<P>
<CODE>DES_xcbc_encrypt()</CODE> is RSA's DESX mode of DES. It uses <EM>inw</EM> and
<EM>outw</EM> to 'whiten' the encryption. <EM>inw</EM> and <EM>outw</EM> are secret (unlike the iv) and are as such, part of the key. So the key is
sort of 24 bytes. This is much better than CBC DES.
</P>
<P>
<CODE>DES_ede3_cbc_encrypt()</CODE> implements outer triple CBC DES
encryption with three keys. This means that each DES operation inside the
CBC mode is an <CODE>C=E(ks3,D(ks2,E(ks1,M)))</CODE>. This mode is used by SSL.
</P>
<P>
The <CODE>DES_ede2_cbc_encrypt()</CODE> macro implements two-key Triple-DES
by reusing <EM>ks1</EM> for the final encryption. <CODE>C=E(ks1,D(ks2,E(ks1,M)))</CODE>. This form of Triple-DES is used by the RSAREF library.
</P>
<P>
<CODE>DES_pcbc_encrypt()</CODE> encrypt/decrypts using the propagating
cipher block chaining mode used by Kerberos v4. Its parameters are the same
as <CODE>DES_ncbc_encrypt().</CODE>
</P>
<P>
<CODE>DES_cfb_encrypt()</CODE> encrypt/decrypts using cipher feedback mode.
This method takes an array of characters as input and outputs and array of
characters. It does not require any padding to 8 character groups. Note:
the <EM>ivec</EM> variable is changed and the new changed value needs to be passed to the
next call to this function. Since this function runs a complete DES ECB
encryption per <EM>numbits</EM>, this function is only suggested for use when sending small numbers of
characters.
</P>
<P>
<CODE>DES_cfb64_encrypt()</CODE> implements CFB mode of DES with 64bit
feedback. Why is this useful you ask? Because this routine will allow you
to encrypt an arbitrary number of bytes, no 8 byte padding. Each call to
this routine will encrypt the input bytes to output and then update ivec
and num. num contains 'how far' we are though ivec. If this does not make
much sense, read more about cfb mode of DES :-).
</P>
<P>
<CODE>DES_ede3_cfb64_encrypt()</CODE> and
<CODE>DES_ede2_cfb64_encrypt()</CODE> is the same as
<CODE>DES_cfb64_encrypt()</CODE> except that Triple-DES is used.
</P>
<P>
<CODE>DES_ofb_encrypt()</CODE> encrypts using output feedback mode. This
method takes an array of characters as input and outputs and array of
characters. It does not require any padding to 8 character groups. Note:
the <EM>ivec</EM> variable is changed and the new changed value needs to be passed to the
next call to this function. Since this function runs a complete DES ECB
encryption per numbits, this function is only suggested for use when
sending small numbers of characters.
</P>
<P>
<CODE>DES_ofb64_encrypt()</CODE> is the same as
<CODE>DES_cfb64_encrypt()</CODE> using Output Feed Back mode.
</P>
<P>
<CODE>DES_ede3_ofb64_encrypt()</CODE> and
<CODE>DES_ede2_ofb64_encrypt()</CODE> is the same as
<CODE>DES_ofb64_encrypt(),</CODE> using Triple-DES.
</P>
<P>
The following functions are included in the DES library for compatibility
with the MIT Kerberos library.
</P>
<P>
<CODE>DES_cbc_cksum()</CODE> produces an 8 byte checksum based on the input
stream (via CBC encryption). The last 4 bytes of the checksum are returned
and the complete 8 bytes are placed in <EM>output</EM>. This function is used by Kerberos v4. Other applications should use
<A HREF="EVP_DigestInit.html#">EVP_DigestInit(3)</A> etc. instead.
</P>
<P>
<CODE>DES_quad_cksum()</CODE> is a Kerberos v4 function. It returns a 4
byte checksum from the input bytes. The algorithm can be iterated over the
input, depending on <EM>out_count</EM>, 1, 2, 3 or 4 times. If <EM>output</EM> is non-NULL, the 8 bytes generated by each pass are written into
<EM>output</EM>.
</P>
<P>
The following are DES-based transformations:
</P>
<P>
<CODE>DES_fcrypt()</CODE> is a fast version of the Unix
<CODE>crypt(3)</CODE> function. This version takes only a small amount of
space relative to other fast <CODE>crypt()</CODE> implementations. This is
different to the normal crypt in that the third parameter is the buffer
that the return value is written into. It needs to be at least 14 bytes
long. This function is thread safe, unlike the normal crypt.
</P>
<P>
<CODE>DES_crypt()</CODE> is a faster replacement for the normal system
<CODE>crypt().</CODE> This function calls <CODE>DES_fcrypt()</CODE> with a
static array passed as the third parameter. This emulates the normal
non-thread safe semantics of <CODE>crypt(3).</CODE>
</P>
<P>
<CODE>DES_enc_write()</CODE> writes <EM>len</EM> bytes to file descriptor <EM>fd</EM> from buffer <EM>buf</EM>. The data is encrypted via <EM>pcbc_encrypt</EM> (default) using <EM>sched</EM> for the key and <EM>iv</EM> as a starting vector. The actual data send down <EM>fd</EM> consists of 4 bytes (in network byte order) containing the length of the
following encrypted data. The encrypted data then follows, padded with
random data out to a multiple of 8 bytes.
</P>
<P>
<CODE>DES_enc_read()</CODE> is used to read <EM>len</EM> bytes from file descriptor
<EM>fd</EM> into buffer <EM>buf</EM>. The data being read from <EM>fd</EM> is assumed to have come from <CODE>DES_enc_write()</CODE> and is decrypted
using <EM>sched</EM> for the key schedule and <EM>iv</EM> for the initial vector.
</P>
<P>
<STRONG>Warning:</STRONG> The data format used by <CODE>DES_enc_write()</CODE> and
<CODE>DES_enc_read()</CODE> has a cryptographic weakness: When asked to
write more than MAXWRITE bytes, <CODE>DES_enc_write()</CODE> will split the
data into several chunks that are all encrypted using the same IV. So don't
use these functions unless you are sure you know what you do (in which case
you might not want to use them anyway). They cannot handle non-blocking
sockets. <CODE>DES_enc_read()</CODE> uses an internal state and thus cannot
be used on multiple files.
</P>
<P>
<EM>DES_rw_mode</EM> is used to specify the encryption mode to use with
<CODE>DES_enc_read()</CODE> and <CODE>DES_end_write().</CODE> If set to <EM>DES_PCBC_MODE</EM> (the default), DES_pcbc_encrypt is used. If set to <EM>DES_CBC_MODE</EM>
DES_cbc_encrypt is used.
</P>
<P>
<HR>
<H1><A NAME="BUGS">BUGS</A></H1>
<P>
<CODE>DES_3cbc_encrypt()</CODE> is flawed and must not be used in
applications.
</P>
<P>
<CODE>DES_cbc_encrypt()</CODE> does not modify <STRONG>ivec</STRONG>; use <CODE>DES_ncbc_encrypt()</CODE> instead.
</P>
<P>
<CODE>DES_cfb_encrypt()</CODE> and <CODE>DES_ofb_encrypt()</CODE> operates
on input of 8 bits. What this means is that if you set numbits to 12, and
length to 2, the first 12 bits will come from the 1st input byte and the
low half of the second input byte. The second 12 bits will have the low 8
bits taken from the 3rd input byte and the top 4 bits taken from the 4th
input byte. The same holds for output. This function has been implemented
this way because most people will be using a multiple of 8 and because once
you get into pulling bytes input bytes apart things get ugly!
</P>
<P>
<CODE>DES_string_to_key()</CODE> is available for backward compatibility
with the MIT library. New applications should use a cryptographic hash
function. The same applies for <CODE>DES_string_to_2key().</CODE>
</P>
<P>
<HR>
<H1><A NAME="CONFORMING_TO">CONFORMING TO</A></H1>
<P>
ANSI X3.106
</P>
<P>
The <STRONG>des</STRONG> library was written to be source code compatible with the MIT Kerberos
library.
</P>
<P>
<HR>
<H1><A NAME="NOTES">NOTES</A></H1>
<P>
Applications should use the higher level functions
<A HREF="EVP_EncryptInit.html#">EVP_EncryptInit(3)</A> etc. instead of calling these functions directly.
</P>
<P>
Single-key DES is insecure due to its short key size. ECB mode is not
suitable for most applications; see <A HREF="des_modes.html#">des_modes(7)</A>.
</P>
<P>
<HR>
<H1><A NAME="HISTORY">HISTORY</A></H1>
<P>
In OpenSSL 0.9.7, all des_ functions were renamed to DES_ to avoid clashes
with older versions of libdes. Compatibility des_ functions are provided
for a short while, as well as <CODE>crypt().</CODE> Declarations for these
are in &lt;openssl/des_old.h&gt;. There is no DES_ variant for
<CODE>des_random_seed().</CODE> This will happen to other functions as well
if they are deemed redundant (des_random_seed() just calls
<CODE>RAND_seed()</CODE> and is present for backward compatibility only),
buggy or already scheduled for removal.
</P>
<P>
<CODE>des_cbc_cksum(),</CODE> <CODE>des_cbc_encrypt(),</CODE>
<CODE>des_ecb_encrypt(),</CODE> <CODE>des_is_weak_key(),</CODE>
<CODE>des_key_sched(),</CODE> <CODE>des_pcbc_encrypt(),</CODE>
<CODE>des_quad_cksum(),</CODE> <CODE>des_random_key()</CODE> and
<CODE>des_string_to_key()</CODE> are available in the MIT Kerberos library;
<CODE>des_check_key_parity(),</CODE> <CODE>des_fixup_key_parity()</CODE>
and <CODE>des_is_weak_key()</CODE> are available in newer versions of that
library.
</P>
<P>
<CODE>des_set_key_checked()</CODE> and <CODE>des_set_key_unchecked()</CODE>
were added in OpenSSL 0.9.5.
</P>
<P>
<CODE>des_generate_random_block(),</CODE>
<CODE>des_init_random_number_generator(),</CODE>
<CODE>des_new_random_key(),</CODE>
<CODE>des_set_random_generator_seed()</CODE> and
<CODE>des_set_sequence_number()</CODE> and <CODE>des_rand_data()</CODE> are
used in newer versions of Kerberos but are not implemented here.
</P>
<P>
<CODE>des_random_key()</CODE> generated cryptographically weak random data
in SSLeay and in OpenSSL prior version 0.9.5, as well as in the original
MIT library.
</P>
<P>
<HR>
<H1><A NAME="AUTHOR">AUTHOR</A></H1>
<P>
Eric Young (<A HREF="mailto:eay@cryptsoft.com">eay@cryptsoft.com</A>)
Modified for the OpenSSL project (http://www.openssl.org).
</P>
<P>
<HR>
<H1><A NAME="SEE_ALSO">SEE ALSO</A></H1>
<P>
<A HREF="des_modes.html#">des_modes(7)</A>,
<A HREF="EVP_EncryptInit.html#">EVP_EncryptInit(3)</A>
</P>
        </td><td align="right" width="20" bgcolor="#ffffff">&nbsp;&nbsp;&nbsp;</td><td align="right" width="50" bgcolor="#666699">&nbsp;</td></tr>
  <tr><td align="left" valign="top" width="100" bgcolor="#666699">&nbsp;</td><td align="left" width="20"><img src="../../images/page-corner-bl.gif" alt="" width="20" height="20"></td><td align="left" valign="top" bgcolor="#ffffff">&nbsp;</td><td align="right" width="20"><img src="../../images/page-corner-br.gif" alt="" width="20" height="20"></td><td align="right" width="50" bgcolor="#666699">&nbsp;</td></tr>
  <tr><td colspan="5" bgcolor="#666699">&nbsp;</td></tr>
</table>
</body>
</html>

