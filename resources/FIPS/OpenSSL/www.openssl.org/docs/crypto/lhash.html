<html>
<head>
<!--
     Copyright (c) 1998-2014 The OpenSSL Project, http://www.openssl.org/
     Author:   OpenSSL (openssl@openssl.org)
     Modified: 2013-01-17 09:33:34.
     Generated from ``lhash.wml'' via WML 2.0.11 (19-Aug-2006).
               by OpenSSL (openssl@openssl.org)
               on 2014-05-01 12:15:25.

     DO NOT EDIT THIS FILE DIRECTLY! INSTEAD EDIT ``lhash.wml''.
-->
<meta name="Copyright" content="1998-2014 The OpenSSL Project, http://www.openssl.org/">
<meta name="Author"    content="OpenSSL, openssl@openssl.org">
<meta name="Generator" content="WML 2.0.11 (19-Aug-2006)">
<meta name="Modified"  content="2013-01-17 09:33:34">
<title>OpenSSL: Documents, lhash(3)</title>
<style type="text/css"><!--
BODY { position: absolute; left: 0px; top: 0px; background: #666699; }
A { text-decoration: none; font-weight: bold; }
A:link { text-decoration: none; font-weight: bold; color: #666699; }
A:visited { text-decoration: none; font-weight: bold; color: #666699; }
A:hover { text-decoration: none; font-weight: bold; color: #666699; text-decoration: underline; }
#red { color: #cc3333; }
#sf { font-family: arial,helvetica; font-variant: normal; font-style: normal; }
#sfl { font-weight: bold; font-family: arial,helvetica; font-size: 16pt; line-height: 16pt; font-variant: normal; font-style: normal; }
H1 { font-weight: bold; font-size: 18pt; line-height: 18pt; font-family: arial,helvetica; font-variant: normal; font-style: normal; }
H2 { font-weight: bold; font-size: 14pt; line-height: 14pt; font-family: arial,helvetica; font-variant: normal; font-style: normal; }
H3 { font-weight: bold; font-size: 12pt; line-height: 12pt; font-family: arial,helvetica; font-variant: normal; font-style: normal; }
--></style>
</head>
<body link="#6666cc" alink="#6666cc" vlink="#6666cc" bgcolor="#666699" text="#000000"
      marginheight="0" leftmargin="0" rightmargin="0" topmargin="0">
<table width="100%" cellspacing="0" cellpadding="0" border="0" summary="">
  <tr><td align="left" width="100" bgcolor="#666699"><img src="../../images/page-head-tl.jpg" alt="OpenSSL" width="100" height="80"></td><td align="left" colspan="2" width="600" bgcolor="#666699"><img src="../../images/page-head-tm.jpg" alt="" width="600" height="80"></td><td align="right" width="20" bgcolor="#666699">&nbsp;&nbsp;&nbsp;</td><td align="right" width="50" bgcolor="#666699">&nbsp;</td></tr>
  <tr><td align="left" width="100"><img src="../../images/page-head-bl.jpg" alt="" width="100" height="20"></td><td align="left" width="20"><img src="../../images/page-head-bm.jpg" alt="" width="20" height="20"></td><td align="left" width="100%" bgcolor="#ffffff">
<table cellspacing="0" cellpadding="0" border="0" summary="">
        <tr>
<td><font face="Arial,Helvetica">&nbsp;<a href="../index.html" onmouseover="self.status = '../'; return true" onmouseout="self.status = ''; return true" onfocus="self.status = '../'; return true" onblur="self.status = ''; return true"><font color="#666666">Documents</font></a></font>&nbsp;</td><td>|</td>
<td><font face="Arial,Helvetica">&nbsp;<a href="../apps/openssl.html" onmouseover="self.status = '../apps/openssl.html'; return true" onmouseout="self.status = ''; return true" onfocus="self.status = '../apps/openssl.html'; return true" onblur="self.status = ''; return true"><font color="#666666">openssl(1)</font></a></font>&nbsp;</td><td>|</td>
<td><font face="Arial,Helvetica">&nbsp;<a href="../ssl/ssl.html" onmouseover="self.status = '../ssl/ssl.html'; return true" onmouseout="self.status = ''; return true" onfocus="self.status = '../ssl/ssl.html'; return true" onblur="self.status = ''; return true"><font color="#666666">ssl(3)</font></a></font>&nbsp;</td><td>|</td>
<td><font face="Arial,Helvetica">&nbsp;<a href="crypto.html" onmouseover="self.status = '../crypto/crypto.html'; return true" onmouseout="self.status = ''; return true" onfocus="self.status = '../crypto/crypto.html'; return true" onblur="self.status = ''; return true"><font color="#666666">crypto(3)</font></a></font>&nbsp;</td><td>|</td>
<td><font face="Arial,Helvetica">&nbsp;<a href="../HOWTO/index.html" onmouseover="self.status = '../HOWTO/'; return true" onmouseout="self.status = ''; return true" onfocus="self.status = '../HOWTO/'; return true" onblur="self.status = ''; return true"><font color="#666666">HOWTO</font></a></font>&nbsp;</td><td>|</td>
<td><font face="Arial,Helvetica">&nbsp;<a href="http://wiki.openssl.org/" onmouseover="self.status = 'http://wiki.openssl.org/'; return true" onmouseout="self.status = ''; return true" onfocus="self.status = 'http://wiki.openssl.org/'; return true" onblur="self.status = ''; return true"><font color="#666666">Wiki</font></a></font>&nbsp;</td><td>|</td>
<td><font face="Arial,Helvetica">&nbsp;<a href="../fips/index.html" onmouseover="self.status = '../fips/'; return true" onmouseout="self.status = ''; return true" onfocus="self.status = '../fips/'; return true" onblur="self.status = ''; return true"><font color="#666666">FIPS140</font></a></font>&nbsp;</td><td>|</td>
<td><font face="Arial,Helvetica">&nbsp;<a href="../misc/index.html" onmouseover="self.status = '../misc/'; return true" onmouseout="self.status = ''; return true" onfocus="self.status = '../misc/'; return true" onblur="self.status = ''; return true"><font color="#666666">misc</font></a></font>&nbsp;</td><td></td>
</tr>
      </table>
</td><td align="right" width="20"><img src="../../images/page-corner-tr.gif" alt="" width="20" height="20"></td><td align="right" width="50" bgcolor="#666699">&nbsp;</td></tr>
  <tr><td align="left" valign="top" width="100" bgcolor="#666699"><table cellspacing="0" cellpadding="0" border="0" summary=""><tr><td><img src="../../images/page-navbar-top.jpg" alt="" width="100" height="11"></td></tr>
<script type="text/javascript" language="JavaScript">
<!-- Hiding the code
function nb_imgNormal(imgName) {
    if (document.images) {
        document[imgName].src = eval(imgName + '_n.src');
        self.status = '';
    }
}
function nb_imgSelect(imgName) {
    if (document.images) {
        document[imgName].src = eval(imgName + '_s.src');
        self.status = '';
    }
}
function nb_imgOver(imgName, nohints, descript) {
    if (document.images) {
        document[imgName].src = eval(imgName + '_o.src');
        if (! nohints) self.status = descript;
    }
}
// done hiding -->
</script>
<script type="text/javascript" language="JavaScript">
<!-- Hiding the code
if (document.images) {
    nb_img1_title_n = new Image();
    nb_img1_title_n.src = '../../images/page-navbar-ti-n.jpg';
    nb_img1_title_o = new Image();
    nb_img1_title_o.src = '../../images/page-navbar-ti-s.jpg';
    nb_img1_FAQ_n = new Image();
    nb_img1_FAQ_n.src = '../../images/page-navbar-fq-n.jpg';
    nb_img1_FAQ_o = new Image();
    nb_img1_FAQ_o.src = '../../images/page-navbar-fq-s.jpg';
    nb_img1_about_n = new Image();
    nb_img1_about_n.src = '../../images/page-navbar-ab-n.jpg';
    nb_img1_about_o = new Image();
    nb_img1_about_o.src = '../../images/page-navbar-ab-s.jpg';
    nb_img1_news_n = new Image();
    nb_img1_news_n.src = '../../images/page-navbar-ne-n.jpg';
    nb_img1_news_o = new Image();
    nb_img1_news_o.src = '../../images/page-navbar-ne-s.jpg';
    nb_img1_docs_s = new Image();
    nb_img1_docs_s.src = '../../images/page-navbar-do-s.jpg';
    nb_img1_docs_o = new Image();
    nb_img1_docs_o.src = '../../images/page-navbar-do-s.jpg';
    nb_img1_source_n = new Image();
    nb_img1_source_n.src = '../../images/page-navbar-so-n.jpg';
    nb_img1_source_o = new Image();
    nb_img1_source_o.src = '../../images/page-navbar-so-s.jpg';
    nb_img1_contrib_n = new Image();
    nb_img1_contrib_n.src = '../../images/page-navbar-co-n.jpg';
    nb_img1_contrib_o = new Image();
    nb_img1_contrib_o.src = '../../images/page-navbar-co-s.jpg';
    nb_img1_support_n = new Image();
    nb_img1_support_n.src = '../../images/page-navbar-su-n.jpg';
    nb_img1_support_o = new Image();
    nb_img1_support_o.src = '../../images/page-navbar-su-s.jpg';
    nb_img1_related_n = new Image();
    nb_img1_related_n.src = '../../images/page-navbar-re-n.jpg';
    nb_img1_related_o = new Image();
    nb_img1_related_o.src = '../../images/page-navbar-re-s.jpg';
}
// done hiding -->
</script>
<tr><td><a href="../../index.html" onmouseover="nb_imgOver('nb_img1_title', 0, 'Title'); return true" onmouseout="nb_imgNormal('nb_img1_title'); return true" onfocus="nb_imgOver('nb_img1_title', 0, 'Title'); return true" onblur="nb_imgNormal('nb_img1_title'); return true"><img name="nb_img1_title" src="../../images/page-navbar-ti-n.jpg" alt="Title" border="0" width="100" height="27"></a></td></tr>
<tr><td><a href="../../support/faq.html" onmouseover="nb_imgOver('nb_img1_FAQ', 0, 'FAQ'); return true" onmouseout="nb_imgNormal('nb_img1_FAQ'); return true" onfocus="nb_imgOver('nb_img1_FAQ', 0, 'FAQ'); return true" onblur="nb_imgNormal('nb_img1_FAQ'); return true"><img name="nb_img1_FAQ" src="../../images/page-navbar-fq-n.jpg" alt="FAQ" border="0" width="100" height="27"></a></td></tr>
<tr><td><a href="../../about/index.html" onmouseover="nb_imgOver('nb_img1_about', 0, 'About'); return true" onmouseout="nb_imgNormal('nb_img1_about'); return true" onfocus="nb_imgOver('nb_img1_about', 0, 'About'); return true" onblur="nb_imgNormal('nb_img1_about'); return true"><img name="nb_img1_about" src="../../images/page-navbar-ab-n.jpg" alt="About" border="0" width="100" height="27"></a></td></tr>
<tr><td><a href="../../news/index.html" onmouseover="nb_imgOver('nb_img1_news', 0, 'News'); return true" onmouseout="nb_imgNormal('nb_img1_news'); return true" onfocus="nb_imgOver('nb_img1_news', 0, 'News'); return true" onblur="nb_imgNormal('nb_img1_news'); return true"><img name="nb_img1_news" src="../../images/page-navbar-ne-n.jpg" alt="News" border="0" width="100" height="27"></a></td></tr>
<tr><td><a href="../index.html" onmouseover="nb_imgOver('nb_img1_docs', 0, 'Documents'); return true" onmouseout="nb_imgSelect('nb_img1_docs'); return true" onfocus="nb_imgOver('nb_img1_docs', 0, 'Documents'); return true" onblur="nb_imgSelect('nb_img1_docs'); return true"><img name="nb_img1_docs" src="../../images/page-navbar-do-s.jpg" alt="Documents" border="0" width="100" height="27"></a></td></tr>
<tr><td><a href="../../source/index.html" onmouseover="nb_imgOver('nb_img1_source', 0, 'Source'); return true" onmouseout="nb_imgNormal('nb_img1_source'); return true" onfocus="nb_imgOver('nb_img1_source', 0, 'Source'); return true" onblur="nb_imgNormal('nb_img1_source'); return true"><img name="nb_img1_source" src="../../images/page-navbar-so-n.jpg" alt="Source" border="0" width="100" height="27"></a></td></tr>
<tr><td><a href="../../contrib/index.html" onmouseover="nb_imgOver('nb_img1_contrib', 0, 'Contribution'); return true" onmouseout="nb_imgNormal('nb_img1_contrib'); return true" onfocus="nb_imgOver('nb_img1_contrib', 0, 'Contribution'); return true" onblur="nb_imgNormal('nb_img1_contrib'); return true"><img name="nb_img1_contrib" src="../../images/page-navbar-co-n.jpg" alt="Contribution" border="0" width="100" height="27"></a></td></tr>
<tr><td><a href="../../support/index.html" onmouseover="nb_imgOver('nb_img1_support', 0, 'Support'); return true" onmouseout="nb_imgNormal('nb_img1_support'); return true" onfocus="nb_imgOver('nb_img1_support', 0, 'Support'); return true" onblur="nb_imgNormal('nb_img1_support'); return true"><img name="nb_img1_support" src="../../images/page-navbar-su-n.jpg" alt="Support" border="0" width="100" height="27"></a></td></tr>
<tr><td><a href="../../related/index.html" onmouseover="nb_imgOver('nb_img1_related', 0, 'Related'); return true" onmouseout="nb_imgNormal('nb_img1_related'); return true" onfocus="nb_imgOver('nb_img1_related', 0, 'Related'); return true" onblur="nb_imgNormal('nb_img1_related'); return true"><img name="nb_img1_related" src="../../images/page-navbar-re-n.jpg" alt="Related" border="0" width="100" height="27"></a></td></tr>
    <tr><td><img src="../../images/page-navbar-bot.jpg" alt="" width="100" height="150"><br><p></td></tr>
  </table>
</td><td align="left" valign="top" width="20" bgcolor="#ffffff">&nbsp;</td><td align="left" valign="top" bgcolor="#ffffff"><br>
        
<h1>lhash(3)</h1>
<!-- INDEX BEGIN -->
<UL>
	<LI><A HREF="lhash.html#NAME">NAME</A>
	<LI><A HREF="lhash.html#SYNOPSIS">SYNOPSIS</A>
	<LI><A HREF="lhash.html#DESCRIPTION">DESCRIPTION</A>
	<LI><A HREF="lhash.html#RETURN_VALUES">RETURN VALUES</A>
	<LI><A HREF="lhash.html#NOTE">NOTE</A>
	<LI><A HREF="lhash.html#BUGS">BUGS</A>
	<LI><A HREF="lhash.html#INTERNALS">INTERNALS</A>
	<LI><A HREF="lhash.html#SEE_ALSO">SEE ALSO</A>
	<LI><A HREF="lhash.html#HISTORY">HISTORY</A>
</UL>
<!-- INDEX END -->
<HR>
<P>
<HR>
<H1><A NAME="NAME">NAME</A></H1>
<P>
lh_new, lh_free, lh_insert, lh_delete, lh_retrieve, lh_doall, lh_doall_arg,
lh_error - dynamic hash table
</P>
<P>
<HR>
<H1><A NAME="SYNOPSIS">SYNOPSIS</A></H1>
<PRE> #include &lt;openssl/lhash.h&gt;
</PRE>
<PRE> DECLARE_LHASH_OF(&lt;type&gt;);
</PRE>
<PRE> LHASH *lh_&lt;type&gt;_new();
 void lh_&lt;type&gt;_free(LHASH_OF(&lt;type&gt; *table);
</PRE>
<PRE> &lt;type&gt; *lh_&lt;type&gt;_insert(LHASH_OF(&lt;type&gt; *table, &lt;type&gt; *data);
 &lt;type&gt; *lh_&lt;type&gt;_delete(LHASH_OF(&lt;type&gt; *table, &lt;type&gt; *data);
 &lt;type&gt; *lh_retrieve(LHASH_OF&lt;type&gt; *table, &lt;type&gt; *data);
</PRE>
<PRE> void lh_&lt;type&gt;_doall(LHASH_OF(&lt;type&gt; *table, LHASH_DOALL_FN_TYPE func);
 void lh_&lt;type&gt;_doall_arg(LHASH_OF(&lt;type&gt; *table, LHASH_DOALL_ARG_FN_TYPE func,
          &lt;type2&gt;, &lt;type2&gt; *arg);
</PRE>
<PRE> int lh_&lt;type&gt;_error(LHASH_OF(&lt;type&gt; *table);
</PRE>
<PRE> typedef int (*LHASH_COMP_FN_TYPE)(const void *, const void *);
 typedef unsigned long (*LHASH_HASH_FN_TYPE)(const void *);
 typedef void (*LHASH_DOALL_FN_TYPE)(const void *);
 typedef void (*LHASH_DOALL_ARG_FN_TYPE)(const void *, const void *);
</PRE>
<P>
<HR>
<H1><A NAME="DESCRIPTION">DESCRIPTION</A></H1>
<P>
This library implements type-checked dynamic hash tables. The hash table
entries can be arbitrary structures. Usually they consist of key and value
fields.
</P>
<P>
lh_&lt;type&gt;_new() creates a new <STRONG>LHASH_OF(<type</STRONG>&gt; structure to store arbitrary data entries, and provides the 'hash' and
'compare' callbacks to be used in organising the table's entries. The <STRONG>hash</STRONG>
callback takes a pointer to a table entry as its argument and returns an
unsigned long hash value for its key field. The hash value is normally
truncated to a power of 2, so make sure that your hash function returns
well mixed low order bits. The <STRONG>compare</STRONG> callback takes two arguments (pointers to two hash table entries), and
returns 0 if their keys are equal, non-zero otherwise. If your hash table
will contain items of some particular type and the <STRONG>hash</STRONG> and
<STRONG>compare</STRONG> callbacks hash/compare these types, then the
<STRONG>DECLARE_LHASH_HASH_FN</STRONG> and <STRONG>IMPLEMENT_LHASH_COMP_FN</STRONG> macros can be used to create callback wrappers of the prototypes required
by lh_&lt;type&gt;_new(). These provide per-variable casts before calling
the type-specific callbacks written by the application author. These
macros, as well as those used for the ``doall'' callbacks, are defined as;
</P>
<PRE> #define DECLARE_LHASH_HASH_FN(name, o_type) \
         unsigned long name##_LHASH_HASH(const void *);
 #define IMPLEMENT_LHASH_HASH_FN(name, o_type) \
         unsigned long name##_LHASH_HASH(const void *arg) { \
                 const o_type *a = arg; \
                 return name##_hash(a); }
 #define LHASH_HASH_FN(name) name##_LHASH_HASH
</PRE>
<PRE> #define DECLARE_LHASH_COMP_FN(name, o_type) \
         int name##_LHASH_COMP(const void *, const void *);
 #define IMPLEMENT_LHASH_COMP_FN(name, o_type) \
         int name##_LHASH_COMP(const void *arg1, const void *arg2) { \
                 const o_type *a = arg1;                    \
                 const o_type *b = arg2; \
                 return name##_cmp(a,b); }
 #define LHASH_COMP_FN(name) name##_LHASH_COMP
</PRE>
<PRE> #define DECLARE_LHASH_DOALL_FN(name, o_type) \
         void name##_LHASH_DOALL(void *);
 #define IMPLEMENT_LHASH_DOALL_FN(name, o_type) \
         void name##_LHASH_DOALL(void *arg) { \
                 o_type *a = arg; \
                 name##_doall(a); }
 #define LHASH_DOALL_FN(name) name##_LHASH_DOALL
</PRE>
<PRE> #define DECLARE_LHASH_DOALL_ARG_FN(name, o_type, a_type) \
         void name##_LHASH_DOALL_ARG(void *, void *);
 #define IMPLEMENT_LHASH_DOALL_ARG_FN(name, o_type, a_type) \
         void name##_LHASH_DOALL_ARG(void *arg1, void *arg2) { \
                 o_type *a = arg1; \
                 a_type *b = arg2; \
                 name##_doall_arg(a, b); }
 #define LHASH_DOALL_ARG_FN(name) name##_LHASH_DOALL_ARG
</PRE>
<PRE> An example of a hash table storing (pointers to) structures of type 'STUFF'
 could be defined as follows;
</PRE>
<PRE> /* Calculates the hash value of 'tohash' (implemented elsewhere) */
 unsigned long STUFF_hash(const STUFF *tohash);
 /* Orders 'arg1' and 'arg2' (implemented elsewhere) */
 int stuff_cmp(const STUFF *arg1, const STUFF *arg2);
 /* Create the type-safe wrapper functions for use in the LHASH internals */
 static IMPLEMENT_LHASH_HASH_FN(stuff, STUFF);
 static IMPLEMENT_LHASH_COMP_FN(stuff, STUFF);
 /* ... */
 int main(int argc, char *argv&#91;&#93;) {
         /* Create the new hash table using the hash/compare wrappers */
         LHASH_OF(STUFF) *hashtable = lh_STUFF_new(LHASH_HASH_FN(STUFF_hash),
                                   LHASH_COMP_FN(STUFF_cmp));
         /* ... */
 }
</PRE>
<P>
lh_&lt;type&gt;_free() frees the <STRONG>LHASH_OF(<type</STRONG>&gt; structure
<STRONG>table</STRONG>. Allocated hash table entries will not be freed; consider using
lh_&lt;type&gt;_doall() to deallocate any remaining entries in the hash
table (see below).
</P>
<P>
lh_&lt;type&gt;_insert() inserts the structure pointed to by <STRONG>data</STRONG> into
<STRONG>table</STRONG>. If there already is an entry with the same key, the old value is
replaced. Note that lh_&lt;type&gt;_insert() stores pointers, the data are
not copied.
</P>
<P>
lh_&lt;type&gt;_delete() deletes an entry from <STRONG>table</STRONG>.
</P>
<P>
lh_&lt;type&gt;_retrieve() looks up an entry in <STRONG>table</STRONG>. Normally, <STRONG>data</STRONG>
is a structure with the key <CODE>field(s)</CODE> set; the function will
return a pointer to a fully populated structure.
</P>
<P>
lh_&lt;type&gt;_doall() will, for every entry in the hash table, call
<STRONG>func</STRONG> with the data item as its parameter. For lh_&lt;type&gt;_doall() and lh_&lt;type&gt;_doall_arg(), function pointer casting should be avoided in the
callbacks (see <STRONG>NOTE</STRONG>) - instead use the declare/implement macros to create type-checked
wrappers that cast variables prior to calling your type-specific callbacks.
An example of this is illustrated here where the callback is used to
cleanup resources for items in the hash table prior to the hashtable itself
being deallocated:
</P>
<PRE> /* Cleans up resources belonging to 'a' (this is implemented elsewhere) */
 void STUFF_cleanup_doall(STUFF *a);
 /* Implement a prototype-compatible wrapper for &quot;STUFF_cleanup&quot; */
 IMPLEMENT_LHASH_DOALL_FN(STUFF_cleanup, STUFF)
         /* ... then later in the code ... */
 /* So to run &quot;STUFF_cleanup&quot; against all items in a hash table ... */
 lh_STUFF_doall(hashtable, LHASH_DOALL_FN(STUFF_cleanup));
 /* Then the hash table itself can be deallocated */
 lh_STUFF_free(hashtable);
</PRE>
<P>
When doing this, be careful if you delete entries from the hash table in
your callbacks: the table may decrease in size, moving the item that you
are currently on down lower in the hash table - this could cause some
entries to be skipped during the iteration. The second best solution to
this problem is to set hash-&gt;down_load=0 before you start (which will stop the hash table ever
decreasing in size). The best solution is probably to avoid deleting items
from the hash table inside a ``doall'' callback!
</P>
<P>
lh_&lt;type&gt;_doall_arg() is the same as lh_&lt;type&gt;_doall() except that
<STRONG>func</STRONG> will be called with <STRONG>arg</STRONG> as the second argument and <STRONG>func</STRONG>
should be of type <STRONG>LHASH_DOALL_ARG_FN_TYPE</STRONG> (a callback prototype that is passed both the table entry and an extra
argument). As with <CODE>lh_doall(),</CODE> you can instead choose to
declare your callback with a prototype matching the types you are dealing
with and use the declare/implement macros to create compatible wrappers
that cast variables before calling your type-specific callbacks. An example
of this is demonstrated here (printing all hash table entries to a BIO that
is provided by the caller):
</P>
<PRE> /* Prints item 'a' to 'output_bio' (this is implemented elsewhere) */
 void STUFF_print_doall_arg(const STUFF *a, BIO *output_bio);
 /* Implement a prototype-compatible wrapper for &quot;STUFF_print&quot; */
 static IMPLEMENT_LHASH_DOALL_ARG_FN(STUFF, const STUFF, BIO)
         /* ... then later in the code ... */
 /* Print out the entire hashtable to a particular BIO */
 lh_STUFF_doall_arg(hashtable, LHASH_DOALL_ARG_FN(STUFF_print), BIO,
                    logging_bio);
 
lh_&lt;type&gt;_error() can be used to determine if an error occurred in the last
operation. lh_&lt;type&gt;_error() is a macro.
</PRE>
<P>
<HR>
<H1><A NAME="RETURN_VALUES">RETURN VALUES</A></H1>
<P>
lh_&lt;type&gt;_new() returns <STRONG>NULL</STRONG> on error, otherwise a pointer to the new
<STRONG>LHASH</STRONG> structure.
</P>
<P>
When a hash table entry is replaced, lh_&lt;type&gt;_insert() returns the value being replaced. <STRONG>NULL</STRONG> is returned on normal operation and on error.
</P>
<P>
lh_&lt;type&gt;_delete() returns the entry being deleted. <STRONG>NULL</STRONG> is returned if there is no such value in the hash table.
</P>
<P>
lh_&lt;type&gt;_retrieve() returns the hash table entry if it has been found,
<STRONG>NULL</STRONG> otherwise.
</P>
<P>
lh_&lt;type&gt;_error() returns 1 if an error occurred in the last
operation, 0 otherwise.
</P>
<P>
lh_&lt;type&gt;_free(), lh_&lt;type&gt;_doall() and
lh_&lt;type&gt;_doall_arg() return no values.
</P>
<P>
<HR>
<H1><A NAME="NOTE">NOTE</A></H1>
<P>
The various LHASH macros and callback types exist to make it possible to
write type-checked code without resorting to function-prototype casting -
an evil that makes application code much harder to audit/verify and also
opens the window of opportunity for stack corruption and other hard-to-find
bugs. It also, apparently, violates ANSI-C.
</P>
<P>
The LHASH code regards table entries as constant data. As such, it
internally represents <CODE>lh_insert()'d</CODE> items with a ``const void
*'' pointer type. This is why callbacks such as those used by
<CODE>lh_doall()</CODE> and <CODE>lh_doall_arg()</CODE> declare their
prototypes with ``const'', even for the parameters that pass back the table
items' data pointers - for consistency, user-provided data is ``const'' at
all times as far as the LHASH code is concerned. However, as callers are
themselves providing these pointers, they can choose whether they too
should be treating all such parameters as constant.
</P>
<P>
As an example, a hash table may be maintained by code that, for reasons of
encapsulation, has only ``const'' access to the data being indexed in the
hash table (ie. it is returned as ``const'' from elsewhere in their code) -
in this case the LHASH prototypes are appropriate as-is. Conversely, if the
caller is responsible for the life-time of the data in question, then they
may well wish to make modifications to table item passed back in the
<CODE>lh_doall()</CODE> or <CODE>lh_doall_arg()</CODE> callbacks (see the
``STUFF_cleanup'' example above). If so, the caller can either cast the
``const'' away (if they're providing the raw callbacks themselves) or use
the macros to declare/implement the wrapper functions without ``const''
types.
</P>
<P>
Callers that only have ``const'' access to data they're indexing in a
table, yet declare callbacks without constant types (or cast the ``const''
away themselves), are therefore creating their own risks/bugs without being
encouraged to do so by the API. On a related note, those auditing code
should pay special attention to any instances of
DECLARE/IMPLEMENT_LHASH_DOALL_&#91;ARG_&#93;_FN macros that provide types without
any ``const'' qualifiers.
</P>
<P>
<HR>
<H1><A NAME="BUGS">BUGS</A></H1>
<P>
lh_&lt;type&gt;_insert() returns <STRONG>NULL</STRONG> both for success and error.
</P>
<P>
<HR>
<H1><A NAME="INTERNALS">INTERNALS</A></H1>
<P>
The following description is based on the SSLeay documentation:
</P>
<P>
The <STRONG>lhash</STRONG> library implements a hash table described in the
<EM>Communications of the ACM</EM> in 1991. What makes this hash table different is that as the table fills,
the hash table is increased (or decreased) in size via
<CODE>OPENSSL_realloc().</CODE> When a 'resize' is done, instead of all
hashes being redistributed over twice as many 'buckets', one bucket is
split. So when an 'expand' is done, there is only a minimal cost to
redistribute some values. Subsequent inserts will cause more single
'bucket' redistributions but there will never be a sudden large cost due to
redistributing all the 'buckets'.
</P>
<P>
The state for a particular hash table is kept in the <STRONG>LHASH</STRONG> structure. The decision to increase or decrease the hash table size is made
depending on the 'load' of the hash table. The load is the number of items
in the hash table divided by the size of the hash table. The default values
are as follows. If (hash-&gt;up_load &lt; load) =&gt;
expand. if (hash-&gt;down_load &gt; load) =&gt; contract. The
<STRONG>up_load</STRONG> has a default value of 1 and <STRONG>down_load</STRONG> has a default value of 2. These numbers can be modified by the application
by just playing with the <STRONG>up_load</STRONG> and <STRONG>down_load</STRONG> variables. The 'load' is kept in a form which is multiplied by 256. So
hash-&gt;up_load=8*256; will cause a load of 8 to be set.
</P>
<P>
If you are interested in performance the field to watch is num_comp_calls.
The hash library keeps track of the 'hash' value for each item so when a
lookup is done, the 'hashes' are compared, if there is a match, then a full
compare is done, and hash-&gt;num_comp_calls is incremented. If num_comp_calls is not equal to num_delete
plus num_retrieve it means that your hash function is generating hashes
that are the same for different values. It is probably worth changing your
hash function if this is the case because even if your hash table has 10
items in a 'bucket', it can be searched with 10 <STRONG>unsigned long</STRONG> compares and 10 linked list traverses. This will be much less expensive
that 10 calls to your compare function.
</P>
<P>
<CODE>lh_strhash()</CODE> is a demo string hashing function:
</P>
<PRE> unsigned long lh_strhash(const char *c);
</PRE>
<P>
Since the <STRONG>LHASH</STRONG> routines would normally be passed structures, this routine would not
normally be passed to lh_&lt;type&gt;_new(), rather it would be used in the
function passed to lh_&lt;type&gt;_new().
</P>
<P>
<HR>
<H1><A NAME="SEE_ALSO">SEE ALSO</A></H1>
<P>
<A HREF="lh_stats.html#">lh_stats(3)</A>
</P>
<P>
<HR>
<H1><A NAME="HISTORY">HISTORY</A></H1>
<P>
The <STRONG>lhash</STRONG> library is available in all versions of SSLeay and OpenSSL.
<CODE>lh_error()</CODE> was added in SSLeay 0.9.1b.
</P>
<P>
This manpage is derived from the SSLeay documentation.
</P>
<P>
In OpenSSL 0.9.7, all lhash functions that were passed function pointers
were changed for better type safety, and the function types
LHASH_COMP_FN_TYPE, LHASH_HASH_FN_TYPE, LHASH_DOALL_FN_TYPE and
LHASH_DOALL_ARG_FN_TYPE became available.
</P>
<P>
In OpenSSL 1.0.0, the lhash interface was revamped for even better type
checking.
</P>
        </td><td align="right" width="20" bgcolor="#ffffff">&nbsp;&nbsp;&nbsp;</td><td align="right" width="50" bgcolor="#666699">&nbsp;</td></tr>
  <tr><td align="left" valign="top" width="100" bgcolor="#666699">&nbsp;</td><td align="left" width="20"><img src="../../images/page-corner-bl.gif" alt="" width="20" height="20"></td><td align="left" valign="top" bgcolor="#ffffff">&nbsp;</td><td align="right" width="20"><img src="../../images/page-corner-br.gif" alt="" width="20" height="20"></td><td align="right" width="50" bgcolor="#666699">&nbsp;</td></tr>
  <tr><td colspan="5" bgcolor="#666699">&nbsp;</td></tr>
</table>
</body>
</html>

