<html>
<head>
<!--
     Copyright (c) 1998-2014 The OpenSSL Project, http://www.openssl.org/
     Author:   OpenSSL (openssl@openssl.org)
     Modified: 2014-07-17 14:00:17.
     Generated from ``pem.wml'' via WML 2.0.11 (19-Aug-2006).
               by OpenSSL (openssl@openssl.org)
               on 2014-07-17 14:01:09.

     DO NOT EDIT THIS FILE DIRECTLY! INSTEAD EDIT ``pem.wml''.
-->
<meta name="Copyright" content="1998-2014 The OpenSSL Project, http://www.openssl.org/">
<meta name="Author"    content="OpenSSL, openssl@openssl.org">
<meta name="Generator" content="WML 2.0.11 (19-Aug-2006)">
<meta name="Modified"  content="2014-07-17 14:00:17">
<title>OpenSSL: Documents, pem(3)</title>
<style type="text/css"><!--
BODY { position: absolute; left: 0px; top: 0px; background: #666699; }
A { text-decoration: none; font-weight: bold; }
A:link { text-decoration: none; font-weight: bold; color: #666699; }
A:visited { text-decoration: none; font-weight: bold; color: #666699; }
A:hover { text-decoration: none; font-weight: bold; color: #666699; text-decoration: underline; }
#red { color: #cc3333; }
#sf { font-family: arial,helvetica; font-variant: normal; font-style: normal; }
#sfl { font-weight: bold; font-family: arial,helvetica; font-size: 16pt; line-height: 16pt; font-variant: normal; font-style: normal; }
H1 { font-weight: bold; font-size: 18pt; line-height: 18pt; font-family: arial,helvetica; font-variant: normal; font-style: normal; }
H2 { font-weight: bold; font-size: 14pt; line-height: 14pt; font-family: arial,helvetica; font-variant: normal; font-style: normal; }
H3 { font-weight: bold; font-size: 12pt; line-height: 12pt; font-family: arial,helvetica; font-variant: normal; font-style: normal; }
--></style>
</head>
<body link="#6666cc" alink="#6666cc" vlink="#6666cc" bgcolor="#666699" text="#000000"
      marginheight="0" leftmargin="0" rightmargin="0" topmargin="0">
<table width="100%" cellspacing="0" cellpadding="0" border="0" summary="">
  <tr><td align="left" width="100" bgcolor="#666699"><img src="../../images/page-head-tl.jpg" alt="OpenSSL" width="100" height="80"></td><td align="left" colspan="2" width="600" bgcolor="#666699"><img src="../../images/page-head-tm.jpg" alt="" width="600" height="80"></td><td align="right" width="20" bgcolor="#666699">&nbsp;&nbsp;&nbsp;</td><td align="right" width="50" bgcolor="#666699">&nbsp;</td></tr>
  <tr><td align="left" width="100"><img src="../../images/page-head-bl.jpg" alt="" width="100" height="20"></td><td align="left" width="20"><img src="../../images/page-head-bm.jpg" alt="" width="20" height="20"></td><td align="left" width="100%" bgcolor="#ffffff">
<table cellspacing="0" cellpadding="0" border="0" summary="">
        <tr>
<td><font face="Arial,Helvetica">&nbsp;<a href="../index.html" onmouseover="self.status = '../'; return true" onmouseout="self.status = ''; return true" onfocus="self.status = '../'; return true" onblur="self.status = ''; return true"><font color="#666666">Documents</font></a></font>&nbsp;</td><td>|</td>
<td><font face="Arial,Helvetica">&nbsp;<a href="../apps/openssl.html" onmouseover="self.status = '../apps/openssl.html'; return true" onmouseout="self.status = ''; return true" onfocus="self.status = '../apps/openssl.html'; return true" onblur="self.status = ''; return true"><font color="#666666">openssl(1)</font></a></font>&nbsp;</td><td>|</td>
<td><font face="Arial,Helvetica">&nbsp;<a href="../ssl/ssl.html" onmouseover="self.status = '../ssl/ssl.html'; return true" onmouseout="self.status = ''; return true" onfocus="self.status = '../ssl/ssl.html'; return true" onblur="self.status = ''; return true"><font color="#666666">ssl(3)</font></a></font>&nbsp;</td><td>|</td>
<td><font face="Arial,Helvetica">&nbsp;<a href="crypto.html" onmouseover="self.status = '../crypto/crypto.html'; return true" onmouseout="self.status = ''; return true" onfocus="self.status = '../crypto/crypto.html'; return true" onblur="self.status = ''; return true"><font color="#666666">crypto(3)</font></a></font>&nbsp;</td><td>|</td>
<td><font face="Arial,Helvetica">&nbsp;<a href="../HOWTO/index.html" onmouseover="self.status = '../HOWTO/'; return true" onmouseout="self.status = ''; return true" onfocus="self.status = '../HOWTO/'; return true" onblur="self.status = ''; return true"><font color="#666666">HOWTO</font></a></font>&nbsp;</td><td>|</td>
<td><font face="Arial,Helvetica">&nbsp;<a href="http://wiki.openssl.org/" onmouseover="self.status = 'http://wiki.openssl.org/'; return true" onmouseout="self.status = ''; return true" onfocus="self.status = 'http://wiki.openssl.org/'; return true" onblur="self.status = ''; return true"><font color="#666666">Wiki</font></a></font>&nbsp;</td><td>|</td>
<td><font face="Arial,Helvetica">&nbsp;<a href="../fips/index.html" onmouseover="self.status = '../fips/'; return true" onmouseout="self.status = ''; return true" onfocus="self.status = '../fips/'; return true" onblur="self.status = ''; return true"><font color="#666666">FIPS140</font></a></font>&nbsp;</td><td>|</td>
<td><font face="Arial,Helvetica">&nbsp;<a href="../misc/index.html" onmouseover="self.status = '../misc/'; return true" onmouseout="self.status = ''; return true" onfocus="self.status = '../misc/'; return true" onblur="self.status = ''; return true"><font color="#666666">misc</font></a></font>&nbsp;</td><td></td>
</tr>
      </table>
</td><td align="right" width="20"><img src="../../images/page-corner-tr.gif" alt="" width="20" height="20"></td><td align="right" width="50" bgcolor="#666699">&nbsp;</td></tr>
  <tr><td align="left" valign="top" width="100" bgcolor="#666699"><table cellspacing="0" cellpadding="0" border="0" summary=""><tr><td><img src="../../images/page-navbar-top.jpg" alt="" width="100" height="11"></td></tr>
<script type="text/javascript" language="JavaScript">
<!-- Hiding the code
function nb_imgNormal(imgName) {
    if (document.images) {
        document[imgName].src = eval(imgName + '_n.src');
        self.status = '';
    }
}
function nb_imgSelect(imgName) {
    if (document.images) {
        document[imgName].src = eval(imgName + '_s.src');
        self.status = '';
    }
}
function nb_imgOver(imgName, nohints, descript) {
    if (document.images) {
        document[imgName].src = eval(imgName + '_o.src');
        if (! nohints) self.status = descript;
    }
}
// done hiding -->
</script>
<script type="text/javascript" language="JavaScript">
<!-- Hiding the code
if (document.images) {
    nb_img1_title_n = new Image();
    nb_img1_title_n.src = '../../images/page-navbar-ti-n.jpg';
    nb_img1_title_o = new Image();
    nb_img1_title_o.src = '../../images/page-navbar-ti-s.jpg';
    nb_img1_FAQ_n = new Image();
    nb_img1_FAQ_n.src = '../../images/page-navbar-fq-n.jpg';
    nb_img1_FAQ_o = new Image();
    nb_img1_FAQ_o.src = '../../images/page-navbar-fq-s.jpg';
    nb_img1_about_n = new Image();
    nb_img1_about_n.src = '../../images/page-navbar-ab-n.jpg';
    nb_img1_about_o = new Image();
    nb_img1_about_o.src = '../../images/page-navbar-ab-s.jpg';
    nb_img1_news_n = new Image();
    nb_img1_news_n.src = '../../images/page-navbar-ne-n.jpg';
    nb_img1_news_o = new Image();
    nb_img1_news_o.src = '../../images/page-navbar-ne-s.jpg';
    nb_img1_docs_s = new Image();
    nb_img1_docs_s.src = '../../images/page-navbar-do-s.jpg';
    nb_img1_docs_o = new Image();
    nb_img1_docs_o.src = '../../images/page-navbar-do-s.jpg';
    nb_img1_source_n = new Image();
    nb_img1_source_n.src = '../../images/page-navbar-so-n.jpg';
    nb_img1_source_o = new Image();
    nb_img1_source_o.src = '../../images/page-navbar-so-s.jpg';
    nb_img1_contrib_n = new Image();
    nb_img1_contrib_n.src = '../../images/page-navbar-co-n.jpg';
    nb_img1_contrib_o = new Image();
    nb_img1_contrib_o.src = '../../images/page-navbar-co-s.jpg';
    nb_img1_support_n = new Image();
    nb_img1_support_n.src = '../../images/page-navbar-su-n.jpg';
    nb_img1_support_o = new Image();
    nb_img1_support_o.src = '../../images/page-navbar-su-s.jpg';
    nb_img1_related_n = new Image();
    nb_img1_related_n.src = '../../images/page-navbar-re-n.jpg';
    nb_img1_related_o = new Image();
    nb_img1_related_o.src = '../../images/page-navbar-re-s.jpg';
}
// done hiding -->
</script>
<tr><td><a href="../../index.html" onmouseover="nb_imgOver('nb_img1_title', 0, 'Title'); return true" onmouseout="nb_imgNormal('nb_img1_title'); return true" onfocus="nb_imgOver('nb_img1_title', 0, 'Title'); return true" onblur="nb_imgNormal('nb_img1_title'); return true"><img name="nb_img1_title" src="../../images/page-navbar-ti-n.jpg" alt="Title" border="0" width="100" height="27"></a></td></tr>
<tr><td><a href="../../support/faq.html" onmouseover="nb_imgOver('nb_img1_FAQ', 0, 'FAQ'); return true" onmouseout="nb_imgNormal('nb_img1_FAQ'); return true" onfocus="nb_imgOver('nb_img1_FAQ', 0, 'FAQ'); return true" onblur="nb_imgNormal('nb_img1_FAQ'); return true"><img name="nb_img1_FAQ" src="../../images/page-navbar-fq-n.jpg" alt="FAQ" border="0" width="100" height="27"></a></td></tr>
<tr><td><a href="../../about/index.html" onmouseover="nb_imgOver('nb_img1_about', 0, 'About'); return true" onmouseout="nb_imgNormal('nb_img1_about'); return true" onfocus="nb_imgOver('nb_img1_about', 0, 'About'); return true" onblur="nb_imgNormal('nb_img1_about'); return true"><img name="nb_img1_about" src="../../images/page-navbar-ab-n.jpg" alt="About" border="0" width="100" height="27"></a></td></tr>
<tr><td><a href="../../news/index.html" onmouseover="nb_imgOver('nb_img1_news', 0, 'News'); return true" onmouseout="nb_imgNormal('nb_img1_news'); return true" onfocus="nb_imgOver('nb_img1_news', 0, 'News'); return true" onblur="nb_imgNormal('nb_img1_news'); return true"><img name="nb_img1_news" src="../../images/page-navbar-ne-n.jpg" alt="News" border="0" width="100" height="27"></a></td></tr>
<tr><td><a href="../index.html" onmouseover="nb_imgOver('nb_img1_docs', 0, 'Documents'); return true" onmouseout="nb_imgSelect('nb_img1_docs'); return true" onfocus="nb_imgOver('nb_img1_docs', 0, 'Documents'); return true" onblur="nb_imgSelect('nb_img1_docs'); return true"><img name="nb_img1_docs" src="../../images/page-navbar-do-s.jpg" alt="Documents" border="0" width="100" height="27"></a></td></tr>
<tr><td><a href="../../source/index.html" onmouseover="nb_imgOver('nb_img1_source', 0, 'Source'); return true" onmouseout="nb_imgNormal('nb_img1_source'); return true" onfocus="nb_imgOver('nb_img1_source', 0, 'Source'); return true" onblur="nb_imgNormal('nb_img1_source'); return true"><img name="nb_img1_source" src="../../images/page-navbar-so-n.jpg" alt="Source" border="0" width="100" height="27"></a></td></tr>
<tr><td><a href="../../contrib/index.html" onmouseover="nb_imgOver('nb_img1_contrib', 0, 'Contribution'); return true" onmouseout="nb_imgNormal('nb_img1_contrib'); return true" onfocus="nb_imgOver('nb_img1_contrib', 0, 'Contribution'); return true" onblur="nb_imgNormal('nb_img1_contrib'); return true"><img name="nb_img1_contrib" src="../../images/page-navbar-co-n.jpg" alt="Contribution" border="0" width="100" height="27"></a></td></tr>
<tr><td><a href="../../support/index.html" onmouseover="nb_imgOver('nb_img1_support', 0, 'Support'); return true" onmouseout="nb_imgNormal('nb_img1_support'); return true" onfocus="nb_imgOver('nb_img1_support', 0, 'Support'); return true" onblur="nb_imgNormal('nb_img1_support'); return true"><img name="nb_img1_support" src="../../images/page-navbar-su-n.jpg" alt="Support" border="0" width="100" height="27"></a></td></tr>
<tr><td><a href="../../related/index.html" onmouseover="nb_imgOver('nb_img1_related', 0, 'Related'); return true" onmouseout="nb_imgNormal('nb_img1_related'); return true" onfocus="nb_imgOver('nb_img1_related', 0, 'Related'); return true" onblur="nb_imgNormal('nb_img1_related'); return true"><img name="nb_img1_related" src="../../images/page-navbar-re-n.jpg" alt="Related" border="0" width="100" height="27"></a></td></tr>
    <tr><td><img src="../../images/page-navbar-bot.jpg" alt="" width="100" height="150"><br><p></td></tr>
  </table>
</td><td align="left" valign="top" width="20" bgcolor="#ffffff">&nbsp;</td><td align="left" valign="top" bgcolor="#ffffff"><br>
        
<h1>pem(3)</h1>
<!-- INDEX BEGIN -->
<UL>
	<LI><A HREF="pem.html#NAME">NAME</A>
	<LI><A HREF="pem.html#SYNOPSIS">SYNOPSIS</A>
	<LI><A HREF="pem.html#DESCRIPTION">DESCRIPTION</A>
	<LI><A HREF="pem.html#PEM_FUNCTION_ARGUMENTS">PEM FUNCTION ARGUMENTS</A>
	<LI><A HREF="pem.html#EXAMPLES">EXAMPLES</A>
	<LI><A HREF="pem.html#NOTES">NOTES</A>
	<LI><A HREF="pem.html#PEM_ENCRYPTION_FORMAT">PEM ENCRYPTION FORMAT</A>
	<LI><A HREF="pem.html#BUGS">BUGS</A>
	<LI><A HREF="pem.html#RETURN_CODES">RETURN CODES</A>
	<LI><A HREF="pem.html#SEE_ALSO">SEE ALSO</A>
</UL>
<!-- INDEX END -->
<HR>
<P>
<HR>
<H1><A NAME="NAME">NAME</A></H1>
<P>
PEM, PEM_read_bio_PrivateKey, PEM_read_PrivateKey,
PEM_write_bio_PrivateKey, PEM_write_PrivateKey,
PEM_write_bio_PKCS8PrivateKey, PEM_write_PKCS8PrivateKey,
PEM_write_bio_PKCS8PrivateKey_nid, PEM_write_PKCS8PrivateKey_nid,
PEM_read_bio_PUBKEY, PEM_read_PUBKEY, PEM_write_bio_PUBKEY,
PEM_write_PUBKEY, PEM_read_bio_RSAPrivateKey, PEM_read_RSAPrivateKey,
PEM_write_bio_RSAPrivateKey, PEM_write_RSAPrivateKey,
PEM_read_bio_RSAPublicKey, PEM_read_RSAPublicKey,
PEM_write_bio_RSAPublicKey, PEM_write_RSAPublicKey,
PEM_read_bio_RSA_PUBKEY, PEM_read_RSA_PUBKEY, PEM_write_bio_RSA_PUBKEY,
PEM_write_RSA_PUBKEY, PEM_read_bio_DSAPrivateKey, PEM_read_DSAPrivateKey,
PEM_write_bio_DSAPrivateKey, PEM_write_DSAPrivateKey,
PEM_read_bio_DSA_PUBKEY, PEM_read_DSA_PUBKEY, PEM_write_bio_DSA_PUBKEY,
PEM_write_DSA_PUBKEY, PEM_read_bio_DSAparams, PEM_read_DSAparams,
PEM_write_bio_DSAparams, PEM_write_DSAparams, PEM_read_bio_DHparams,
PEM_read_DHparams, PEM_write_bio_DHparams, PEM_write_DHparams,
PEM_read_bio_X509, PEM_read_X509, PEM_write_bio_X509, PEM_write_X509,
PEM_read_bio_X509_AUX, PEM_read_X509_AUX, PEM_write_bio_X509_AUX,
PEM_write_X509_AUX, PEM_read_bio_X509_REQ, PEM_read_X509_REQ,
PEM_write_bio_X509_REQ, PEM_write_X509_REQ, PEM_write_bio_X509_REQ_NEW,
PEM_write_X509_REQ_NEW, PEM_read_bio_X509_CRL, PEM_read_X509_CRL,
PEM_write_bio_X509_CRL, PEM_write_X509_CRL, PEM_read_bio_PKCS7,
PEM_read_PKCS7, PEM_write_bio_PKCS7, PEM_write_PKCS7,
PEM_read_bio_NETSCAPE_CERT_SEQUENCE, PEM_read_NETSCAPE_CERT_SEQUENCE,
PEM_write_bio_NETSCAPE_CERT_SEQUENCE, PEM_write_NETSCAPE_CERT_SEQUENCE -
PEM routines
</P>
<P>
<HR>
<H1><A NAME="SYNOPSIS">SYNOPSIS</A></H1>
<PRE> #include &lt;openssl/pem.h&gt;
</PRE>
<PRE> EVP_PKEY *PEM_read_bio_PrivateKey(BIO *bp, EVP_PKEY **x,
                                        pem_password_cb *cb, void *u);
</PRE>
<PRE> EVP_PKEY *PEM_read_PrivateKey(FILE *fp, EVP_PKEY **x,
                                        pem_password_cb *cb, void *u);
</PRE>
<PRE> int PEM_write_bio_PrivateKey(BIO *bp, EVP_PKEY *x, const EVP_CIPHER *enc,
                                        unsigned char *kstr, int klen,
                                        pem_password_cb *cb, void *u);
</PRE>
<PRE> int PEM_write_PrivateKey(FILE *fp, EVP_PKEY *x, const EVP_CIPHER *enc,
                                        unsigned char *kstr, int klen,
                                        pem_password_cb *cb, void *u);
</PRE>
<PRE> int PEM_write_bio_PKCS8PrivateKey(BIO *bp, EVP_PKEY *x, const EVP_CIPHER *enc,
                                        char *kstr, int klen,
                                        pem_password_cb *cb, void *u);
</PRE>
<PRE> int PEM_write_PKCS8PrivateKey(FILE *fp, EVP_PKEY *x, const EVP_CIPHER *enc,
                                        char *kstr, int klen,
                                        pem_password_cb *cb, void *u);
</PRE>
<PRE> int PEM_write_bio_PKCS8PrivateKey_nid(BIO *bp, EVP_PKEY *x, int nid,
                                        char *kstr, int klen,
                                        pem_password_cb *cb, void *u);
</PRE>
<PRE> int PEM_write_PKCS8PrivateKey_nid(FILE *fp, EVP_PKEY *x, int nid,
                                        char *kstr, int klen,
                                        pem_password_cb *cb, void *u);
</PRE>
<PRE> EVP_PKEY *PEM_read_bio_PUBKEY(BIO *bp, EVP_PKEY **x,
                                        pem_password_cb *cb, void *u);
</PRE>
<PRE> EVP_PKEY *PEM_read_PUBKEY(FILE *fp, EVP_PKEY **x,
                                        pem_password_cb *cb, void *u);
</PRE>
<PRE> int PEM_write_bio_PUBKEY(BIO *bp, EVP_PKEY *x);
 int PEM_write_PUBKEY(FILE *fp, EVP_PKEY *x);
</PRE>
<PRE> RSA *PEM_read_bio_RSAPrivateKey(BIO *bp, RSA **x,
                                        pem_password_cb *cb, void *u);
</PRE>
<PRE> RSA *PEM_read_RSAPrivateKey(FILE *fp, RSA **x,
                                        pem_password_cb *cb, void *u);
</PRE>
<PRE> int PEM_write_bio_RSAPrivateKey(BIO *bp, RSA *x, const EVP_CIPHER *enc,
                                        unsigned char *kstr, int klen,
                                        pem_password_cb *cb, void *u);
</PRE>
<PRE> int PEM_write_RSAPrivateKey(FILE *fp, RSA *x, const EVP_CIPHER *enc,
                                        unsigned char *kstr, int klen,
                                        pem_password_cb *cb, void *u);
</PRE>
<PRE> RSA *PEM_read_bio_RSAPublicKey(BIO *bp, RSA **x,
                                        pem_password_cb *cb, void *u);
</PRE>
<PRE> RSA *PEM_read_RSAPublicKey(FILE *fp, RSA **x,
                                        pem_password_cb *cb, void *u);
</PRE>
<PRE> int PEM_write_bio_RSAPublicKey(BIO *bp, RSA *x);
</PRE>
<PRE> int PEM_write_RSAPublicKey(FILE *fp, RSA *x);
</PRE>
<PRE> RSA *PEM_read_bio_RSA_PUBKEY(BIO *bp, RSA **x,
                                        pem_password_cb *cb, void *u);
</PRE>
<PRE> RSA *PEM_read_RSA_PUBKEY(FILE *fp, RSA **x,
                                        pem_password_cb *cb, void *u);
</PRE>
<PRE> int PEM_write_bio_RSA_PUBKEY(BIO *bp, RSA *x);
</PRE>
<PRE> int PEM_write_RSA_PUBKEY(FILE *fp, RSA *x);
</PRE>
<PRE> DSA *PEM_read_bio_DSAPrivateKey(BIO *bp, DSA **x,
                                        pem_password_cb *cb, void *u);
</PRE>
<PRE> DSA *PEM_read_DSAPrivateKey(FILE *fp, DSA **x,
                                        pem_password_cb *cb, void *u);
</PRE>
<PRE> int PEM_write_bio_DSAPrivateKey(BIO *bp, DSA *x, const EVP_CIPHER *enc,
                                        unsigned char *kstr, int klen,
                                        pem_password_cb *cb, void *u);
</PRE>
<PRE> int PEM_write_DSAPrivateKey(FILE *fp, DSA *x, const EVP_CIPHER *enc,
                                        unsigned char *kstr, int klen,
                                        pem_password_cb *cb, void *u);
</PRE>
<PRE> DSA *PEM_read_bio_DSA_PUBKEY(BIO *bp, DSA **x,
                                        pem_password_cb *cb, void *u);
</PRE>
<PRE> DSA *PEM_read_DSA_PUBKEY(FILE *fp, DSA **x,
                                        pem_password_cb *cb, void *u);
</PRE>
<PRE> int PEM_write_bio_DSA_PUBKEY(BIO *bp, DSA *x);
</PRE>
<PRE> int PEM_write_DSA_PUBKEY(FILE *fp, DSA *x);
</PRE>
<PRE> DSA *PEM_read_bio_DSAparams(BIO *bp, DSA **x, pem_password_cb *cb, void *u);
</PRE>
<PRE> DSA *PEM_read_DSAparams(FILE *fp, DSA **x, pem_password_cb *cb, void *u);
</PRE>
<PRE> int PEM_write_bio_DSAparams(BIO *bp, DSA *x);
</PRE>
<PRE> int PEM_write_DSAparams(FILE *fp, DSA *x);
</PRE>
<PRE> DH *PEM_read_bio_DHparams(BIO *bp, DH **x, pem_password_cb *cb, void *u);
</PRE>
<PRE> DH *PEM_read_DHparams(FILE *fp, DH **x, pem_password_cb *cb, void *u);
</PRE>
<PRE> int PEM_write_bio_DHparams(BIO *bp, DH *x);
</PRE>
<PRE> int PEM_write_DHparams(FILE *fp, DH *x);
</PRE>
<PRE> X509 *PEM_read_bio_X509(BIO *bp, X509 **x, pem_password_cb *cb, void *u);
</PRE>
<PRE> X509 *PEM_read_X509(FILE *fp, X509 **x, pem_password_cb *cb, void *u);
</PRE>
<PRE> int PEM_write_bio_X509(BIO *bp, X509 *x);
</PRE>
<PRE> int PEM_write_X509(FILE *fp, X509 *x);
</PRE>
<PRE> X509 *PEM_read_bio_X509_AUX(BIO *bp, X509 **x, pem_password_cb *cb, void *u);
</PRE>
<PRE> X509 *PEM_read_X509_AUX(FILE *fp, X509 **x, pem_password_cb *cb, void *u);
</PRE>
<PRE> int PEM_write_bio_X509_AUX(BIO *bp, X509 *x);
</PRE>
<PRE> int PEM_write_X509_AUX(FILE *fp, X509 *x);
</PRE>
<PRE> X509_REQ *PEM_read_bio_X509_REQ(BIO *bp, X509_REQ **x,
                                        pem_password_cb *cb, void *u);
</PRE>
<PRE> X509_REQ *PEM_read_X509_REQ(FILE *fp, X509_REQ **x,
                                        pem_password_cb *cb, void *u);
</PRE>
<PRE> int PEM_write_bio_X509_REQ(BIO *bp, X509_REQ *x);
</PRE>
<PRE> int PEM_write_X509_REQ(FILE *fp, X509_REQ *x);
</PRE>
<PRE> int PEM_write_bio_X509_REQ_NEW(BIO *bp, X509_REQ *x);
</PRE>
<PRE> int PEM_write_X509_REQ_NEW(FILE *fp, X509_REQ *x);
</PRE>
<PRE> X509_CRL *PEM_read_bio_X509_CRL(BIO *bp, X509_CRL **x,
                                        pem_password_cb *cb, void *u);
 X509_CRL *PEM_read_X509_CRL(FILE *fp, X509_CRL **x,
                                        pem_password_cb *cb, void *u);
 int PEM_write_bio_X509_CRL(BIO *bp, X509_CRL *x);
 int PEM_write_X509_CRL(FILE *fp, X509_CRL *x);
</PRE>
<PRE> PKCS7 *PEM_read_bio_PKCS7(BIO *bp, PKCS7 **x, pem_password_cb *cb, void *u);
</PRE>
<PRE> PKCS7 *PEM_read_PKCS7(FILE *fp, PKCS7 **x, pem_password_cb *cb, void *u);
</PRE>
<PRE> int PEM_write_bio_PKCS7(BIO *bp, PKCS7 *x);
</PRE>
<PRE> int PEM_write_PKCS7(FILE *fp, PKCS7 *x);
</PRE>
<PRE> NETSCAPE_CERT_SEQUENCE *PEM_read_bio_NETSCAPE_CERT_SEQUENCE(BIO *bp,
                                                NETSCAPE_CERT_SEQUENCE **x,
                                                pem_password_cb *cb, void *u);
</PRE>
<PRE> NETSCAPE_CERT_SEQUENCE *PEM_read_NETSCAPE_CERT_SEQUENCE(FILE *fp,
                                                NETSCAPE_CERT_SEQUENCE **x,
                                                pem_password_cb *cb, void *u);
</PRE>
<PRE> int PEM_write_bio_NETSCAPE_CERT_SEQUENCE(BIO *bp, NETSCAPE_CERT_SEQUENCE *x);
</PRE>
<PRE> int PEM_write_NETSCAPE_CERT_SEQUENCE(FILE *fp, NETSCAPE_CERT_SEQUENCE *x);
</PRE>
<P>
<HR>
<H1><A NAME="DESCRIPTION">DESCRIPTION</A></H1>
<P>
The PEM functions read or write structures in PEM format. In this sense PEM
format is simply base64 encoded data surrounded by header lines.
</P>
<P>
For more details about the meaning of arguments see the
<STRONG>PEM FUNCTION ARGUMENTS</STRONG> section.
</P>
<P>
Each operation has four functions associated with it. For clarity the term
``<STRONG>foobar</STRONG> functions'' will be used to collectively refer to the
<CODE>PEM_read_bio_foobar(),</CODE> <CODE>PEM_read_foobar(),</CODE>
<CODE>PEM_write_bio_foobar()</CODE> and <CODE>PEM_write_foobar()</CODE>
functions.
</P>
<P>
The <STRONG>PrivateKey</STRONG> functions read or write a private key in PEM format using an EVP_PKEY
structure. The write routines use ``traditional'' private key format and
can handle both RSA and DSA private keys. The read functions can
additionally transparently handle PKCS#8 format encrypted and unencrypted
keys too.
</P>
<P>
<CODE>PEM_write_bio_PKCS8PrivateKey()</CODE> and
<CODE>PEM_write_PKCS8PrivateKey()</CODE> write a private key in an EVP_PKEY
structure in PKCS#8 EncryptedPrivateKeyInfo format using PKCS#5 v2.0
password based encryption algorithms. The <STRONG>cipher</STRONG> argument specifies the encryption algorithm to use: unlike all other PEM
routines the encryption is applied at the PKCS#8 level and not in the PEM
headers. If <STRONG>cipher</STRONG> is NULL then no encryption is used and a PKCS#8 PrivateKeyInfo structure is
used instead.
</P>
<P>
<CODE>PEM_write_bio_PKCS8PrivateKey_nid()</CODE> and
<CODE>PEM_write_PKCS8PrivateKey_nid()</CODE> also write out a private key
as a PKCS#8 EncryptedPrivateKeyInfo however it uses PKCS#5 v1.5 or PKCS#12
encryption algorithms instead. The algorithm to use is specified in the <STRONG>nid</STRONG> parameter and should be the NID of the corresponding OBJECT IDENTIFIER (see
NOTES section).
</P>
<P>
The <STRONG>PUBKEY</STRONG> functions process a public key using an EVP_PKEY structure. The public key
is encoded as a SubjectPublicKeyInfo structure.
</P>
<P>
The <STRONG>RSAPrivateKey</STRONG> functions process an RSA private key using an RSA structure. It handles the
same formats as the <STRONG>PrivateKey</STRONG>
functions but an error occurs if the private key is not RSA.
</P>
<P>
The <STRONG>RSAPublicKey</STRONG> functions process an RSA public key using an RSA structure. The public key
is encoded using a PKCS#1 RSAPublicKey structure.
</P>
<P>
The <STRONG>RSA_PUBKEY</STRONG> functions also process an RSA public key using an RSA structure. However
the public key is encoded using a SubjectPublicKeyInfo structure and an
error occurs if the public key is not RSA.
</P>
<P>
The <STRONG>DSAPrivateKey</STRONG> functions process a DSA private key using a DSA structure. It handles the
same formats as the <STRONG>PrivateKey</STRONG>
functions but an error occurs if the private key is not DSA.
</P>
<P>
The <STRONG>DSA_PUBKEY</STRONG> functions process a DSA public key using a DSA structure. The public key is
encoded using a SubjectPublicKeyInfo structure and an error occurs if the
public key is not DSA.
</P>
<P>
The <STRONG>DSAparams</STRONG> functions process DSA parameters using a DSA structure. The parameters are
encoded using a foobar structure.
</P>
<P>
The <STRONG>DHparams</STRONG> functions process DH parameters using a DH structure. The parameters are
encoded using a PKCS#3 DHparameter structure.
</P>
<P>
The <STRONG>X509</STRONG> functions process an X509 certificate using an X509 structure. They will
also process a trusted X509 certificate but any trust settings are
discarded.
</P>
<P>
The <STRONG>X509_AUX</STRONG> functions process a trusted X509 certificate using an X509 structure.
</P>
<P>
The <STRONG>X509_REQ</STRONG> and <STRONG>X509_REQ_NEW</STRONG> functions process a PKCS#10 certificate request using an X509_REQ
structure. The <STRONG>X509_REQ</STRONG>
write functions use <STRONG>CERTIFICATE REQUEST</STRONG> in the header whereas the <STRONG>X509_REQ_NEW</STRONG> functions use <STRONG>NEW CERTIFICATE REQUEST</STRONG>
(as required by some CAs). The <STRONG>X509_REQ</STRONG> read functions will handle either form so there are no <STRONG>X509_REQ_NEW</STRONG> read functions.
</P>
<P>
The <STRONG>X509_CRL</STRONG> functions process an X509 CRL using an X509_CRL structure.
</P>
<P>
The <STRONG>PKCS7</STRONG> functions process a PKCS#7 ContentInfo using a PKCS7 structure.
</P>
<P>
The <STRONG>NETSCAPE_CERT_SEQUENCE</STRONG> functions process a Netscape Certificate Sequence using a
NETSCAPE_CERT_SEQUENCE structure.
</P>
<P>
<HR>
<H1><A NAME="PEM_FUNCTION_ARGUMENTS">PEM FUNCTION ARGUMENTS</A></H1>
<P>
The PEM functions have many common arguments.
</P>
<P>
The <STRONG>bp</STRONG> BIO parameter (if present) specifies the BIO to read from or write to.
</P>
<P>
The <STRONG>fp</STRONG> FILE parameter (if present) specifies the FILE pointer to read from or
write to.
</P>
<P>
The PEM read functions all take an argument <STRONG>TYPE **x</STRONG> and return a <STRONG>TYPE *</STRONG> pointer. Where <STRONG>TYPE</STRONG> is whatever structure the function uses. If <STRONG>x</STRONG> is NULL then the parameter is ignored. If <STRONG>x</STRONG> is not NULL but <STRONG>*x</STRONG> is NULL then the structure returned will be written to <STRONG>*x</STRONG>. If neither <STRONG>x</STRONG> nor <STRONG>*x</STRONG> is NULL then an attempt is made to reuse the structure at <STRONG>*x</STRONG> (but see BUGS and EXAMPLES sections). Irrespective of the value of <STRONG>x</STRONG> a pointer to the structure is always returned (or NULL if an error
occurred).
</P>
<P>
The PEM functions which write private keys take an <STRONG>enc</STRONG> parameter which specifies the encryption algorithm to use, encryption is
done at the PEM level. If this parameter is set to NULL then the private
key is written in unencrypted form.
</P>
<P>
The <STRONG>cb</STRONG> argument is the callback to use when querying for the pass phrase used for
encrypted PEM structures (normally only private keys).
</P>
<P>
For the PEM write routines if the <STRONG>kstr</STRONG> parameter is not NULL then
<STRONG>klen</STRONG> bytes at <STRONG>kstr</STRONG> are used as the passphrase and <STRONG>cb</STRONG> is ignored.
</P>
<P>
If the <STRONG>cb</STRONG> parameters is set to NULL and the <STRONG>u</STRONG> parameter is not NULL then the <STRONG>u</STRONG> parameter is interpreted as a null terminated string to use as the
passphrase. If both <STRONG>cb</STRONG> and <STRONG>u</STRONG> are NULL then the default callback routine is used which will typically
prompt for the passphrase on the current terminal with echoing turned off.
</P>
<P>
The default passphrase callback is sometimes inappropriate (for example in
a GUI application) so an alternative can be supplied. The callback routine
has the following form:
</P>
<PRE> int cb(char *buf, int size, int rwflag, void *u);
</PRE>
<P>
<STRONG>buf</STRONG> is the buffer to write the passphrase to. <STRONG>size</STRONG> is the maximum length of the passphrase (i.e. the size of buf). <STRONG>rwflag</STRONG> is a flag which is set to 0 when reading and 1 when writing. A typical
routine will ask the user to verify the passphrase (for example by
prompting for it twice) if <STRONG>rwflag</STRONG> is 1. The <STRONG>u</STRONG> parameter has the same value as the <STRONG>u</STRONG> parameter passed to the PEM routine. It allows arbitrary data to be passed
to the callback by the application (for example a window handle in a GUI
application). The callback
<STRONG>must</STRONG> return the number of characters in the passphrase or 0 if an error
occurred.
</P>
<P>
<HR>
<H1><A NAME="EXAMPLES">EXAMPLES</A></H1>
<P>
Although the PEM routines take several arguments in almost all applications
most of them are set to 0 or NULL.
</P>
<P>
Read a certificate in PEM format from a BIO:
</P>
<PRE> X509 *x;
 x = PEM_read_bio_X509(bp, NULL, 0, NULL);
 if (x == NULL)
        {
        /* Error */
        }
</PRE>
<P>
Alternative method:
</P>
<PRE> X509 *x = NULL;
 if (!PEM_read_bio_X509(bp, &amp;x, 0, NULL))
        {
        /* Error */
        }
</PRE>
<P>
Write a certificate to a BIO:
</P>
<PRE> if (!PEM_write_bio_X509(bp, x))
        {
        /* Error */
        }
</PRE>
<P>
Write an unencrypted private key to a FILE pointer:
</P>
<PRE> if (!PEM_write_PrivateKey(fp, key, NULL, NULL, 0, 0, NULL))
        {
        /* Error */
        }
</PRE>
<P>
Write a private key (using traditional format) to a BIO using triple DES
encryption, the pass phrase is prompted for:
</P>
<PRE> if (!PEM_write_bio_PrivateKey(bp, key, EVP_des_ede3_cbc(), NULL, 0, 0, NULL))
        {
        /* Error */
        }
</PRE>
<P>
Write a private key (using PKCS#8 format) to a BIO using triple DES
encryption, using the pass phrase ``hello'':
</P>
<PRE> if (!PEM_write_bio_PKCS8PrivateKey(bp, key, EVP_des_ede3_cbc(), NULL, 0, 0, &quot;hello&quot;))
        {
        /* Error */
        }
</PRE>
<P>
Read a private key from a BIO using the pass phrase ``hello'':
</P>
<PRE> key = PEM_read_bio_PrivateKey(bp, NULL, 0, &quot;hello&quot;);
 if (key == NULL)
        {
        /* Error */
        }
</PRE>
<P>
Read a private key from a BIO using a pass phrase callback:
</P>
<PRE> key = PEM_read_bio_PrivateKey(bp, NULL, pass_cb, &quot;My Private Key&quot;);
 if (key == NULL)
        {
        /* Error */
        }
</PRE>
<P>
Skeleton pass phrase callback:
</P>
<PRE> int pass_cb(char *buf, int size, int rwflag, void *u);
        {
        int len;
        char *tmp;
        /* We'd probably do something else if 'rwflag' is 1 */
        printf(&quot;Enter pass phrase for \&quot;%s\&quot;\n&quot;, u);
</PRE>
<PRE>        /* get pass phrase, length 'len' into 'tmp' */
        tmp = &quot;hello&quot;;
        len = strlen(tmp);
</PRE>
<PRE>        if (len &lt;= 0) return 0;
        /* if too long, truncate */
        if (len &gt; size) len = size;
        memcpy(buf, tmp, len);
        return len;
        }
</PRE>
<P>
<HR>
<H1><A NAME="NOTES">NOTES</A></H1>
<P>
The old <STRONG>PrivateKey</STRONG> write routines are retained for compatibility. New applications should
write private keys using the <CODE>PEM_write_bio_PKCS8PrivateKey()</CODE>
or <CODE>PEM_write_PKCS8PrivateKey()</CODE> routines because they are more
secure (they use an iteration count of 2048 whereas the traditional
routines use a count of 1) unless compatibility with older versions of
OpenSSL is important.
</P>
<P>
The <STRONG>PrivateKey</STRONG> read routines can be used in all applications because they handle all
formats transparently.
</P>
<P>
A frequent cause of problems is attempting to use the PEM routines like
this:
</P>
<PRE> X509 *x;
 PEM_read_bio_X509(bp, &amp;x, 0, NULL);
</PRE>
<P>
this is a bug because an attempt will be made to reuse the data at <STRONG>x</STRONG>
which is an uninitialised pointer.
</P>
<P>
<HR>
<H1><A NAME="PEM_ENCRYPTION_FORMAT">PEM ENCRYPTION FORMAT</A></H1>
<P>
This old <STRONG>PrivateKey</STRONG> routines use a non standard technique for encryption.
</P>
<P>
The private key (or other data) takes the following form:
</P>
<PRE> -----BEGIN RSA PRIVATE KEY-----
 Proc-Type: 4,ENCRYPTED
 DEK-Info: DES-EDE3-CBC,3F17F5316E2BAC89
</PRE>
<PRE> ...base64 encoded data...
 -----END RSA PRIVATE KEY-----
</PRE>
<P>
The line beginning DEK-Info contains two comma separated pieces of
information: the encryption algorithm name as used by
<CODE>EVP_get_cipherbyname()</CODE> and an 8 byte <STRONG>salt</STRONG> encoded as a set of hexadecimal digits.
</P>
<P>
After this is the base64 encoded encrypted data.
</P>
<P>
The encryption key is determined using <CODE>EVP_BytesToKey(),</CODE> using <STRONG>salt</STRONG> and an iteration count of 1. The IV used is the value of <STRONG>salt</STRONG> and *not* the IV returned by <CODE>EVP_BytesToKey().</CODE>
</P>
<P>
<HR>
<H1><A NAME="BUGS">BUGS</A></H1>
<P>
The PEM read routines in some versions of OpenSSL will not correctly reuse
an existing structure. Therefore the following:
</P>
<PRE> PEM_read_bio_X509(bp, &amp;x, 0, NULL);
</PRE>
<P>
where <STRONG>x</STRONG> already contains a valid certificate, may not work, whereas:
</P>
<PRE> X509_free(x);
 x = PEM_read_bio_X509(bp, NULL, 0, NULL);
</PRE>
<P>
is guaranteed to work.
</P>
<P>
<HR>
<H1><A NAME="RETURN_CODES">RETURN CODES</A></H1>
<P>
The read routines return either a pointer to the structure read or NULL if
an error occurred.
</P>
<P>
The write routines return 1 for success or 0 for failure.
</P>
<P>
<HR>
<H1><A NAME="SEE_ALSO">SEE ALSO</A></H1>
<P>
<EM>EVP_get_cipherbyname(3)</EM>, <A HREF="EVP_BytesToKey.html#">EVP_BytesToKey(3)</A>
</P>
        </td><td align="right" width="20" bgcolor="#ffffff">&nbsp;&nbsp;&nbsp;</td><td align="right" width="50" bgcolor="#666699">&nbsp;</td></tr>
  <tr><td align="left" valign="top" width="100" bgcolor="#666699">&nbsp;</td><td align="left" width="20"><img src="../../images/page-corner-bl.gif" alt="" width="20" height="20"></td><td align="left" valign="top" bgcolor="#ffffff">&nbsp;</td><td align="right" width="20"><img src="../../images/page-corner-br.gif" alt="" width="20" height="20"></td><td align="right" width="50" bgcolor="#666699">&nbsp;</td></tr>
  <tr><td colspan="5" bgcolor="#666699">&nbsp;</td></tr>
</table>
</body>
</html>

